<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java中异常的相关知识</title>
    <url>/2022/10/15/10-15/</url>
    <content><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="因为一些原因导致开发的程序出现问题"><a href="#因为一些原因导致开发的程序出现问题" class="headerlink" title="因为一些原因导致开发的程序出现问题"></a>因为一些原因导致开发的程序出现问题</h3><p>Throwable是error和Exception的父类，是Java里所有异常的父类<br>##error<br>如果出现了error，则代表计算机出现了重大的错误，比如jvm无法解决的问题等。</p>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>如果出现了Exception，则代表计算机代码出现了问题，编译或者运行的时候出现了问题。但是Exception还分为运行时异常和编译时异常</p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>运行时异常比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayIndexOutOfBoundsException//这就是个数组越界的异常</span><br></pre></td></tr></table></figure>

<p>这些都是运行的时候产生的异常，编译可以通过的，其中最常见的就是数组越界，下表越剧等</p>
<h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>编译时异常比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The final local variable m cannot be assigned. It must be blank and not using a compound assignment //这个就是个简单的final修饰的变量不可被改变的异常</span><br></pre></td></tr></table></figure>

<p>这些是在程序未被运行之前就报出的错误。会被编译器会进行优先的处理。<br>最常见的就是作用域的问题，比如static变量和非static的变量等。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><p>我们可以通过try catch的方法进行捕获异常，让异常出现的时候不至于停止程序的运行<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;//放会报错的语句，这个是个简单数组越界</span><br><span class="line">	a[m] = 1;</span><br><span class="line">	System.out.println(&quot;输入正确&quot;);	</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">	// TODO: handle exception</span><br><span class="line">	// 在错误发生时怎么处理</span><br><span class="line">	System.out.println(&quot;成功抛出异常&quot;);</span><br><span class="line">	&#125; </span><br><span class="line">	catch(xxxxx) &#123;</span><br><span class="line">	&#125;// 这里的catch还可以继续往下写，但是要注意其中异常的类型必须是越在后面类型越大的，因为Exception还分多个子类异常，这样可以更精确的分辨是什么异常，不过直接写Exception也不算错</span><br><span class="line">	finally &#123;</span><br><span class="line">		// finally里放一定会执行的代码，不过不写finally也不算错</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是要注意，我们不可以捕获error异常，因为error异常已经超出了代码捕获的范围，我们一般都要进行硬件及软件的处理</p>
<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>我们可以通过throws把异常向上抛出，让他们的上层去处理，可是一般上层如果不能处理，还会继续向上抛出，这种方法我简称为逃避，我们，一般使用try catch语句较多，一般是抛到main方法里进行try catch处理，<br>如果异常一直不处理，那编译器最后会报错</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>数字及big类</title>
    <url>/2022/10/17/10-17/</url>
    <content><![CDATA[<h1 id="关于数学包里常用的几个类"><a href="#关于数学包里常用的几个类" class="headerlink" title="关于数学包里常用的几个类"></a>关于数学包里常用的几个类</h1><h2 id="abs"><a href="#abs" class="headerlink" title="abs"></a>abs</h2><p>abs是取绝对值</p>
<h2 id="cell"><a href="#cell" class="headerlink" title="cell"></a>cell</h2><p>向上（正方向）取整</p>
<h2 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h2><p>向下（负方向）取整</p>
<h2 id="round"><a href="#round" class="headerlink" title="round"></a>round</h2><p> 四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 简单的例子 ，5舍6入</span><br><span class="line">可以通过floor进行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h1><p>BigInteger类型的数字范围较Integer，Long类型的数字范围要大得多，它支持任意精度的整数，也就是说在运算中 BigInteger 类型可以准确地表示任何大小的整数值而不会丢失任何信息。</p>
<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//1.加</span><br><span class="line">BigInteger bigNum1 = a.add(b);			//17</span><br><span class="line">//2.减</span><br><span class="line">BigInteger bigNum2 = a.subtract(b);		//9</span><br><span class="line">//3.乘</span><br><span class="line">BigInteger bigNum3 = a.multiply(b);		//52</span><br><span class="line">//4.除</span><br><span class="line">BigInteger bigNum4 = a.divide(b);		//3</span><br><span class="line">//5.取模(需 b &gt; 0，否则出现异常：ArithmeticException(&quot;BigInteger: modulus not positive&quot;))</span><br><span class="line">BigInteger bigNum5 = a.mod(b);			//1</span><br><span class="line">//6.求余</span><br><span class="line">BigInteger bigNum6 = a.remainder(b);	//1</span><br><span class="line">//7.平方(需 n &gt;= 0，否则出现异常：ArithmeticException(&quot;Negative exponent&quot;))</span><br><span class="line">BigInteger bigNum7 = a.pow(n);			//2197</span><br><span class="line">//8.取绝对值</span><br><span class="line">BigInteger bigNum8 = a.abs();			//13</span><br><span class="line">//9.取相反数</span><br><span class="line">BigInteger bigNum9 = a.negate();		//-13</span><br></pre></td></tr></table></figure>

<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//读入方法：nextBigInteger()</span><br><span class="line">@Test</span><br><span class="line">public void test5() &#123;</span><br><span class="line">	Scanner scan = new Scanner(System.in);				// 读入</span><br><span class="line">	int n = scan.nextInt(); 							// 读入一个int;</span><br><span class="line">	BigInteger m = scan.nextBigInteger();				// 读入一个BigInteger;</span><br><span class="line">	while(scan.hasNext())&#123;	</span><br><span class="line">		System.out.print(&quot;scan.hasNext()=&quot; + scan.hasNext());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中除了这个还有big浮点型，用法和上面一样</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>java里的日期和Object的一些方法</title>
    <url>/2022/10/18/10-18/</url>
    <content><![CDATA[<h1 id="Java-util-Date"><a href="#Java-util-Date" class="headerlink" title="Java.util.Date"></a>Java.util.Date</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date d = new Date();</span><br><span class="line">System.out.Println(d);</span><br></pre></td></tr></table></figure>
<p>一般这样直接打印出，是中国国际化标准化时间<br>但是一般除了getTime别的都过时了，保不准会在什么时候就舍弃</p>
<h2 id="getmonth"><a href="#getmonth" class="headerlink" title="getmonth"></a>getmonth</h2><p>他是用农历算的，范围是0-11</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.getMonth();</span><br></pre></td></tr></table></figure>
<h2 id="getYear"><a href="#getYear" class="headerlink" title="getYear"></a>getYear</h2><p>获取从1900年到现在的年数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.getYear();</span><br></pre></td></tr></table></figure>
<h2 id="getDate"><a href="#getDate" class="headerlink" title="getDate"></a>getDate</h2><p>获取到现在的日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.getDate();</span><br></pre></td></tr></table></figure>
<h2 id="getHours"><a href="#getHours" class="headerlink" title="getHours"></a>getHours</h2><p>获取现在的小时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.getHours();</span><br></pre></td></tr></table></figure>
<h2 id="getMinutes"><a href="#getMinutes" class="headerlink" title="getMinutes"></a>getMinutes</h2><p>获取现在的分钟数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.getMinutes();</span><br></pre></td></tr></table></figure>
<h2 id="getSeconds"><a href="#getSeconds" class="headerlink" title="getSeconds"></a>getSeconds</h2><p>获取当前的秒数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.getSeconds();</span><br></pre></td></tr></table></figure>
<h2 id="getDays"><a href="#getDays" class="headerlink" title="getDays"></a>getDays</h2><p>获取当前日期范围是0-6，周一到周六</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.getDay();</span><br></pre></td></tr></table></figure>
<h2 id="getTime"><a href="#getTime" class="headerlink" title="getTime"></a>getTime</h2><p>获取从1970年到现在时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.getTime();</span><br></pre></td></tr></table></figure>
<h2 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h2><p>自动排序：正数是大于 ， 0是相等 ， -1 是小于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.compareTo(d);</span><br></pre></td></tr></table></figure>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line"> 代表过时的，会让方法上面画上横线</span><br></pre></td></tr></table></figure>
<h1 id="java-sql-Date"><a href="#java-sql-Date" class="headerlink" title="java.sql.Date"></a>java.sql.Date</h1><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.sql.Date d = new java.sql.Date(date.getTime);</span><br><span class="line">// 获取时间,包含天月的</span><br></pre></td></tr></table></figure>
<h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.sql.Time d  = new java.sql.Time(date.getTime);</span><br><span class="line">// 获取时间</span><br></pre></td></tr></table></figure>

<h2 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.sql.Timestamp d = new java.sql.Timestamp(date.getTime);</span><br><span class="line">// 获取精确到毫秒数的时间</span><br></pre></td></tr></table></figure>

<h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy-MM-dd:mm:ss.SSS&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="format日期变字符串"><a href="#format日期变字符串" class="headerlink" title="format日期变字符串"></a>format日期变字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String string s.format(date);</span><br></pre></td></tr></table></figure>

<h2 id="字符串变日期"><a href="#字符串变日期" class="headerlink" title="字符串变日期"></a>字符串变日期</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.parse(&quot;2000-11-12 13:14:15.000&quot;);</span><br><span class="line">// 但是这个可能会有错误，所以，我们需要用try catch包住他</span><br></pre></td></tr></table></figure>
<h1 id="Ccalender"><a href="#Ccalender" class="headerlink" title="Ccalender"></a>Ccalender</h1><p>用静态方法实例化，new 不了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getLnstance();</span><br></pre></td></tr></table></figure>
<h2 id="set设置"><a href="#set设置" class="headerlink" title="set设置"></a>set设置</h2><p>set和get基本相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c1.set(Calendar.MONTH ， xxx)；</span><br><span class="line">c1.set(Calendar.HOURS , xxx);等</span><br><span class="line">// 这里xxx代表一个int型的数字，会自动进位，如果xxx超过11则会自动进位，对其他的小时，秒数也同样是适用</span><br></pre></td></tr></table></figure>

<h2 id="get获取"><a href="#get获取" class="headerlink" title="get获取"></a>get获取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c.get(Calendar.MONTH);</span><br><span class="line">c.get(Calendar.DATE);</span><br><span class="line">等,要通过一系列常量来控制他</span><br></pre></td></tr></table></figure>
<h2 id="add计算"><a href="#add计算" class="headerlink" title="add计算"></a>add计算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c.add(Calendar.MONTH , 1);</span><br><span class="line">// 单纯是加到其中前一个变量上，可以进位。还有其他的方法，比如huors等</span><br></pre></td></tr></table></figure>
<h2 id="getTime-1"><a href="#getTime-1" class="headerlink" title="getTime"></a>getTime</h2><p>转换成Date型，然后就可以用SimpleDateFormat了</p>
<h1 id="Localdate"><a href="#Localdate" class="headerlink" title="Localdate"></a>Localdate</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate l = LocalDate.now(); // 获取当前日期</span><br></pre></td></tr></table></figure>
<ul>
<li><p>最大支持999999999-12-31</p>
</li>
<li><p>最小支持-999999999-01-01</p>
</li>
</ul>
<h2 id="adjiustInto"><a href="#adjiustInto" class="headerlink" title="adjiustInto"></a>adjiustInto</h2><p>调整指定的时间对象与此对象时间相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.adjustInto(l)</span><br></pre></td></tr></table></figure>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>检查这个日期是不是等于另外一个日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.equals(d)</span><br></pre></td></tr></table></figure>
<h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>使用指定格式格式化日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.format(null);</span><br></pre></td></tr></table></figure>

<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h2 id="getDayofMonth"><a href="#getDayofMonth" class="headerlink" title="getDayofMonth"></a>getDayofMonth</h2><p>获取月份字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.getDayofMonth();</span><br></pre></td></tr></table></figure>

<h2 id="getDayofWeek"><a href="#getDayofWeek" class="headerlink" title="getDayofWeek"></a>getDayofWeek</h2><p>同上只是获取星期几，这个是个枚举</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.getDayOfWeek();</span><br></pre></td></tr></table></figure>
<h2 id="getDayofYear"><a href="#getDayofYear" class="headerlink" title="getDayofYear"></a>getDayofYear</h2><p>同上只是获取日期字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.getDayofYear();</span><br></pre></td></tr></table></figure>
<h2 id="getChronology"><a href="#getChronology" class="headerlink" title="getChronology"></a>getChronology</h2><p>获取ios的日历系统的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.getChronology();</span><br></pre></td></tr></table></figure>
<h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h2><p>返回这个日期的哈希码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.hashcode();</span><br></pre></td></tr></table></figure>
<h2 id="isAfter"><a href="#isAfter" class="headerlink" title="isAfter"></a>isAfter</h2><p>检查日期是不是在这个日期之后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.isAfter(l);</span><br></pre></td></tr></table></figure>
<h2 id="isBefore"><a href="#isBefore" class="headerlink" title="isBefore"></a>isBefore</h2><p>同上</p>
<h2 id="isEqual"><a href="#isEqual" class="headerlink" title="isEqual"></a>isEqual</h2><p>检查这个日期是不是等于指定日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.isEqual(l);</span><br></pre></td></tr></table></figure>
<h2 id="isLeapYear"><a href="#isLeapYear" class="headerlink" title="isLeapYear"></a>isLeapYear</h2><p>根据ios日历，检查是不是闰年</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.isLeapYear();</span><br></pre></td></tr></table></figure>

<h2 id="now"><a href="#now" class="headerlink" title="now"></a>now</h2><p>获取当前的时间<br>初始化方法</p>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>同上面的parse</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.parse(null);</span><br></pre></td></tr></table></figure>
<h2 id="plus"><a href="#plus" class="headerlink" title="plus"></a>plus</h2><p>返回此日期的副本，并添加指定的金额。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.plus(null);</span><br></pre></td></tr></table></figure>
<h2 id="plusDays"><a href="#plusDays" class="headerlink" title="plusDays"></a>plusDays</h2><p>返回指定天数的副本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.plusDays(0);</span><br></pre></td></tr></table></figure>
<h2 id="plusMonths"><a href="#plusMonths" class="headerlink" title="plusMonths"></a>plusMonths</h2><p>返回这个LocalDate的副本，其指定的时间段以月为单位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.plusMonths(0);</span><br></pre></td></tr></table></figure>
<h2 id="plusweeks"><a href="#plusweeks" class="headerlink" title="plusweeks"></a>plusweeks</h2><p>返回这个LocalDate的副本并以指定周期添加周数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.plusWeeks(0);</span><br></pre></td></tr></table></figure>
<h2 id="plusYears"><a href="#plusYears" class="headerlink" title="plusYears"></a>plusYears</h2><p>返回这个LocalDate的副本其中指定的时间段以添加的年数访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.plusYears(0);</span><br></pre></td></tr></table></figure>
<h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><p>返回指定的查询查询日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.query(null);</span><br></pre></td></tr></table></figure>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>返回此日期的调整的副本</p>
<ul>
<li>其和上面一样有对单独地方调整的函数，比如日期月份等<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.with(l);</span><br><span class="line">		l.withDayOfMonth(0);</span><br><span class="line">		l.withDayOfYear(0);</span><br><span class="line">		l.withMonth(0);</span><br><span class="line">		l.withYear(0);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>将日期转换为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l.toString();</span><br></pre></td></tr></table></figure>
<h1 id="方法的综合应用"><a href="#方法的综合应用" class="headerlink" title="方法的综合应用"></a>方法的综合应用</h1><h2 id="计算每个月的天数通过Calendar运行"><a href="#计算每个月的天数通过Calendar运行" class="headerlink" title="计算每个月的天数通过Calendar运行"></a>计算每个月的天数通过Calendar运行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C1.add(Calendar.MONTH, 1);</span><br><span class="line">C1.add(Calendar.DAY_OF_MONTH, -(当前天数));</span><br><span class="line">System.out.println(C1.getTime());</span><br></pre></td></tr></table></figure>
<h2 id="LocalDateTime的实际应用"><a href="#LocalDateTime的实际应用" class="headerlink" title="LocalDateTime的实际应用"></a>LocalDateTime的实际应用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.TemporalField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain4</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//		LocalTime</span></span><br><span class="line"><span class="comment">//		LocalDate</span></span><br><span class="line">		<span class="type">LocalDateTime</span> <span class="variable">ldtDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">		System.out.println(ldtDateTime);</span><br><span class="line">		System.out.println(ldtDateTime.getDayOfWeek().getValue()); <span class="comment">// 2</span></span><br><span class="line">		System.out.println(ldtDateTime.getMonth()); <span class="comment">// 10不会走 国外的历法</span></span><br><span class="line">		System.out.println(ldtDateTime.getMonthValue()); </span><br><span class="line">		</span><br><span class="line">		<span class="type">LocalDateTime</span> <span class="variable">ldtDateTime2</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2022</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">		System.out.println(ldtDateTime2);</span><br><span class="line">		</span><br><span class="line">		<span class="type">DateTimeFormatter</span> <span class="variable">dFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> dFormatter.format(ldtDateTime);</span><br><span class="line">		System.out.println(string);</span><br><span class="line">		</span><br><span class="line">		<span class="type">LocalDateTime</span> <span class="variable">ldtDateTime3</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2022-10-18 15:21:30&quot;</span>, dFormatter);</span><br><span class="line">		System.out.println(ldtDateTime3);</span><br><span class="line">		</span><br><span class="line">		<span class="type">LocalDateTime</span> <span class="variable">ldtDateTime4</span> <span class="operator">=</span> LocalDateTime.from(dFormatter.parse(<span class="string">&quot;2022-10-18 15:21:30&quot;</span>));</span><br><span class="line">		System.out.println(ldtDateTime4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><p>获取反射</p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>获取hash值，约等于地址</p>
<h2 id="equals-1"><a href="#equals-1" class="headerlink" title="equals"></a>equals</h2><ul>
<li>比较对象的值</li>
<li>&#x3D;&#x3D;对比的是地址</li>
</ul>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>暂时不让用，意义是克隆属性,但是对于引用类型直接克隆是克隆地址，就会造成改一个进而全部都改变，但是有办法，可以进行深克隆进而解决</p>
<ul>
<li>浅克隆：就是只用一次克隆</li>
<li>深克隆：通过多次克隆进而使每个被克隆出来的个体都有不同地址的相同引用类型</li>
</ul>
<h3 id="使用克隆的方法"><a href="#使用克隆的方法" class="headerlink" title="使用克隆的方法"></a>使用克隆的方法</h3><ul>
<li><p>Cloneable:  标记型接口，先实现标记性接口 。 JDK就2个标记接口Serializable和Cloneable</p>
<ul>
<li><ol>
<li>覆盖Object的clone方法;</li>
<li>实现标记Cloneable;</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>finalize代表GC回调，就是让垃圾回收不要回收他，但是一般不让用，因为会容易造成卡死，或者因为有关联关系的对象而无法进行进行回收</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">  package lesson12;</span><br><span class="line">  </span><br><span class="line">  public class TestMain6 &#123;</span><br><span class="line">  </span><br><span class="line">  	public static void main(String[] args) &#123;</span><br><span class="line">  		Student student = new Student(&quot;jerry&quot;, 2);</span><br><span class="line">  		abc();</span><br><span class="line">  		student = null;</span><br><span class="line">  		System.out.println(111);</span><br><span class="line">  		</span><br><span class="line">  		// 通知jvm在适当时候进行GC</span><br><span class="line">  		System.gc();</span><br><span class="line">  		System.out.println(222);</span><br><span class="line">  		for (;;) &#123;</span><br><span class="line">  			</span><br><span class="line">  		&#125;</span><br><span class="line">  		</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	private static void abc() &#123;</span><br><span class="line">  		// TODO Auto-generated method stub</span><br><span class="line">  		Student student = new Student(&quot;tom&quot;, 1);</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  &#125;</span><br><span class="line">  Student &#123;</span><br><span class="line">  	@Override</span><br><span class="line">  	protected void finalize() throws Throwable &#123;</span><br><span class="line">  		System.out.println(this + &quot;被回收了&quot;);</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="static-代码块和非static代码块"><a href="#static-代码块和非static代码块" class="headerlink" title="static 代码块和非static代码块"></a>static 代码块和非static代码块</h1><ul>
<li><p>static 静态代码块。  运行时记载类，只调用一次。</p>
<ul>
<li>一次性的操作。例如： 加载资源，加载驱动。</li>
</ul>
</li>
<li><p>非静态代码块，       每次实例化都会调用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain7</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是非静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">TestMain7</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestMain7</span>();</span><br><span class="line">		<span class="type">TestMain7</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestMain7</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式和反射</title>
    <url>/2022/10/19/10-19/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul>
<li>一个类只有一个实例</li>
<li>通过private ， 构造方法</li>
<li>static方法</li>
<li>饿汉式</li>
</ul>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class testmain1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		A a1 = A.getInstance();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">	private A() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	private static A a1 = new A();</span><br><span class="line">	public static A getInstance() &#123;</span><br><span class="line">		return a1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>懒汉式</li>
</ul>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;</span><br><span class="line">public class testmain1 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">	A a1 = A.getInstance();</span><br><span class="line">	B a2 = B.getInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">	private B() &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">private static B ai;</span><br><span class="line">public synchronized static B getInstance() &#123;</span><br><span class="line">	if(ai == null) &#123;</span><br><span class="line">		ai = new B();</span><br><span class="line">	&#125;</span><br><span class="line">	return ai;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>开发的时候懒汉式用的比较多，因为可控</li>
<li>但是一般都在懒汉式哪里添加一个线程锁，为了线程安全，就是synchronized</li>
</ul>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><ul>
<li>创建型设计模式</li>
<li>通过方法创建对象</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul>
<li>静态工厂方法模式，例如单例模式，单例模式是特殊的工厂模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Diver &#123;</span><br><span class="line">	public static Car driverCar(String s) &#123;</span><br><span class="line">		if(s.equalsIgnoreCase(&quot;宝马&quot;)) &#123;</span><br><span class="line">			return new Car(&quot;宝马&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(s.equalsIgnoreCase(&quot;奔驰&quot;)) &#123;</span><br><span class="line">			return new Car(&quot;奔驰&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(s.equalsIgnoreCase(&quot;奥迪&quot;)) &#123;</span><br><span class="line">			return new Car(&quot;奥迪&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul>
<li>非静态方法，不同的工厂生成不同的产品</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package factory;</span><br><span class="line">public  class bzfactory &#123;</span><br><span class="line"></span><br><span class="line">public  Car product() &#123;</span><br><span class="line">	return new Car();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class BenzCar extends bzfactory&#123;</span><br><span class="line">public Car product() &#123;</span><br><span class="line">	return new bz();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class bmwfactory extends bzfactory&#123;</span><br><span class="line">public Car product() &#123;</span><br><span class="line">	return new bmw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class bz extends Car&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class bmw extends Car&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class audi extends Car&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样可以不用动代码，可以直接加类，进而直接引</li>
<li>而第一种要把别的人已经打包好的解包进而对其代码进行操作</li>
<li>而这种不用，只要新加几个类就可以</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><ul>
<li>工厂的工厂模式</li>
<li>给用户提供一个接口，可以创建多个产品族中的对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	package com.icss.javasechapter.factory;</span><br><span class="line">//抽象工厂模式</span><br><span class="line">	interface Car&#123;</span><br><span class="line">		public void drive();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	interface SportsCar extends Car&#123;</span><br><span class="line">		public boolean isConvertible();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	interface BussinessCar extends Car&#123;</span><br><span class="line">		public boolean isAutoDoor();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 具体产品角色</span><br><span class="line">	class BenzSprotsCar implements SportsCar &#123;</span><br><span class="line">		public void drive() &#123;</span><br><span class="line">			System.out.println(&quot;Driving Benz S&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public boolean isConvertible() &#123;</span><br><span class="line">			// TODO Auto-generated method stub</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	class BenzBussinessCar implements BussinessCar &#123;</span><br><span class="line">		public void drive() &#123;</span><br><span class="line">			System.out.println(&quot;Driving Benz B&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">		public boolean isAutoDoor() &#123;</span><br><span class="line">			// TODO Auto-generated method stub</span><br><span class="line">			return false;</span><br><span class="line">				&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class BmwSprotsCar implements SportsCar &#123;</span><br><span class="line">		public void drive() &#123;</span><br><span class="line">			System.out.println(&quot;Driving Bmw S &quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public boolean isConvertible() &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	class BmwBussinessCar implements BussinessCar &#123;</span><br><span class="line">		public void drive() &#123;</span><br><span class="line">			System.out.println(&quot;Driving Bmw B &quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public boolean isAutoDoor() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return false;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	interface CarFactory&#123;</span><br><span class="line">		public SportsCar getSportsCar();</span><br><span class="line">		public BussinessCar getBussinessCar();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	class BenzCarFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public SportsCar getSportsCar() &#123;</span><br><span class="line">			// TODO Auto-generated method stub</span><br><span class="line">			return new BenzSprotsCar();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public BussinessCar getBussinessCar() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return new BenzBussinessCar();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class BmwCarFactroy implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public SportsCar getSportsCar() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">			return new BmwSprotsCar();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public BussinessCar getBussinessCar() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">			return new BmwBussinessCar();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 抽象产品角色，具体产品角色与简单工厂模式类似，只是变得复杂了些，这里略。</span><br><span class="line">	// 抽象工厂角色</span><br><span class="line">	class AbstractCarFactory&#123;</span><br><span class="line">	</span><br><span class="line">	public static CarFactory getCarFactory(String name)&#123;</span><br><span class="line">		if(&quot;Benz&quot;.equals(name))&#123;</span><br><span class="line">			return new BenzCarFactory();</span><br><span class="line">		&#125;else if(&quot;Bmw&quot;.equals(name))&#123;</span><br><span class="line">			return new BmwCarFactroy();</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			throw new RuntimeException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public class MagnateAbstractFactory &#123;</span><br><span class="line">		public static void main(String[] args) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				CarFactory factory = AbstractCarFactory.getCarFactory(&quot;Bmw&quot;);</span><br><span class="line">				BussinessCar car = factory.getBussinessCar();</span><br><span class="line">				car.drive();</span><br><span class="line">				System.out.println(car.isAutoDoor());</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul>
<li>订阅与发布</li>
<li>java通过Observable和Observer来实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 作业;</span><br><span class="line"></span><br><span class="line">public class lesson13 &#123;</span><br><span class="line"></span><br><span class="line">	public int aaa =0;</span><br><span class="line">	public MyObsever[] array = new MyObsever[10];</span><br><span class="line">	int index = -1;</span><br><span class="line">	public void addObsever(MyObsever obs) &#123;</span><br><span class="line">			array[++index &gt; 9 ? index = 0 : index] =obs;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAaa(int newvalue) &#123;</span><br><span class="line">		this.aaa = newvalue;</span><br><span class="line">		for(int i =0; i &lt; array.length ; i++) &#123;</span><br><span class="line">			if(array[i] == null)break;</span><br><span class="line">				array[i].update(this.aaa , newvalue);</span><br><span class="line">			&#125;</span><br><span class="line">		this.aaa = newvalue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyObsever ob = new MyObsever();</span><br><span class="line">		lesson13 data = new lesson13();</span><br><span class="line">		data.addObsever(ob);</span><br><span class="line">		data.setAaa(10000);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyObsever &#123;</span><br><span class="line">	String name;</span><br><span class="line">	public void update(int aaa , int newvalue) &#123;</span><br><span class="line">		System.out.println(&quot;观察者&quot; + this.name + &quot;,&quot; + aaa + &quot;变成&quot; + newvalue);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>简单来说就是群发消息，或者说是改变github上的代码的那种改变</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul>
<li>代理模式给一个对象提供代理对象，比如代打，比如代刷xxx等<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 作业;</span><br><span class="line">public class TestMain4 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		Target t = new Target();</span><br><span class="line">		Proxy proxy = new Proxy();</span><br><span class="line">		proxy.target = t;</span><br><span class="line">		proxy.price();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Target &#123;</span><br><span class="line">	public void price() &#123;</span><br><span class="line">		System.out.println(&quot;---100--&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Proxy &#123;</span><br><span class="line">	Target target;</span><br><span class="line">	public void price() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(&quot;100&quot;);</span><br><span class="line">			target.price();</span><br><span class="line">			System.out.println(&quot;50&quot;);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO: handle exception</span><br><span class="line">			System.out.println(&quot;10&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>就相当于中间商赚差价，商家会把货发送到代理这里，代理再提高价格发送出去，上面的这个叫静态代理</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul>
<li>动态代理要用接口来实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package lesson13;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.nio.channels.NonWritableChannelException;</span><br><span class="line">public class TestMain4 &#123;</span><br><span class="line">	public static void main(String[] args) // 主方法调用代理的 </span><br><span class="line">	&#123;</span><br><span class="line">		DynamicTargetInf inf = DynamicProxFactory.getInstance();	</span><br><span class="line">		inf.price();</span><br><span class="line">		int r = inf.add(1, 2);</span><br><span class="line">		System.out.println(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface DynamicTargetInf // 要代理的接口 </span><br><span class="line">&#123;</span><br><span class="line">	void price();</span><br><span class="line">	int add(int i, int j);</span><br><span class="line">&#125;</span><br><span class="line">class DynamicTarget implements DynamicTargetInf // 要代理的目标类，我们接下来要代理这里的方法</span><br><span class="line">&#123;</span><br><span class="line">	public void price() &#123;</span><br><span class="line">		System.out.println(&quot;--target-100--&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int add(int i, int j) &#123;</span><br><span class="line">		System.out.println(&quot;--target-i + j--&quot;);</span><br><span class="line">		return i + j;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// invocationHandle   invoke执行 handle句柄    welcome,xxx</span><br><span class="line">	class DynamicProxFactory implements InvocationHandler // 代理控制器，就是代理对象每次要运行方法都要经过他</span><br><span class="line">	&#123;</span><br><span class="line">	DynamicTargetInf target = new DynamicTarget();	// 一般这个地方是要传值进来的，不过这里为了方便，我们就直接赋值了</span><br><span class="line">	// 代理对象每次运行方法的时候会执行</span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable // invoke方法是InvocationHandler接口的方法，这个方法是执行的意思</span><br><span class="line">	&#123;</span><br><span class="line">			Object result = null; // 定义一个返回值 ，Object类代表可以转化成任何类型</span><br><span class="line">		try &#123;  // try catch包裹，一是为了判断是不是出错，二是为了安全性</span><br><span class="line">		System.out.println(&quot;-之前-100---&quot;);</span><br><span class="line">		// 反射。当前方法执行。target对象的当前方法， args方法的参数</span><br><span class="line">		result = method.invoke(target, args);</span><br><span class="line">		//	target.price();</span><br><span class="line">		System.out.println(&quot;-之后-50---&quot;);	</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		System.out.println(&quot;-异常-10---&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">	&#125;</span><br><span class="line">	public static DynamicTargetInf getInstance() // 要代理的目标的接口的实例化方法 ， 通过这个方法会把要代理对象的接口和代理工厂连接到一起</span><br><span class="line">	&#123;</span><br><span class="line">	Object object = java.lang.reflect.Proxy.newProxyInstance(DynamicProxFactory.class.getClassLoader(), new Class[] &#123;DynamicTargetInf.class&#125;, new DynamicProxFactory()); // 这里的三个参数其实是，第一个是类加载器 ， 第二个是目标接口的类数组 ， 第三个是代理工厂的句柄，也就是句柄</span><br><span class="line">	return (DynamicTargetInf) object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于静态的代理，每一个方法都要写一个代理，于是就很麻烦，可是对于动态的代理，他会自动的把那个方法里的方法都代理一边，只要在主函数里调用就行，</li>
<li>其实基本上思想就是，把要代理的目标变成一个接口，然后通过实例化这个接口，再通过接口的特性，让代理去实现目标的方法</li>
<li>私有的方法无法代理</li>
</ul>
<h1 id="反射，类的类型"><a href="#反射，类的类型" class="headerlink" title="反射，类的类型"></a>反射，类的类型</h1><p>类的类型，就是所有类都可以有的东西比如：属性，构造方法，方法。</p>
<ul>
<li>可以用这些类的类型去创建一个新类</li>
<li>而我们如果想获取这个类的类型，就要用到反射，</li>
<li>他可以获取这个类的类型，就是上面说的属性，构造方法，方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">public class wjw1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// 获取反射的三种方式 第一种</span><br><span class="line">	Class clzz1 = student.class;</span><br><span class="line">	// 第二中 </span><br><span class="line">	student student = new student();</span><br><span class="line">	Class a = student.getClass();</span><br><span class="line">	// 第三种</span><br><span class="line">	try &#123;</span><br><span class="line">		Class ae = Class.forName(&quot;作业.student&quot;);</span><br><span class="line">	&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Constructor[] cons = clzz1.getConstructors(); // 查看构造器</span><br><span class="line">	for (int i = 0; i &lt; cons.length; i++) &#123;</span><br><span class="line">		System.out.println(cons[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	Field[] d = a.getFields(); // 查看变量，非私有的</span><br><span class="line">	for (int i = 0; i &lt; d.length; i++) &#123;</span><br><span class="line">		System.out.println(d[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	Field[] f = a.getDeclaredFields(); // 私有变量只能这样查看</span><br><span class="line">	for (int i = 0; i &lt; f.length; i++) &#123;</span><br><span class="line">		System.out.println(f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">		Constructor Con; // 获取有特定参数的构造器</span><br><span class="line">	try &#123;</span><br><span class="line">		Con = clzz1.getConstructor(new Class[] &#123;String.class , int.class&#125;);//里面放那个类型的对应的.class</span><br><span class="line">		&#125; catch (NoSuchMethodException | SecurityException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123; // 通过反射进行实例化，证明了，实例化不一定非要用new</span><br><span class="line">		Object object = Con.newInstance(new Object[] &#123;343,&quot;sdajkdha&quot;&#125;);</span><br><span class="line">		&#125; catch (InstantiationException | IllegalAccessException | IllegalArgumentException</span><br><span class="line">			| InvocationTargetException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面，是我们要运行的方法里如何写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;	</span><br><span class="line">public class student &#123;</span><br><span class="line">private String name;</span><br><span class="line">private String num;</span><br><span class="line">private String sex;</span><br><span class="line">public int age;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">	return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public String getNum() &#123;</span><br><span class="line">	return num;</span><br><span class="line">&#125;</span><br><span class="line">public void setNum(String num) &#123;</span><br><span class="line">	this.num = num;</span><br><span class="line">&#125;</span><br><span class="line">public String getSex() &#123;</span><br><span class="line">	return sex;</span><br><span class="line">&#125;</span><br><span class="line">public void setSex(String sex) &#123;</span><br><span class="line">	this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">	return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">public student() &#123;</span><br><span class="line">	super();</span><br><span class="line">	// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">public student( int x , String name) &#123;</span><br><span class="line">	this.age = x;</span><br><span class="line">	this.name = name;</span><br><span class="line">	// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">clzz1.getMethods() // 获取里面所有可以访问的方法</span><br><span class="line">clzz1.getMethod(name, parameterTypes) // 获取特定的可以访问的方法</span><br><span class="line">clzz1.getDeclaredMethod(name, parameterTypes); // 查找特定参数的自己定义的方法</span><br><span class="line">clzz1.getDeclaredMethods(); // 查询所有自己定义的方法</span><br><span class="line">Method m = clzz1.getDeclaredMethod(name, parameterTypes);</span><br><span class="line">Object r = m.invoke(obj, args); // 执行前面一个参数里的方法m方法 ， 后面的一个是这个方法的参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Field f1 =	clzz1.getField(&quot;name&quot;); // 获取单独的与里面字符串匹配的变量 ， 如果是私有的要用declaer方法，比如</span><br><span class="line"> Field f2 = clzz1.getDeclaredField(&quot;name&quot;); // 可以获取私有的变量</span><br><span class="line"> f1.setAccessible(true); // 修改访问权限修饰符，true代表public false代表private</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>下面只是个普通的方法</li>
<li>这是两个class，要注意，因为都是public，所以必须单独建立两个class，才可以</li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><ul>
<li><p>用@interface</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 作业;</span><br><span class="line">@Target (value = &#123;ElementType.CONSTRUCTOR,ElementType.FIELD,ElementType.METHOD,ElementType.TYPE&#125;) // target是代表要修饰的目标种类，比如方法，构造器，属性等</span><br><span class="line">@Retention(value = RetentionPolicy.SOURCE) // 代表这个存活的位置，一般我们用不到，这个是存活于源码里，编译之后就无了</span><br><span class="line">@Retention(value = RetentionPolicy.CLASS) // 这个是存活与class中</span><br><span class="line">@Retention(value = RetentionPolicy.RUNTIME) // 这个是存活在运行时</span><br><span class="line">public @interface lesson14 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的@Retention只能用一个，而且只能选择一个</p>
</li>
<li><p>而后再有一个类</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 作业;</span><br><span class="line">@lesson14</span><br><span class="line">public class try1 &#123;</span><br><span class="line">	@lesson14</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面是一般用法。</li>
<li>如果在接口上面增加@Target，就是代表让你可以修饰的东西</li>
<li>@Retention 代表设置其存活的地方</li>
</ul>
<h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p>可以在接口内写value，如果加上了value则在引用的时候要在括号内写上内容<br>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public @interface lesson14 &#123;</span><br><span class="line">String value()</span><br><span class="line">default &quot;默认信息&quot;; // 代表默认值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@lesson14(&quot;klsdajhal&quot;)</span><br><span class="line">或者@lesson14(value = &quot;sadajd&quot;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>io流</title>
    <url>/2022/10/20/10-20/</url>
    <content><![CDATA[<h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><ul>
<li>字节流的结尾一般都是InputStream ， OutputStream</li>
<li>是个抽象类</li>
<li>可以自动关闭</li>
<li>顶层类，上面就是Object</li>
<li>这个东西是要有参照物的</li>
</ul>
<h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 作业;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">public class sd3333sdfse &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		OutputStream os1;</span><br><span class="line">		try &#123;</span><br><span class="line">			os1 = new FileOutputStream( new File(&quot;D:\\a.txt&quot;), false); // 这个false代表是覆盖源文件，如果是true就是把字符串加入</span><br><span class="line">			String s = &quot;hello word&quot;;</span><br><span class="line">			os1.write(s.getBytes());</span><br><span class="line">			os1.flush();  // 落盘到磁盘上</span><br><span class="line">			os1.close(); // 关闭文件输出流</span><br><span class="line">		&#125; catch (FileNotFoundException e1) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">public class read &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	try &#123;</span><br><span class="line">		InputStream is = new FileInputStream(&quot;D:/a.txt&quot;);</span><br><span class="line">//			while(is.available() != 0) &#123;</span><br><span class="line">//				System.out.println((char)is.read()); // 默认一次只读一个字符</span><br><span class="line">//			&#125;</span><br><span class="line">		</span><br><span class="line">		byte[] buffer = new byte[10]; // 通过设置缓冲区进行扩展一次可读的字符数量，如果是字符型，那这个byte要变char</span><br><span class="line">		int len = 0; // 设置个长度</span><br><span class="line">		while((len = is.read(buffer)) != -1) // 判断我是不是超出缓冲区的限定，如果超出，就只读取超出的部分</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(new String(buffer , 0 , len)); </span><br><span class="line">		&#125;</span><br><span class="line">		is.close();</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>定义：File d &#x3D; new File(“XXxxx”，”name”); &#x2F;&#x2F; 这里XXxxx是文件目录 , 第二个是文件名字</li>
<li>文件或者目录</li>
</ul>
<h2 id="exist（）"><a href="#exist（）" class="headerlink" title="exist（）"></a>exist（）</h2><ul>
<li>文件是有大小的，目录是无大小</li>
<li>判断文件&#x2F;目录是不是存在</li>
</ul>
<h2 id="isFile"><a href="#isFile" class="headerlink" title="isFile"></a>isFile</h2><ul>
<li>代表判断是不是文件</li>
</ul>
<h2 id="isDirectory"><a href="#isDirectory" class="headerlink" title="isDirectory"></a>isDirectory</h2><ul>
<li>代表是不是文件夹</li>
</ul>
<h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><ul>
<li>代表查看其字节的长度，大小，但是文件有大小，目录无大小</li>
</ul>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><ul>
<li>代表删除文件，注意这里删除的文件不是送进回收站里的，如果要删除目录，要先把里面的文件清空</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">public class file &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">	File m = new File(&quot;D:\\&quot; , &quot;a.txt&quot;);</span><br><span class="line">	File k = new File(&quot;D//&quot;);</span><br><span class="line">	System.out.println(m.exists());</span><br><span class="line">	System.out.println(k.exists());</span><br><span class="line">	System.out.println(k.isFile());</span><br><span class="line">	System.out.println(m.isDirectory());</span><br><span class="line">	System.out.println(k.length());</span><br><span class="line">	System.out.println(k.delete());</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void SHANCHU(File k) &#123;</span><br><span class="line">	File[] ds =	k.listFiles(); </span><br><span class="line">	for (int i = 0; i &lt; ds.length ; i++ ) &#123;</span><br><span class="line">		File[] h = ds[i].listFiles();</span><br><span class="line">		if(h == null) &#123;</span><br><span class="line">			System.out.println(&quot;这个是个文件&quot;);</span><br><span class="line">			ds[i].delete();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			k.delete();</span><br><span class="line">			SHANCHU(ds[i]);</span><br><span class="line">				&#125;</span><br><span class="line">		k.delete();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="makedir"><a href="#makedir" class="headerlink" title="makedir"></a>makedir</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 作业;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">public class adsgqjd &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">	File file = new File(&quot;D:/a/abc.txt&quot;);</span><br><span class="line">	System.out.println(file.exists());</span><br><span class="line">	System.out.println(file.mkdir());</span><br><span class="line">	File file2 =new File(&quot;D:/a/c/v/bv/nb&quot;);</span><br><span class="line">	System.out.println(file2.mkdirs());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们通过mkdirs可以直接深度创建</li>
<li>但是如果没有父目录，一般的文件就无法创建</li>
</ul>
<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static File getCopy(File f1) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	String sufString = f1.getName().substring(f1.getName().lastIndexOf(&quot;.&quot;));</span><br><span class="line">	String qi = f1.getName().substring(0, f1.getName().lastIndexOf(&quot;.&quot;));</span><br><span class="line">	String use = qi + &quot;-副本&quot; + sufString;</span><br><span class="line">	File newf = new File(f1.getParent() , use);</span><br><span class="line">	if(newf.exists()) &#123;</span><br><span class="line">	return	getCopy(newf);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	return newf;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>字符流</title>
    <url>/2022/10/21/10-21/</url>
    <content><![CDATA[<h1 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h1><ul>
<li>Write是抽象方法</li>
<li>其里面定义了传输大小（在源码中）</li>
<li>在write里<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int WRITE_BUFFER_SIZE = 1024;</span><br></pre></td></tr></table></figure></li>
<li>所谓的字符流只是把字节流包装起来，证据在源码里<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 项目实训;</span><br><span class="line"></span><br><span class="line">	import java.io.FileWriter;</span><br><span class="line">	import java.io.IOException;</span><br><span class="line">	import java.io.Writer;</span><br><span class="line"></span><br><span class="line">	public class char流 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		Writer w = new FileWriter(&quot;D:/a.txt&quot;);</span><br><span class="line">		w.write(&quot;hello world&quot;);</span><br><span class="line">		w.append(&quot;hello Bgido&quot;);</span><br><span class="line">		w.write(&quot;hello java&quot;.toCharArray());</span><br><span class="line">		w.flush();</span><br><span class="line">		w.close();</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意这里的write是直接在文件里重写数据，而append是增加数据，因为write底层调用的是write方法</li>
</ul>
<h1 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h1><ul>
<li>出现的原因，是因为字节流可能存不住，所以才出现，会造成乱码</li>
</ul>
<h2 id="字符分类以及编码格式"><a href="#字符分类以及编码格式" class="headerlink" title="字符分类以及编码格式"></a>字符分类以及编码格式</h2><ul>
<li><p>一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。</p>
</li>
<li><p>ASCII 码中，一个英文字母(不分大小写)为一个字节，一个中文汉字为两个字节。</p>
</li>
<li><p>UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。</p>
</li>
<li><p>Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</p>
</li>
<li><p>符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号 。占2个字节的大小。</p>
</li>
<li><p>UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节(Unicode 扩展区的一些汉字存储需要 4 个字节)。</p>
</li>
<li><p>UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 项目实训;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">public class inputchar1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	try &#123;</span><br><span class="line">		Reader reader = new FileReader(&quot;D:/a.txt&quot;);</span><br><span class="line">		reader.close();</span><br><span class="line">		// 这个也可以读取文件</span><br><span class="line">		Reader reader1 = new InputStreamReader(new FileInputStream(&quot;D:/a.txt&quot;) , &quot;UTF-8&quot;); // 古老的方式，不过可以直接改代码的编码格式</span><br><span class="line">		char[] buffer = new char[10];</span><br><span class="line">		int len = 0;</span><br><span class="line">		while((len = reader1.read(buffer)) != -1) &#123;</span><br><span class="line">			System.out.print(new String(buffer , 0 ,len));</span><br><span class="line">		&#125;</span><br><span class="line">		reader1.close();</span><br><span class="line">		while((len = reader.read(buffer)) != -1) &#123;</span><br><span class="line">			System.out.print(new String(buffer, 0, len));</span><br><span class="line">		&#125;</span><br><span class="line">		reader.close();</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		// TODO: handle exception</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="具体的流"><a href="#具体的流" class="headerlink" title="具体的流"></a>具体的流</h1><h2 id="buffered系类"><a href="#buffered系类" class="headerlink" title="buffered系类"></a>buffered系类</h2><ul>
<li>代表缓冲区系类</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 项目实训;</span><br><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class sdahasdk &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		BufferedInputStream us = new BufferedInputStream(new FileInputStream(&quot;D:/a.txt&quot;)); // 要自己定义缓冲区</span><br><span class="line">		us.skip(1);</span><br><span class="line">		byte[] buffer = new byte[10];</span><br><span class="line">		int len = 0;</span><br><span class="line">		while((len = us.read(buffer)) != -1) &#123;</span><br><span class="line">			System.out.println( new String(buffer , 0 ,len ));</span><br><span class="line">		&#125;</span><br><span class="line">		us.close();</span><br><span class="line">		</span><br><span class="line">		BufferedReader r = new BufferedReader(new FileReader(&quot;D:/a.txt&quot;)); // 里面有设置默认的缓冲区在源码里可以点进去查看</span><br><span class="line">		while(r.ready()) // ready是可读性，可读就true，不可读就fasle</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(	r.readLine());</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>只有顶层类的方法是没有线程锁的</li>
<li>同样也有writer的方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedWriter wwe = new BufferedWriter( new FileWriter(&quot;D:/a.txt&quot;));</span><br></pre></td></tr></table></figure></li>
<li>然后通过wwe.xxx访问方法</li>
</ul>
<h1 id="InputStreamReader-x2F-Writer"><a href="#InputStreamReader-x2F-Writer" class="headerlink" title="InputStreamReader&#x2F;Writer"></a>InputStreamReader&#x2F;Writer</h1><ul>
<li>比较古老</li>
<li>因为可以设置编码格式</li>
<li>在构造方法里</li>
<li>和上面的FileInputStream一样</li>
</ul>
<h1 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 项目实训;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">public class stu implements Serializable&#123;</span><br><span class="line">public stu() &#123;</span><br><span class="line">	super();</span><br><span class="line">	// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">public stu(int x , String name) &#123;</span><br><span class="line">	this.age = x;</span><br><span class="line">	this.name = name;</span><br><span class="line">	// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">private String name;</span><br><span class="line">private transient int age;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">	return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">	return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">	return &quot;stu [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这个是个学生类，代表我们要实例化的类，要加个可序列化的标记性接口</li>
<li>transient是不参与序列化的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 项目实训;</span><br><span class="line"></span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class lesson15 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(&quot;D:/student.dat&quot;));</span><br><span class="line">			stu s = new stu(15 , &quot;tom&quot;);</span><br><span class="line">			oo.writeObject(s);</span><br><span class="line">			oo.flush();</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 项目实训;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">public class lesson15 &#123;	</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		</span><br><span class="line">		ObjectInputStream d = new ObjectInputStream(new FileInputStream(&quot;D:/student.dat&quot;));</span><br><span class="line">		Object o = d.readObject();</span><br><span class="line">		System.out.println(o);</span><br><span class="line">		d.close();</span><br><span class="line">		</span><br><span class="line">	&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 项目实训;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class scanner &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		Scanner scanner = new Scanner( new FileInputStream(&quot;D:/a.txt&quot;) , &quot;UTF-8&quot;);</span><br><span class="line">		while(scanner.hasNext()) &#123;</span><br><span class="line">			System.out.println(scanner.nextLine());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Channnel流"><a href="#Channnel流" class="headerlink" title="Channnel流"></a>Channnel流</h1><ul>
<li>其是新io包里的</li>
<li>是nio里的，用的是堆外内存</li>
<li>就是jvm内存，所以效率会比在堆里的数组缓冲区效率更高</li>
<li>追主要的是对接，管道分为输入管道和输出管道</li>
<li>当他们对接上就可以实现复制等操作了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 项目实训;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">public class Channel &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	File file = new File(&quot;D:/a.txt&quot;);</span><br><span class="line">	FileInputStream ii;</span><br><span class="line">	try &#123;</span><br><span class="line">		ii = new FileInputStream(file);</span><br><span class="line">		FileChannel cha = ii.getChannel();</span><br><span class="line">		FileChannel out = new FileOutputStream(&quot;D:/a1.txt&quot;).getChannel();		</span><br><span class="line">		cha.transferTo(0, file.length(), out); // 这个输入管道的对接口 三个参数 ，第一个是开始复制的起始下标，第二个是文件长度 ，第三个是输出管道</span><br><span class="line">		out.transferFrom(cha, 0, file.length()); // 这个是输出管道的接口 三个参数 ，第一个是输入管道，第二个是起始下标 ，第三个是文件长度</span><br><span class="line">	&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>两种管道对接的方式造成的结果是一样的，都是复制文件，但是如果这两个代码要制作的文件存在，则进行覆盖</li>
</ul>
<h1 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h1><ul>
<li>解决字符串的加法的问题，</li>
<li>字符串的+是方法的重载，每次都会返回一个对象</li>
<li>而下面两个则是用堆运存运算省区了一个变量</li>
<li>而builder无线程锁，所以比buffer要快<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 项目实训;</span><br><span class="line">public class sr &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	String s = &quot;shdghgsg&quot;;</span><br><span class="line">	long start = System.currentTimeMillis();</span><br><span class="line">	 // 拼接太费事</span><br><span class="line">	String h = s + &quot;shak&quot;;</span><br><span class="line">	long end = System.currentTimeMillis();</span><br><span class="line">	StringBuffer sb =new StringBuffer();</span><br><span class="line">	System.out.println(end - start);</span><br><span class="line">	sb.append(&quot;world&quot;);</span><br><span class="line">	long start1 = System.currentTimeMillis();</span><br><span class="line">	 // 拼接太费事</span><br><span class="line">	sb.append(&quot;world&quot;);</span><br><span class="line">	long end1 = System.currentTimeMillis();</span><br><span class="line">	System.out.println(end1 - start1);</span><br><span class="line">	 // 更快的</span><br><span class="line">	StringBuilder sd = new StringBuilder();</span><br><span class="line">	long start2 = System.currentTimeMillis();</span><br><span class="line">	 // 拼接太费事</span><br><span class="line">	sd.append(&quot;world&quot;);</span><br><span class="line">	long end2 = System.currentTimeMillis();</span><br><span class="line">	System.out.println(end2 - start2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="比较快的排序方式"><a href="#比较快的排序方式" class="headerlink" title="比较快的排序方式"></a>比较快的排序方式</h2><ul>
<li>Arrays.sort(要排序的数组)默认是正序</li>
<li>也可以变成倒序，但是要是泛型数组就可以</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int[] a = &#123;3,4,5,1,3,5,5&#125;;</span><br><span class="line">Arrays.sort(a);</span><br><span class="line">for (int i : a) &#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li>进程是程序对应的资源</li>
<li>线程是cpu运行的最小单位</li>
<li>线程是随机切换，一个程序中</li>
</ul>
<h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 项目实训;</span><br><span class="line"></span><br><span class="line">public class xiancheng &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">	System.out.println(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">	Task1 task1 = new Task1();</span><br><span class="line">	Thread t1 = new Thread(task1);</span><br><span class="line">	t1.setName(&quot;第一个线程&quot;); // 线程的名字</span><br><span class="line">	t1.start(); // 线程开始</span><br><span class="line">	new Thread(task1).start(); // 这种方式也可以进行线程启动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Task1 implements Runnable // 任务</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	for (int i = 0; i &lt;101; i++) &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(Thread.currentThread() + &quot;@&quot; +i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在做一件事的时候还是单线程比较快，多线程可以一起干很多事情，所以就相当于一个人和多个人的差距</li>
<li>意思就是单线程不一定比多线程慢，因为多线程存在上下文切换</li>
<li>首先分配cpu资源的单位是进程。一个进程所获得到的cpu资源是一定的。程序在执行的过程中消耗的是cpu，比如一个单核cpu，多个线程同时执行工作时，需要不断切换执行(上下文切换)，单个线程时间耗费更多了，而单线程只是一个线程跑。</li>
<li>多线程的总体执行时间和单线程是一样的，但是多线程中单个线程的执行时间是单线程的多倍。<br>多线程提高的是并发数量，比如现在有一个4核cpu的服务器，同一时间可执行4个线程，这样处理线程任务的速度比较快。但是多出来的线程，5个，6个，7个，多出的线程还是要等待。</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以说其实多线程不一定能够比单线程快是因为上下文切换，以及线程等待的问题</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2022/10/24/10-24/</url>
    <content><![CDATA[<h1 id="线程的概念以及原理"><a href="#线程的概念以及原理" class="headerlink" title="线程的概念以及原理"></a>线程的概念以及原理</h1><h2 id="操作系统中线程和进程的概念"><a href="#操作系统中线程和进程的概念" class="headerlink" title="操作系统中线程和进程的概念"></a>操作系统中线程和进程的概念</h2><ul>
<li>进程是指一个内存中运行的应用程序，每个进程都有自己的独立空间，一个进程中可以启动多个线程，比如在windows里一个运行的exe就是一个进程</li>
<li>线程是指进程中的一个执行流程，一个进程中可以用运行多个线程。线程总是属于某个进程的，进程中多个线程共享进程的内存</li>
</ul>
<h2 id="java中的线程"><a href="#java中的线程" class="headerlink" title="java中的线程"></a>java中的线程</h2><ul>
<li>在java中，线程是指两件不同的事</li>
<li>java.lang.Thread类的一个实例</li>
<li>线程的执行</li>
<li>使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义实例化，和启动新线程。</li>
<li>一个Thread类实例只是一个对象，像java和其他对象一样，有变量和方法，生死于堆上</li>
<li>在java里每个线程都拥有一个调用栈，即使不在程序中创建任何的新线程，线程也会在后台运行着</li>
<li>一个java应用总是从main方法开始，main方法运行在一个线程里，他被称为主线程</li>
<li>一旦创建一个线程，就会产生一个新的栈调用。</li>
<li>线程总体分为两类，用户线程和守护线程</li>
<li>当所有用户距线程执行完毕，jvm自己关闭，守护线程一般是由操作系统或者或者用户自己创建</li>
</ul>
<h1 id="创建与启动"><a href="#创建与启动" class="headerlink" title="创建与启动"></a>创建与启动</h1><ul>
<li><p>扩展java.lang.Thread</p>
</li>
<li><p>这个类中有个run方法，应该注意其用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void run()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果该线程是使用独立的Runnable运行对象构造的，则调用该Runnable对象的run方法，要不然，该方法不执行任何操作并返回</p>
</li>
<li><p>Thread的子类应该重写这个方法，因为其底层也是继承的Runnable接口</p>
</li>
<li><p>run操作里是他会执行的事情</p>
</li>
</ul>
<h2 id="实例化线程"><a href="#实例化线程" class="headerlink" title="实例化线程"></a>实例化线程</h2><ul>
<li>如果是用Thread，则直接new就行</li>
<li>如果是实现了，java.lang.Runnable接口的类，则用Thread的构造方法:</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target , String name)</span><br><span class="line">Thread(ThreadGroup group, Runnable target)</span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name)</span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name, long stackSize)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><ul>
<li>在线程的Thread对象上调用Start（）方法而不是用run或者别的</li>
<li>在调用start之前线程处于新状态中，新状态指有一个Thread对象，但是还没有一个真正的线程</li>
<li>调用了之后发生了一系列复杂的事情</li>
<li>尝试启动新的线程（具有新的调用栈）</li>
<li>该线程从新状态转移到可运行状态</li>
<li>当线程获得执行机会，就会调用run</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 实现Runnable接口的类</span><br><span class="line">*</span><br><span class="line">* @author leizhimin 2008-9-13 18:12:10</span><br><span class="line">*/</span><br><span class="line">publicclass DoSomethingimplements Runnable &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public DoSomething(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicvoid run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            for (long k = 0; k &lt; 100000000; k++) ;</span><br><span class="line">            System.out.println(name + &quot;: &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">* 测试Runnable类实现的多线程程序</span><br><span class="line">*</span><br><span class="line">* @author leizhimin 2008-9-13 18:15:02</span><br><span class="line">*/</span><br><span class="line">publicclass TestRunnable &#123;</span><br><span class="line">    publicstaticvoid main(String[] args) &#123;</span><br><span class="line">        DoSomething ds1 = new DoSomething(&quot;阿三&quot;);</span><br><span class="line">        DoSomething ds2 = new DoSomething(&quot;李四&quot;);</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(ds1);</span><br><span class="line">        Thread t2 = new Thread(ds2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展Thread类实现多线程的例子"><a href="#扩展Thread类实现多线程的例子" class="headerlink" title="扩展Thread类实现多线程的例子"></a>扩展Thread类实现多线程的例子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 测试扩展Thread类实现的多线程程序</span><br><span class="line">*</span><br><span class="line">* @author leizhimin 2008-9-13 18:22:13</span><br><span class="line">*/</span><br><span class="line">publicclass TestThreadextends Thread&#123;</span><br><span class="line">    public TestThread(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicvoid run() &#123;</span><br><span class="line">        for(int i = 0;i&lt;5;i++)&#123;</span><br><span class="line">            for(long k= 0; k &lt;100000000;k++);</span><br><span class="line">            System.out.println(this.getName()+&quot; :&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicstaticvoid main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new TestThread(&quot;阿三&quot;);</span><br><span class="line">        Thread t2 = new TestThread(&quot;李四&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul>
<li>线程的名字，一个运行中的线程总是有名字的，名字有两个来源，第一是自己，第二是虚拟机</li>
<li>而且主线程的名字总是mian，非主线程的名字不确定</li>
<li>线程都可以设置名字，主线程的也不例外</li>
<li>线程的调用不一定是顺序的他们是随机的</li>
<li>线程一旦启动，他就不可能重新启动</li>
<li>线程的调度是jvm的一部分，在cpu的机器上，实际上一次只能运行一个线程，一次只有一个线程栈执行，jvm线程调度程序决定实际运行的哪个处于可运行的状态</li>
<li>尽管我们无法控制线程调度的程序，但是可以通过别的方式来影响线程调度的方式</li>
</ul>
<h1 id="线程的转换"><a href="#线程的转换" class="headerlink" title="线程的转换"></a>线程的转换</h1><ul>
<li>线程的状态转换是线程控制的基础。线程状态总的可分为五大状态：分别是生、死、可运行、运行、等待&#x2F;阻塞。</li>
<li>可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。</li>
<li>运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式</li>
<li>等待&#x2F;阻塞&#x2F;睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。</li>
<li>死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li>
</ul>
<h2 id="阻止线程的执行"><a href="#阻止线程的执行" class="headerlink" title="阻止线程的执行"></a>阻止线程的执行</h2><ul>
<li>对于线程的阻止，考虑一下三个方面，不考虑IO阻塞的情况：</li>
<li>睡眠</li>
<li>等待</li>
<li>睡眠：Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)静态方法强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。</li>
<li>线程睡眠的原因：线程执行太快，或者需要强制进入下一轮，因为Java规范不保证合理的轮换。</li>
<li>睡眠的实现：调用静态方法。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">          Thread.sleep(123);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(); </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
<li>睡眠的位置：为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠。</li>
<li>线程睡眠是帮助所有线程获得运行机会的最好方法。</li>
<li>线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。</li>
<li>sleep()是静态方法，只能控制当前正在运行的线程。</li>
</ul>
<h2 id="线程的优先级和线程让步yield"><a href="#线程的优先级和线程让步yield" class="headerlink" title="线程的优先级和线程让步yield()"></a>线程的优先级和线程让步yield()</h2><ul>
<li>线程的让步是通过Thread.yield()来实现的。yield()方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。</li>
<li>线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。</li>
<li>注意：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。</li>
<li>当线程池中线程都具有相同的优先级，调度程序的JVM实现自由选择它喜欢的线程。这时候调度程序的操作有两种可能：一是选择一个线程运行，直到它阻塞或者运行完成为止。二是时间分片，为池内的每个线程提供均等的运行机会。<br>-设置线程的优先级：线程默认的优先级是创建它的执行线程的优先级。可以通过setPriority(int newPriority)更改线程的优先级。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread t = new MyThread();</span><br><span class="line">       t.setPriority(8);</span><br><span class="line">       t.start();</span><br></pre></td></tr></table></figure></li>
<li>线程优先级为1<del>10之间的正整数，JVM从不会改变一个线程的优先级。然而，1</del>10之间的值是没有保证的。一些JVM可能不能识别10个不同的值，而将这些优先级进行每两个或多个合并，变成少于10个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。</li>
<li>线程默认优先级是5，Thread类中有三个常量，定义线程优先级范围：</li>
<li>static int MAX_PRIORITY线程可以具有的最高优先级。</li>
<li>static int MIN_PRIORITY线程可以具有的最低优先级。</li>
<li>static int NORM_PRIORITY分配给线程的默认优先级。</li>
</ul>
<h2 id="Thread-yield-方法"><a href="#Thread-yield-方法" class="headerlink" title="Thread.yield()方法"></a>Thread.yield()方法</h2><ul>
<li>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</li>
<li>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</li>
<li>结论：yield()从未导致线程转到等待&#x2F;睡眠&#x2F;阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。</li>
</ul>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul>
<li><p>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread t = new MyThread();</span><br><span class="line">      t.start();</span><br><span class="line">      t.join();</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外，join()方法还有带超时限制的重载版本。例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。</p>
</li>
<li><p>线程的加入join()对线程栈导致的结果是线程栈发生了变化，当然这些变化都是瞬时的。</p>
</li>
</ul>
<h2 id="Object类的wait方法"><a href="#Object类的wait方法" class="headerlink" title="Object类的wait方法"></a>Object类的wait方法</h2><ul>
<li>让当前线程进入等待池</li>
<li>通过Object类的notify方法通知线程池随机让一条回归</li>
<li>而notifyall 是让所有回归</li>
</ul>
<h1 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h1><ul>
<li>synchronized</li>
<li>是一种对象锁，可重入，不可中断，实际上就是一个字节码</li>
<li>基于jvm的监控机制</li>
<li>栈帧线程独享，不用锁，堆是内存共享的需要线程考虑，方法区也是要线程共享<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;</span><br><span class="line"></span><br><span class="line">public class sdhakdh &#123;</span><br><span class="line"></span><br><span class="line">	public static int flag = 0;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		new Thread(&quot;线程1&quot;) &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName().toString() + &quot;@&quot; + flag++);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		</span><br><span class="line">		new Thread(&quot;线程2&quot;) &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName().toString() + &quot;@&quot; + flag++);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>这样的会出现线程抢占的问题，容易让一个线程卡住，然后另外一个框框执行</li>
<li>结果就是无序的</li>
<li>如果加上synchronized则不会出现这个请况<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 作业;</span><br><span class="line"></span><br><span class="line">public class sdhakdh &#123;</span><br><span class="line"></span><br><span class="line">	public static int flag = 0;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		new Thread(&quot;线程1&quot;) &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (&quot;hello&quot;) &#123;</span><br><span class="line">					for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">						System.out.println(Thread.currentThread().getName().toString() + &quot;@&quot; + flag++);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		</span><br><span class="line">		new Thread(&quot;线程2&quot;) &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (&quot;hello&quot;) &#123;</span><br><span class="line">					for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">						System.out.println(Thread.currentThread().getName().toString() + &quot;@&quot; + flag++);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样就不会发生问题了</li>
<li>就会出现顺序的，因为线程回退的时候，下次会继续线程锁锁住的位置进行执行，同时不让同一个锁内的其他线程执行，直到被所著的线程回来</li>
<li>多线程不加锁不安全，可是慢，如果能解决这个问题，就厉害了</li>
<li>如果锁不是同一个名字则无用</li>
<li>下面的例子,是生产者消费者的例子</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;</span><br><span class="line"></span><br><span class="line">public class repo &#123;</span><br><span class="line"></span><br><span class="line">	private int count;</span><br><span class="line">	</span><br><span class="line">	public synchronized void add() &#123;</span><br><span class="line">		while(count &gt;= 100) &#123; // 设置上限</span><br><span class="line">			try &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		notifyAll(); // 把减少线程从等待池放出来</span><br><span class="line">		count++;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public synchronized void substrct() &#123;</span><br><span class="line">		while(count &lt;= 0) &#123; // 设置下限</span><br><span class="line">			try &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		notifyAll(); // 把add线程从等待池放出来</span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;</span><br><span class="line"></span><br><span class="line">public class product &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		repo r =new repo();</span><br><span class="line">		Prou P = new Prou();</span><br><span class="line">		P.re = r;</span><br><span class="line">		Consumer C = new Consumer();</span><br><span class="line">		C.re = r;</span><br><span class="line">		Thread t1 = new Thread(P , &quot;生产者&quot;);</span><br><span class="line">		Thread t2 = new Thread(C , &quot;消费者&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		</span><br><span class="line">		Prou P1 = new Prou();</span><br><span class="line">		P1.re = r;</span><br><span class="line">		Consumer C1 = new Consumer();</span><br><span class="line">		C1.re = r;</span><br><span class="line">		Thread t11 = new Thread(P , &quot;生产者&quot;);</span><br><span class="line">		Thread t21 = new Thread(C , &quot;消费者&quot;);</span><br><span class="line">		t11.start();</span><br><span class="line">		t21.start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Prou implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">	repo re;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		</span><br><span class="line">			for(int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">				re.add();</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	repo re;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		</span><br><span class="line">			for(int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">				re.substrct();</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意，wait的时候是直接放开锁的</li>
</ul>
<h1 id="创建线程的第三种和第四种方式"><a href="#创建线程的第三种和第四种方式" class="headerlink" title="创建线程的第三种和第四种方式"></a>创建线程的第三种和第四种方式</h1><h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line">//实现Callable接口</span><br><span class="line">public class CallableTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //执行Callable 方式，需要FutureTask 实现实现，用于接收运算结果</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyCallable());</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        //接收线程运算后的结果</span><br><span class="line">        try &#123;</span><br><span class="line">            Integer sum = futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//结果：</span><br><span class="line">/*</span><br><span class="line">4950</span><br><span class="line">Process finished with exit code 0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="线程池创建线程"><a href="#线程池创建线程" class="headerlink" title="线程池创建线程"></a>线程池创建线程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">//线程池实现</span><br><span class="line">public class ThreadPoolExecutorTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建线程池</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line">        ThreadPool threadPool = new ThreadPool();</span><br><span class="line">        for(int i =0;i&lt;5;i++)&#123;</span><br><span class="line">            //为线程池分配任务</span><br><span class="line">            executorService.submit(threadPool);</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class ThreadPool implements Runnable &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0 ;i&lt;10;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 打印结果（不唯一）：</span><br><span class="line">/*</span><br><span class="line">pool-1-thread-1:0</span><br><span class="line">pool-1-thread-2:0</span><br><span class="line">pool-1-thread-2:1</span><br><span class="line">pool-1-thread-3:0</span><br><span class="line">pool-1-thread-3:1</span><br><span class="line">pool-1-thread-3:2</span><br><span class="line">pool-1-thread-2:2</span><br><span class="line">pool-1-thread-2:3</span><br><span class="line">pool-1-thread-2:4</span><br><span class="line">pool-1-thread-2:5</span><br><span class="line">pool-1-thread-1:1</span><br><span class="line">pool-1-thread-5:0</span><br><span class="line">pool-1-thread-5:1</span><br><span class="line">pool-1-thread-5:2</span><br><span class="line">pool-1-thread-5:3</span><br><span class="line">pool-1-thread-2:6</span><br><span class="line">pool-1-thread-2:7</span><br><span class="line">pool-1-thread-2:8</span><br><span class="line">pool-1-thread-3:3</span><br><span class="line">pool-1-thread-2:9</span><br><span class="line">pool-1-thread-5:4</span><br><span class="line">pool-1-thread-4:0</span><br><span class="line">pool-1-thread-4:1</span><br><span class="line">pool-1-thread-1:2</span><br><span class="line">pool-1-thread-1:3</span><br><span class="line">pool-1-thread-1:4</span><br><span class="line">pool-1-thread-1:5</span><br><span class="line">pool-1-thread-1:6</span><br><span class="line">pool-1-thread-1:7</span><br><span class="line">pool-1-thread-1:8</span><br><span class="line">pool-1-thread-1:9</span><br><span class="line">pool-1-thread-4:2</span><br><span class="line">pool-1-thread-4:3</span><br><span class="line">pool-1-thread-4:4</span><br><span class="line">pool-1-thread-4:5</span><br><span class="line">pool-1-thread-5:5</span><br><span class="line">pool-1-thread-3:4</span><br><span class="line">pool-1-thread-3:5</span><br><span class="line">pool-1-thread-3:6</span><br><span class="line">pool-1-thread-3:7</span><br><span class="line">pool-1-thread-3:8</span><br><span class="line">pool-1-thread-3:9</span><br><span class="line">pool-1-thread-5:6</span><br><span class="line">pool-1-thread-4:6</span><br><span class="line">pool-1-thread-5:7</span><br><span class="line">pool-1-thread-4:7</span><br><span class="line">pool-1-thread-5:8</span><br><span class="line">pool-1-thread-4:8</span><br><span class="line">pool-1-thread-4:9</span><br><span class="line">pool-1-thread-5:9</span><br><span class="line">Process finished with exit code 0</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2022/10/25/10-25/</url>
    <content><![CDATA[<h1 id="泛型（任意引用类型）"><a href="#泛型（任意引用类型）" class="headerlink" title="泛型（任意引用类型）"></a>泛型（任意引用类型）</h1><ul>
<li>作用:就是可以让其内的变量无类型，直到用的时候才指定类型，解决了强制转换问题</li>
<li>代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	package 作业;</span><br><span class="line"></span><br><span class="line">	public class gdg &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		sfdhkja&lt;String&gt; a = new sfdhkja(); // 尖括号里面的就是泛型的类型</span><br><span class="line">		a.setName(&quot;小明&quot;);</span><br><span class="line">		System.out.println(a.getName());</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		sfdhkja&lt;Integer&gt; b = new sfdhkja();</span><br><span class="line">		b.setName(11111);</span><br><span class="line">		System.out.println(b.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class sfdhkja&lt;E&gt; &#123;</span><br><span class="line">	E name;</span><br><span class="line"></span><br><span class="line">	public sfdhkja() &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public E getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(E name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="boolean-add-E"><a href="#boolean-add-E" class="headerlink" title="boolean add(E)"></a>boolean add(E)</h3><p>把任意对象类型加进list中</p>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>返回集合的迭代器，用于遍历集合</p>
<h3 id="default修饰的"><a href="#default修饰的" class="headerlink" title="default修饰的"></a>default修饰的</h3><p>代表接口中有方法体</p>
<h3 id="int-size"><a href="#int-size" class="headerlink" title="int size"></a>int size</h3><h3 id="并行流和串型流"><a href="#并行流和串型流" class="headerlink" title="并行流和串型流"></a>并行流和串型流</h3><h3 id="Object-toArray"><a href="#Object-toArray" class="headerlink" title="Object toArray()"></a>Object toArray()</h3><p>可以指定泛型的</p>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 重新开始;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class jeiko &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		Collection&lt;String&gt; c1 =new ArrayList&lt;&gt;();</span><br><span class="line">		c1.add(&quot;中国&quot;);</span><br><span class="line">		c1.add(&quot;韩国哦&quot;);</span><br><span class="line">		c1.add(&quot;hsakdj&quot;);</span><br><span class="line">		System.out.println(c1.size());</span><br><span class="line">		Iterator&lt;String&gt; ra = c1.iterator();</span><br><span class="line">		while(ra.hasNext()) &#123;</span><br><span class="line">			String item = ra.next();</span><br><span class="line">			System.out.println(item);</span><br><span class="line">			ra.remove(); // 删除元素</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-------------------------------&quot;);</span><br><span class="line">		for (String string : c1) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;------------------------------------&quot;);</span><br><span class="line">		c1.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>只有第一种才可以进行便循环边删除</li>
<li>其他都不可以</li>
<li>但是第三种最帅，代码量也最少</li>
</ul>
<h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><ul>
<li>Colllection继承了Iterable接口</li>
<li>list线性，有序集合</li>
<li>set无序集合</li>
<li>旗下是</li>
<li>ArrayLinst</li>
<li>LinkedList</li>
<li>Vector</li>
<li>下面是set的</li>
<li>HashSet</li>
<li>TreeSet</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul>
<li>线性集合 ，有下标</li>
<li>add(index , E)</li>
<li>set(index ,E)</li>
<li>get(index)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 重新开始;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Vector;</span><br><span class="line"></span><br><span class="line">public class Main1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; list = new Vector&lt;String&gt;();</span><br><span class="line">		list.add(&quot;1&quot;);  // 先往list里添加元素</span><br><span class="line">		list.add(&quot;12&quot;); // 同上</span><br><span class="line">		System.out.println(list);  // 直接打印是全部打印出来</span><br><span class="line">		list.add(0,&quot;121&quot;); // 在下表为0的地方添加121</span><br><span class="line">		list.set(2, &quot;dhkjsdhj&quot;); // 把下表为2的地方设置为dhkjsdhj</span><br><span class="line">		System.out.println(list.size()); // 获取list的size就是大小</span><br><span class="line">		</span><br><span class="line">		list.forEach(System.out::println); // 超级帅气的循环语句，本身是lambal表达式</span><br><span class="line">		for(int i =0; i &lt; list.size() ; i++) &#123;</span><br><span class="line">			String item = list.get(i);</span><br><span class="line">			System.out.println(item);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li>底层封装的数组</li>
<li>扩容的时候每次扩容一半</li>
<li>海量添加的时候是很慢的，就是修改长度很慢</li>
<li>查询快，因为有下标</li>
</ul>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ul>
<li>可控增量，且线程安全</li>
<li>底层是数组，且有线程锁，</li>
<li>10，20，40 ，每次扩容一倍，但是是可以控制增量的</li>
<li>比ArrayList慢</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul>
<li>底层封装的是节点，双向链表，每一个节点都有前一个节点和后一个节点的引用</li>
<li>单向链：修改快</li>
<li>双向链：就是双向的，前后都有元素</li>
<li>特点：修改快，但是查询慢</li>
<li>可以用作与自己定义栈<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MyStack&lt;E&gt; &#123;</span><br><span class="line">	LinkedList&lt;E&gt; data;</span><br><span class="line">	public E pop()  &#123;</span><br><span class="line">	return	data.pollLast();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>无序集合</li>
<li>会自动去重，就是有重复的就会	不添加新的元素<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">set.add(11);</span><br><span class="line">set.add(1111);</span><br><span class="line">set.add(898);</span><br><span class="line">set.add(11);</span><br><span class="line">set.forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul>
<li>因为这里的去重机制是根据hashcode和equals来的，默认的时候，可以像正常的列表一样，但是我们可以进行覆盖hashcode和equals</li>
<li>不覆盖<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 重新开始;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Sst &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">		set.add(11);</span><br><span class="line">		set.add(1111);</span><br><span class="line">		set.add(898);</span><br><span class="line">		set.add(11);</span><br><span class="line">		set.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">		Set&lt;stu&gt; s1 =new HashSet&lt;stu&gt;();</span><br><span class="line">		s1.add(new stu());</span><br><span class="line">		s1.add(new stu());</span><br><span class="line">		s1.add(new stu());</span><br><span class="line">		System.out.println(s1.size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class stu&#123;</span><br><span class="line">	private int num;</span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	public stu() &#123;</span><br><span class="line">		super();</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	public int getNum() &#123;</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNum(int num) &#123;</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;stu [num=&quot; + num + &quot;, name=&quot; + name + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>覆盖之后</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 重新开始;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Sst &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">		set.add(11);</span><br><span class="line">		set.add(1111);</span><br><span class="line">		set.add(898);</span><br><span class="line">		set.add(11);</span><br><span class="line">		set.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">		Set&lt;stu&gt; s1 =new HashSet&lt;stu&gt;();</span><br><span class="line">		s1.add(new stu());</span><br><span class="line">		s1.add(new stu());</span><br><span class="line">		s1.add(new stu());</span><br><span class="line">		System.out.println(s1.size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class stu&#123;</span><br><span class="line">	private int num;</span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	public stu() &#123;</span><br><span class="line">		super();</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	public int getNum() &#123;</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNum(int num) &#123;</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;stu [num=&quot; + num + &quot;, name=&quot; + name + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		final int prime = 31;</span><br><span class="line">		int result = 1;</span><br><span class="line">		result = prime * result + ((name == null) ? 0 : name.hashCode());</span><br><span class="line">		result = prime * result + num;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		if (this == obj)</span><br><span class="line">			return true;</span><br><span class="line">		if (obj == null)</span><br><span class="line">			return false;</span><br><span class="line">		if (getClass() != obj.getClass())</span><br><span class="line">			return false;</span><br><span class="line">		stu other = (stu) obj;</span><br><span class="line">		if (name == null) &#123;</span><br><span class="line">			if (other.name != null)</span><br><span class="line">				return false;</span><br><span class="line">		&#125; else if (!name.equals(other.name))</span><br><span class="line">			return false;</span><br><span class="line">		if (num != other.num)</span><br><span class="line">			return false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>也可以在生成覆盖的时候少选几个变量这样这些变量就会变成唯一的筛选变量 ，相当于放宽变量范围</li>
<li>原理是封装了hashmap，利用key和value</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>SetTree</title>
    <url>/2022/10/26/10-26/</url>
    <content><![CDATA[<h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><ul>
<li><p>其是基于compareable的，</p>
</li>
<li><p>进行add的时候放的如果是引用类型，则要实现compareable接口，因为他就是用这个接口来实现的</p>
</li>
<li><p>对于基本类型，则不用</p>
</li>
<li><p>如果这样就会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 重新开始;</span><br><span class="line"></span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class copyfilethread &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		Set&lt;String&gt; set = new TreeSet&lt;String&gt;();</span><br><span class="line">		set.add(&quot;2020-10-19&quot;);</span><br><span class="line">		set.add(&quot;1010-10-20&quot;);</span><br><span class="line">		System.out.println(set);</span><br><span class="line">		Set&lt;stu&gt; SET = new TreeSet&lt;stu&gt;();</span><br><span class="line">		SET.add(new stu(&quot;小明&quot; , 1));</span><br><span class="line">		SET.add(new stu(&quot;snisnh&quot; , 2));</span><br><span class="line">		SET.add(new stu(&quot;狗蛋&quot;  , 1));</span><br><span class="line">		SET.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>stu类</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class stu &#123;</span><br><span class="line">	private int num;</span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	public stu( String name , int num) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.num = num;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public stu() &#123;</span><br><span class="line">		super();</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	public int getNum() &#123;</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNum(int num) &#123;</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;stu [num=&quot; + num + &quot;, name=&quot; + name + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		final int prime = 31;</span><br><span class="line">		int result = 1;</span><br><span class="line">		result = prime * result + ((name == null) ? 0 : name.hashCode());</span><br><span class="line">		result = prime * result + num;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		if (this == obj)</span><br><span class="line">			return true;</span><br><span class="line">		if (obj == null)</span><br><span class="line">			return false;</span><br><span class="line">		if (getClass() != obj.getClass())</span><br><span class="line">			return false;</span><br><span class="line">		stu other = (stu) obj;</span><br><span class="line">		if (name == null) &#123;</span><br><span class="line">			if (other.name != null)</span><br><span class="line">				return false;</span><br><span class="line">		&#125; else if (!name.equals(other.name))</span><br><span class="line">			return false;</span><br><span class="line">		if (num != other.num)</span><br><span class="line">			return false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 大于0是正数，小于0是负数 ，等于0是相等 ，</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样会报错，是类型转换的错误。</li>
<li>因为它实现的是compareable接口，对比引用类型的时候用的是这个接口里的方法</li>
<li>所以在stu类实现这个接口就可以不报错了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class stu implements Comparable&lt;stu&gt;&#123;</span><br><span class="line">	private int num;</span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	public stu( String name , int num) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.num = num;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public stu() &#123;</span><br><span class="line">		super();</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	public int getNum() &#123;</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNum(int num) &#123;</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;stu [num=&quot; + num + &quot;, name=&quot; + name + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		final int prime = 31;</span><br><span class="line">		int result = 1;</span><br><span class="line">		result = prime * result + ((name == null) ? 0 : name.hashCode());</span><br><span class="line">		result = prime * result + num;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		if (this == obj)</span><br><span class="line">			return true;</span><br><span class="line">		if (obj == null)</span><br><span class="line">			return false;</span><br><span class="line">		if (getClass() != obj.getClass())</span><br><span class="line">			return false;</span><br><span class="line">		stu other = (stu) obj;</span><br><span class="line">		if (name == null) &#123;</span><br><span class="line">			if (other.name != null)</span><br><span class="line">				return false;</span><br><span class="line">		&#125; else if (!name.equals(other.name))</span><br><span class="line">			return false;</span><br><span class="line">		if (num != other.num)</span><br><span class="line">			return false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 大于0是正数，小于0是负数 ，等于0是相等 ，</span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(stu o) &#123;</span><br><span class="line">	return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是这样他只能往set里添加一个值</li>
<li>因为这个compare默认的时候就是这样</li>
<li>如果要再进行精度筛选则要，在被覆盖的compareto方法中自己定义，可以改成<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public int compareTo(stu o) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		if(this.num == o.num) &#123;</span><br><span class="line">			return this.name.length() - o.name.length();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return this.num - o.num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>这样就会让如果学号相同，就会按照姓名的长度排序，小的在上面</li>
<li>总之就是可以在这个compareto这里设置规则</li>
<li>可控性强</li>
<li>这里只有数组的是length是属性，其他都是方法</li>
<li>集合的叫size</li>
<li>这个是用于实体类，数据类实现接口用 ， 表达的是自然的顺序，又叫自然排序</li>
</ul>
<h1 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h1><ul>
<li>比较器是对于list来说的</li>
<li>comparetor ：比较器，比上一个更自由 ，可以控制排序的方式，升序或者降序<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;stu&gt; list = new ArrayList&lt;stu&gt;();</span><br><span class="line">System.out.println(&quot;----------------------&quot;);</span><br><span class="line">list.add(new stu(&quot;下&quot; , 1 , 89.1));</span><br><span class="line">list.add(new stu(&quot;下&quot; , 2 , 88.1));</span><br><span class="line">list.add(new stu(&quot;下&quot; , 21 , 87.1));</span><br><span class="line">list.add(new stu(&quot;下&quot; , 22 , 86.1));</span><br><span class="line">list.add(new stu(&quot;下&quot; , 21 , 85.1));</span><br><span class="line">list.add(new stu(&quot;下&quot; , 221 , 84.1));</span><br><span class="line">list.add(new stu(&quot;下&quot; , 21 , 83.1));</span><br><span class="line">list.add(new stu(&quot;下&quot; , 21 , 82.1));</span><br><span class="line"></span><br><span class="line">Collections.sort(list , (a,b) -&gt; -((int)(b.getScore() - a.getScore() * 100 ))); // 这个里面的代表 ， 我们的比较规则， 前面代表要排序的集合，list不去重 ， a,b代表两个元素list中的，后面的就是比较的规则了，一般是升序排序，但是我们可以通过添加-的方法，让他进行降序，他底层也是tree</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li>通过lambal表达式进行比较排序</li>
<li>但是其实这个sort方法也是Arrays.sort，它是将所有元素转入一个数组，对数组进行排序，然后，将排好序 的序列复制回列表 ，</li>
<li>sort()是根据需要排序的数组的长度进行区分的:</li>
<li>首先先判断需要排序的数据量是否大于60。</li>
<li>小于60：使用插入排序，插入排序是稳定的</li>
<li>大于60的数据量会根据数据类型选择排序方式：</li>
<li>基本类型：使用快速排序。「因为基本类型不需要考虑稳定性」</li>
<li>Object类型：使用归并排序「因为归并排序具有稳定性」</li>
<li>注意：不管是快速排序还是归并排序。在二分的时候小于60的数据量依旧会使用插入排序</li>
<li>Collections.reverseOrder()也可以进行降序排序 , 只不过是要基本类型</li>
</ul>
<h1 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射Map</h1><ul>
<li>是一种接口</li>
<li>是一种&lt;k , V&gt; 结构 ，就是一个key对应一个value，其key不会重复，而value可以重复</li>
<li>一个&lt;Ｋ，V&gt;叫一个ｅｎｔｒｙ</li>
<li>万能&lt;Ｋ，V&gt;他可以代表一个对象</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>ｃｌｅａｒ清除所有映射</li>
<li>ｂｏｏｌｅａｎ　ｃｏｎｔａｉｎｓＫｅｙ（Ｏｂｊｅｃｔ　ｋｅｙ）：判断一个ｋｅｙ是不是存在</li>
<li>ｅｎｔｒｙＳｅｔ（）获取ｅｎｔｒｙ集合，就是条目集合<br>，返回类型是一个Ｓｅｔ</li>
<li>ｇｅｔ（ｋｅｙ）根据ｋｅｙ获取ｖａｌｕｅ</li>
<li>ｋｅｙＳｅｔ（）返回ｋｅｙ的集合</li>
<li>ｐｕｔ（K，ｖ），往，ｍａｐ加入一条数据，但是存在相同的ｋｅｙ就覆盖</li>
<li>ｒｅｍｏｖｅ（ｋ）删除ｋｅｙ</li>
<li>ｓｉｚｅ（）条目个数</li>
<li>Ｃｏｌｌｅｃｔｉｏｎ＜Ｖ＞　ｖａｌｕｅｓ（）获取值组成的集合<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 重新开始;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Main2 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Map&lt;String , String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">		map.put(&quot;akjsdhs&quot;, &quot;sdjal&quot;);</span><br><span class="line">		map.put(&quot;dshd&quot; , &quot;sdjjdjd&quot;);</span><br><span class="line">		System.out.println(map.get(&quot;dshd&quot;));</span><br><span class="line">		System.out.println(map.containsKey(&quot;dshd&quot;));</span><br><span class="line">		System.out.println(map.remove(&quot;dshd&quot;));</span><br><span class="line">		System.out.println(map.size());</span><br><span class="line">		System.out.println(map.entrySet());</span><br><span class="line">		System.out.println(map.containsKey(&quot;dshd&quot;));</span><br><span class="line">		map.clear();</span><br><span class="line">		System.out.println(map.size());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>Map</title>
    <url>/2022/10/27/10-27/</url>
    <content><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ul>
<li><p>Map和集合是无关系的</p>
</li>
<li><p>Map是个接口</p>
</li>
<li><p>旗下有hashMap和TreeMap</p>
</li>
<li><p>简单代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;String , String&gt; map1 = new HashMap&lt;&gt;();</span><br><span class="line">	map1.put(&quot;1&quot;, &quot;事假&quot;);</span><br><span class="line">	map1.put(&quot;2&quot;, &quot;病假&quot;);</span><br><span class="line">	map1.put(&quot;3&quot;, &quot;产假&quot;);</span><br><span class="line">	map1.put(&quot;2&quot;, &quot;施加&quot;);</span><br><span class="line">	Set&lt;String&gt; ks = map1.keySet();</span><br><span class="line">	Iterator&lt;String&gt; it = ks.iterator();</span><br><span class="line">	while(it.hasNext()) &#123;</span><br><span class="line">		String item = it.next();</span><br><span class="line">		System.out.println(&quot;key&quot; + item + &quot;@value:&quot; + map1.get(item));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>entrySet</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; km = map1.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; il = km.iterator();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(il.hasNext()) &#123;</span><br><span class="line">Entry&lt;String , String&gt; entry = il.next();</span><br><span class="line">System.out.println(entry.getKey() + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Entry&lt;String, String&gt; entry : km) &#123;</span><br><span class="line">	System.out.println(entry.getKey() + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">km.forEach(new Consumer() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void accept(Object t) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	System.out.println(t);</span><br><span class="line">&#125;&#125;); // Consumer里面有个抽象方法 ，accept，我们要做的事情放进这个accept里，就代表对其每个元素进行accept里的操作 ，就是lambda的表达式</span><br><span class="line">		</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>上述是两种遍历方式，迭代器可边遍历便删除，是我们最古老的，可是也是唯一有这个功能的 ，iterator</li>
<li>其他的都要遍历完了才能再删除</li>
<li>而且entrySet比keySet是要更快点的（单纯遍历）</li>
<li>迭代器的算法是要比后来的算法速度快的，遍历的时候</li>
</ul>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><ul>
<li>lambda表达式是很便捷的一种方法</li>
<li>要求：定义规则，定义几个变量</li>
<li>首先，我们要定义一个接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">interface Yunsuan&#123;</span><br><span class="line">	public int yunsuan(int i , int j);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>然后在这个接口上增加@FunctionalInterface ，注意这个标志是让这个接口只有一个抽象方法，多个抽象方法会报错</li>
<li>这一步是定义我们的，几个元素</li>
<li>接下来我们定义一个函数 ，让这个接口当作参数 ，并且给这个接口传入两个参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static int getresult(int a , int b, Yunsuan yunsuan) &#123;</span><br><span class="line">	return	yunsuan.yunsuan(a, b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>这样 ，我们就算是把这个规则实体化了，接下来我们只要调用这个规则的实例化，就可以对这两个数进行任意操作了</li>
<li>比如<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">System.out.println(getresult(3,2, (i,j)-&gt;i+j)); // 前面两个是实参 ，后面的是规则就这样写就行 ，格式固定，但是语法不固定</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>上面的foreach里嵌套的就算lambda的表达式</li>
</ul>
<h1 id="Map特殊事项"><a href="#Map特殊事项" class="headerlink" title="Map特殊事项"></a>Map特殊事项</h1><ul>
<li><p>如果在map里把key放入引用类型，则对比key的操作会变成对比hashcode和equals，可控性更强</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">package 重新开始;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class TEstmain1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		Map&lt;stu , Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		map.put(new stu(&quot;小明&quot;  , 1), 1);</span><br><span class="line">		map.put(null , null);</span><br><span class="line">		map.put(new stu(&quot;狗蛋&quot; , 1) , 2);</span><br><span class="line">		System.out.println(map.size());</span><br><span class="line">		map.forEach((k , v) -&gt; &#123;System.out.println(k + &quot;@&quot; +v);&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>stu类，通过自动生成hashcode和equals，（我这里只生成了num的）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class stu implements Comparable&lt;stu&gt;&#123;</span><br><span class="line">	private int num;</span><br><span class="line">	private String name;</span><br><span class="line">	private double score;</span><br><span class="line">	public stu( String name , int num) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.num = num;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	public stu( String name , int num , double m) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.num = num;</span><br><span class="line">		this.score = m;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public stu() &#123;</span><br><span class="line">		super();</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	public int getNum() &#123;</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNum(int num) &#123;</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;stu [num=&quot; + num + &quot;, name=&quot; + name + &quot;, score=&quot; + score + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		final int prime = 31;</span><br><span class="line">		int result = 1;</span><br><span class="line">		result = prime * result + num;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		if (this == obj)</span><br><span class="line">			return true;</span><br><span class="line">		if (obj == null)</span><br><span class="line">			return false;</span><br><span class="line">		if (getClass() != obj.getClass())</span><br><span class="line">			return false;</span><br><span class="line">		stu other = (stu) obj;</span><br><span class="line">		if (num != other.num)</span><br><span class="line">			return false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 大于0是正数，小于0是负数 ，等于0是相等 ，</span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(stu o) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		if(this.num == o.num) &#123;</span><br><span class="line">			return this.name.length() - o.name.length();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return o.num - this.num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double getScore() &#123;</span><br><span class="line">		return score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setScore(double score) &#123;</span><br><span class="line">		this.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="lambda加for循环-加上TreeMap"><a href="#lambda加for循环-加上TreeMap" class="headerlink" title="lambda加for循环 加上TreeMap"></a>lambda加for循环 加上TreeMap</h1><ul>
<li><p>通过treeMap实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">package 重新开始;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class TEstmain1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		TreeMap&lt;stu , Object&gt; map11 = new TreeMap();</span><br><span class="line">		map11.put(new stu(&quot;小明&quot;,  1), 1);</span><br><span class="line">		map11.put(new stu(&quot;狗蛋&quot; ,  2) ,2);</span><br><span class="line">		map11.put(new stu(&quot;linux&quot; , 3), 3);</span><br><span class="line">		map11.put(new stu(&quot;狗蛋&quot; ,  2) ,99);</span><br><span class="line">		map11.forEach(TEstmain1::abc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void abc(stu s , Object value) &#123;</span><br><span class="line">		System.out.println(s + &quot;@&quot; +value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>上述的是针对foreach有两个参数的情况，可以定义一个函数，让他去传递参数，和lambda一样</p>
</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>细节</title>
    <url>/2022/10/28/10-28/</url>
    <content><![CDATA[<h1 id="关于Map的遍历"><a href="#关于Map的遍历" class="headerlink" title="关于Map的遍历"></a>关于Map的遍历</h1><ul>
<li>我们可以用Set来遍历</li>
<li>代码如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">map2.put(&quot;Tom&quot;, &quot;Corejava&quot;);</span><br><span class="line">map2.put(&quot;Jerry&quot;, &quot;Jsp&quot;);</span><br><span class="line">map2.put(&quot;KJSHHKJ&quot; , &quot;Oracle&quot;);</span><br><span class="line">Set m = map2.entrySet();</span><br><span class="line">m.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li>我们还可以用，把map转换成流再进行</li>
<li>代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">map2.entrySet().stream().filter((item) -&gt; &quot;Oracle&quot;.equals(item.getValue())).forEach((item) -&gt; System.out.println(item.getKey()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>特别帅气，</li>
<li>而且foreach的本质就是流</li>
<li>先通过entryset转换成集合</li>
<li>然后集合有Stream方法，可以转化成流</li>
<li>然后对于流我们加上filter（过滤器）</li>
<li>筛选我们想要的结构，这个过滤器里面只能放返回值是布尔的</li>
<li>然后筛选完了，我们可以对他进行lambda的表达输出语句</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2022/10/31/10-31/</url>
    <content><![CDATA[<h1 id="linux的目录形式"><a href="#linux的目录形式" class="headerlink" title="linux的目录形式"></a>linux的目录形式</h1><ul>
<li>层级式</li>
<li>当用了Xshell登录了管理员之后会显示</li>
<li>root@bigdata1 liuzihan</li>
<li>前面表示root用户</li>
<li>@后面的是机器名字</li>
<li>在后面的是普通用户的名字</li>
<li>~表示当前用户的家目录</li>
<li>有命令帮助 应用 xx–help ， 这个xx代表是命令</li>
<li>例如： 用法：ls [选项]… [文件]…</li>
<li>上面代表ls后面可以加多个辅助命令 ， 还可以加多个文件</li>
<li>中断命令 ： ctrl + c 或者 ctrl + z</li>
<li>用键盘自动补全 ，</li>
<li>按一次 ： 匹配当前据有唯一标识的补全</li>
<li>按两次 ： 把所有匹配的项目都展示出来</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>pwd : 查看当前所在的目录</li>
<li>ls ： 查看所在的目录下有文件或者文件夹</li>
<li>mkdir ： 创建文件夹 ， 后面加文件夹的名字</li>
<li>cd ： 切换路径 ， 就算现在所在的目录 ， 只能切换文件夹</li>
<li>ls -l ： 表示看这个文件夹的额外的详细信息 ， 权限 ，用户 ， 用户组 ， 大小 ， 创建时间。 </li>
<li>ls -l -a ：显示以.开头的文件或者文件夹 ， 就是隐藏文件</li>
<li>ls -l -h ：查看文件的大小 ， 文件夹是不可以的</li>
<li>上面的 ls -l &#x3D;&#x3D; ll 但是在一些操作系统里是不行的在centos里是可以的但是ubanto上是不行的</li>
<li>其实现是通过别名</li>
<li>ll -r -t ： 可以看见按照时间顺序降序的排序文件 ，就算最下面的就是最近更改的</li>
<li>上述还可以改成 ll -rt &#x3D;&#x3D;ll -r -t</li>
</ul>
<h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹##"></a>创建文件夹##</h2><h3 id="并级创建"><a href="#并级创建" class="headerlink" title="并级创建"></a>并级创建</h3><ul>
<li>mkdir 1 2 3</li>
</ul>
<h3 id="串级创建"><a href="#串级创建" class="headerlink" title="串级创建"></a>串级创建</h3><ul>
<li>mkdir 1&#x2F;2&#x2F;3</li>
<li>但是这样要求必须有上级目录</li>
<li>不过可以用</li>
<li>mkdir -p 1&#x2F;2&#x2F;3</li>
<li>就可以了</li>
</ul>
<h2 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h2><ul>
<li>cd</li>
<li>不过有绝对路径和相对路径的区别</li>
<li>绝对路径 ： 从根目录</li>
<li>相对路径 ： 从当前目录</li>
<li>cd的可以是绝对，也可以是相对</li>
<li>cd..&#x2F; : 返回上级目录</li>
<li>cd.&#x2F; : 表示当前目录</li>
<li>可以这样用 ： cd .&#x2F;1</li>
</ul>
<h3 id="快速回到家目录"><a href="#快速回到家目录" class="headerlink" title="快速回到家目录"></a>快速回到家目录</h3><ul>
<li>1 , cd &#x2F;xx</li>
<li>2 , cd + 回车 &#x3D;&#x3D;&gt;推荐</li>
<li>3 , cd + ~</li>
<li>cd - 回到上次操作的目录</li>
</ul>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><ul>
<li>touch 1.log</li>
<li>vi&#x2F;vim 1.log</li>
<li>echo “bigdata” &gt; 3.log</li>
<li><blockquote>
<p>: 表示创建或者覆盖一个文件</p>
</blockquote>
</li>
<li>cat ： 查看文件内容</li>
<li>比如 ： cat 3.log</li>
<li><blockquote>
<blockquote>
<p>: 追加 ，上述一个 &gt; 是覆盖 ，这个是追加</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h2><ul>
<li>命令行模式</li>
<li>编辑模式</li>
<li>尾行模式</li>
<li>vi&#x2F;vim xxx</li>
<li>然后用insert</li>
<li>编辑完了</li>
<li>用esc ， 之后有几种选项</li>
<li>:q ：代表退出并且不保存</li>
<li>:w ：代表写入，但是不退出</li>
<li>:wq ：代表保存且退出</li>
<li>：！ ：强制</li>
<li>还可以以应用nano</li>
<li>就nano Xxx</li>
<li>然后下面就会有提示</li>
<li>如果没有这个文件，就会创建文件</li>
</ul>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><ul>
<li>cat ： 查看文件所有内容</li>
<li>more ： 查看文件内容，按空格是往下翻，按q退出</li>
<li>less ： 查看大文件，也是一页一页的 ， q是退出，按小键盘的上下键，是翻页</li>
<li>一般小文件，用 cat 大文件more或者less</li>
<li>实时查看文件产生的内容</li>
<li>tail ： </li>
<li>-f</li>
<li>-F &#x3D;&#x3D; -f + retry</li>
<li>意义：-F ， 如果我们查看一个文件的时候，文件被删了，然后又重新生成了给一样文件名的文件 ， 则f就不会动态显示了</li>
<li>但是F会重显示新的那个文件</li>
<li>用法 tail -f xxx</li>
<li>用法 tail -F xxx</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>查找特定日志里的xx字段</li>
<li>通过 vi&#x2F;vim 进入 然后进行搜索</li>
<li>在尾行模式 ，输入要查找的字符 例如 &#x2F;error</li>
<li>然后键盘 n 查找下一个词 N 查找上一个词</li>
<li>通过cat </li>
<li>cat xxxx文件 | grep error 通过后面的grep 过滤文件</li>
<li>查看进程也可以用这种方式筛选</li>
<li>可以和其他命令联用 比如 把所有error的信息收集起来</li>
<li>cat xxx文件 | grep error &gt; xxx文件</li>
<li>grep的常用的参数</li>
<li>grep -A xx行： 查看某一个词的后xx行</li>
<li>grep -B xx行： 查看某一个词的前xx行</li>
<li>grep -C xx行： 查看某一个词的前后xx行</li>
<li>与上面的了连用为</li>
<li>cat xxx文件 | grep -A xx行 error &gt; xxx文件</li>
<li>nano方式</li>
<li>管道符| ：代表让上一个语句的输出代表 代表下一个语句的输入</li>
</ul>
<h2 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h2><ul>
<li>上传 ： win 到 linux</li>
<li>下载 ： linux 到 win</li>
</ul>
<h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ul>
<li>工具 ： Xshell 通过Xshell的Xftp进行下载和上传</li>
<li>linux命令 ： yum install lzxx ，通过他进行下载上传</li>
</ul>
<h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><ul>
<li>clear : 清屏</li>
<li>ctrl + l ： 清屏</li>
</ul>
<h2 id="查看操作命令历史"><a href="#查看操作命令历史" class="headerlink" title="查看操作命令历史"></a>查看操作命令历史</h2><ul>
<li>history </li>
<li>或者键盘上的上下箭头号</li>
<li>按键盘的！ + 命令行数</li>
</ul>
<h2 id="移动与复制"><a href="#移动与复制" class="headerlink" title="移动与复制"></a>移动与复制</h2><ul>
<li>mv[选项]..源文件..目录</li>
<li>例如： mv dir1 bigdata</li>
<li>cp[选项]..源文件..目录</li>
<li>例如： cp -r dir2 bigdata</li>
<li>但是 cp还可以复制的时候改文件名字</li>
<li>例如 cp 源文件 目标文件</li>
<li>就会把源文件中的内容给目标文件，命名就是这里的目标文件</li>
<li>也可以和上一个复制到文件夹联用</li>
<li>例如 ： cp xx xxx目录&#x2F;xx文件</li>
<li>mv始终是一份</li>
<li>而cp则是两份</li>
<li>所以mv比cp快</li>
</ul>
<h2 id="删除文件或者文件夹"><a href="#删除文件或者文件夹" class="headerlink" title="删除文件或者文件夹"></a>删除文件或者文件夹</h2><ul>
<li>rm[选项]..文件..</li>
<li>有删除提示 ： rm reeor.log</li>
<li>删除文件夹 ： rm -r xxxx文件夹</li>
<li>无删除提示 ： rm -f</li>
<li>用法和上面一样</li>
<li>且 rm-r -f xxx &#x3D; rm-rf xxx</li>
<li>比如 我们可以 rm -rf&#x2F; &#x3D;&gt; 把整个全删除了</li>
</ul>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><ul>
<li>alias </li>
<li>创建别名：</li>
<li>alias aa &#x3D;”cd&#x2F;tmp” &#x3D;&gt;仅仅当前会话生效 ， 让aa代表cd&#x2F;tmp</li>
<li>但是在其他会话里就不会生效，因为这个没有在环境变量里设置</li>
</ul>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul>
<li>就像java的jdk环境一样 我们也有环境变量</li>
<li>全局环境变量 &#x2F;etc&#x2F;profile</li>
<li>个人变量 ： 只能当前用户使用 其他用户不能使用</li>
<li>~&#x2F;.bashrcc</li>
<li>~&#x2F;.bash_profile</li>
<li>生效环境变量</li>
<li>source &#x2F;etc&#x2F;profile</li>
<li>重新打开一个会话</li>
<li>然后这个别名就会好用了</li>
<li>但是这个不能跨用户访问，比如root的不能在普通用户这么用，相反也是</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令（运维）</title>
    <url>/2022/11/01/11-1/</url>
    <content><![CDATA[<h1 id="用户常用命令"><a href="#用户常用命令" class="headerlink" title="用户常用命令"></a>用户常用命令</h1><ul>
<li>ll &#x2F;usr&#x2F;sbin&#x2F;user* 查看用户命令</li>
<li>ll &#x2F;usr&#x2F;sbin&#x2F;group* 查看组命令</li>
<li>查看用户信息 &#x2F;etc&#x2F;passwd</li>
<li>查看组信息 &#x2F;etc&#x2F;group</li>
<li>查看用户 id xxx名称</li>
<li>userdel xxx ： 代表删除xx用户</li>
<li>useradd xxx ： 代表添加xx用户</li>
<li>usermod xxx ： 代表对一个用户进行操作</li>
</ul>
<h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><ul>
<li>su xxx</li>
<li>su -xxx </li>
<li>切换用户 ，如果用下面的那种，会获得该用户的环境变量并且执行</li>
<li>用上面的那种目录不会跑到所切换的用户的home</li>
<li>而下面的会跑到切换用户的home</li>
<li>用exit退回</li>
<li>如果删除了一个已经存在的user ， 再次添加相同名称的用户的时候，会有警告，说明此用户的目录已经存在</li>
<li>在skel文件夹下有隐藏文件</li>
<li>如果把这个里的东西删掉，就会出现环境变量丢失的情况</li>
<li>我们可以从别的地方的给他cp过来</li>
<li>就会恢复了</li>
</ul>
<h1 id="组常见命令"><a href="#组常见命令" class="headerlink" title="组常见命令"></a>组常见命令</h1><ul>
<li>groupadd xxx</li>
<li>把一个用户添加到一个组上</li>
<li>usermod -a -G xxx组 xxx用户</li>
<li>usermod -g ： 更改用户主组 ，但是这样会让追加组丢失</li>
</ul>
<h1 id="设置用户密码"><a href="#设置用户密码" class="headerlink" title="设置用户密码"></a>设置用户密码</h1><ul>
<li>passwd</li>
<li>默认修改当前用户的密码</li>
</ul>
<h2 id="修改其他用户的密码"><a href="#修改其他用户的密码" class="headerlink" title="修改其他用户的密码"></a>修改其他用户的密码</h2><ul>
<li>只有root有权限修改其他的密码</li>
<li>passwd xxx名字</li>
</ul>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><ul>
<li>是一个普通用户临时具有最大权限</li>
<li>修改 etc&#x2F;sudoers</li>
<li>xxx用户 ALL&#x3D;(root) NOPASSWD:ALL</li>
<li>然后就可以用 sudo xxx 命令这就代表这条指令具有了最高的权限</li>
<li>su 和 sudo 联用</li>
<li>sudo su xx人员</li>
<li>代表通过root权限切换</li>
</ul>
<h3 id="etc-x2F-paswd"><a href="#etc-x2F-paswd" class="headerlink" title="etc&#x2F;paswd"></a>etc&#x2F;paswd</h3><ul>
<li>这个文件是密码文件</li>
<li>在这个文件里 有解释器 如果后面变成nologin代表不让登录</li>
<li>如果最后变成false 则你无论如何都登陆不成功 </li>
<li>CDH平台 可能会用到</li>
<li>把上面两中改成 bin&#x2F;bash 就可以成功了</li>
</ul>
<h1 id="权限相关命令"><a href="#权限相关命令" class="headerlink" title="权限相关命令"></a>权限相关命令</h1><ul>
<li>第一个字母 </li>
<li>d :文件夹</li>
<li>-(横杠) ： 文件</li>
<li>l ： 链接</li>
<li>后面9个字母 ，每三个一组</li>
<li>r表示read  代表数字 4</li>
<li>w表示write 代表数字 2</li>
<li>x表示执行权限 代表数字 1</li>
<li>-表示无权限 代表数字 0</li>
<li>例子 ：-rw-r- -r- -. 1 root root 2047 10月 31 09:48 initial-setup-ks.cfg</li>
<li>第一组 ： rw- 4+2+0&#x3D;6 代表文件或者文件夹的所属用户拥有的权限</li>
<li>第二组 ： r- - 4+0+0&#x3D;4 代表文件或者文件夹的组的成员的权限</li>
<li>第三组 ： r- - 4+0+0&#x3D;4 代表文件或者文件夹的其他组的权限</li>
<li>字母顺序只能按照rwxr这个顺序</li>
</ul>
<h2 id="权限修改命令"><a href="#权限修改命令" class="headerlink" title="权限修改命令"></a>权限修改命令</h2><ul>
<li>chmod 修改文件或者文件夹权限</li>
<li>chown 修改文件或者文件夹的组 ， 或者用户</li>
<li>例子 ： chmod xxx（数字）xxx名字</li>
<li>如果要该文件夹 则要 chmod -R xxx数字 xxx名字</li>
<li>例子 ： chown xxx用户：xxx用户 文件名</li>
<li>同样也可以用-R ，来修改文件夹</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>如果要访问问文件夹里的文件，要先看上面的文件夹的权限是啥样的</li>
</ul>
<h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><ul>
<li>ll -h ，du -sh</li>
<li>而对于文件夹 du -sh也可以查看 ，ll -h 就不行</li>
<li>du -sh ： 最小是4k ， 但是他无法查看权限</li>
</ul>
<h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><ul>
<li>find</li>
<li>locate（没有网，不建议用）</li>
<li>例子 ： find 【path】 【表达式】 </li>
<li>表达式 ： -name “xxx” : 按照名字查找</li>
<li>比如 ： find &#x2F; -name “1.log”</li>
</ul>
<h2 id="vi-x2F-vim"><a href="#vi-x2F-vim" class="headerlink" title="vi&#x2F;vim"></a>vi&#x2F;vim</h2><ul>
<li>编辑文件</li>
<li>尾行模式 ： wq 退出保存</li>
<li>如果编辑文件的时候突然不小心把编辑的时候中断了，就是ctrl + c 或者 ctrl + z</li>
<li>解决方法 ： 删除Swap文件是隐藏文件 ，.开头的</li>
<li>行号 ： 首先进入尾行模式</li>
<li>set nu 就会有行号</li>
<li>set nonu就可以取消行号</li>
</ul>
<h2 id="常用快捷方式"><a href="#常用快捷方式" class="headerlink" title="常用快捷方式"></a>常用快捷方式</h2><ul>
<li>dd ： 删除当前行</li>
<li>dG ： 删除当前行 以及以下所有行</li>
<li>ndd ： 删除这个行 以及下面n行</li>
<li>u ：　撤回</li>
<li>ｇｇ　：　跳转到第一行的第一个字母</li>
<li>Ｇ　：　跳转到最后一行的第一个字母</li>
<li>ｓｈｉｆｔ　＋ $  ： 就是跳转到行尾</li>
<li>ｓｈｉｆｔ　＋ ^  : 跳转到行头</li>
<li>i ： 是当前行编辑</li>
<li>o ： 是跳转到下一行编辑</li>
</ul>
<h3 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h3><ul>
<li>gg -&gt; dG</li>
<li>linux 有一个空的文件</li>
<li>然后 cat &#x2F;dev&#x2F;null  &gt; xxx文件名字</li>
</ul>
<h2 id="系统相关命令"><a href="#系统相关命令" class="headerlink" title="系统相关命令"></a>系统相关命令</h2><ul>
<li>内存 ： free</li>
<li>磁盘 ： df</li>
<li>可能会添加磁盘</li>
<li>可通过这个来判断</li>
<li>后来挂载的一般是vdb的</li>
<li>负载 ： top</li>
<li>load average ： xxx xxx xxx</li>
<li>第一个是5分钟之内的负载</li>
<li>第二个是10分钟</li>
<li>第三个是15分钟</li>
<li>如果任意一个超过十 ，说明当前公司的服务器 比较卡</li>
<li>pid是进程号</li>
<li>user是那个用户</li>
<li>重启的目的 ： </li>
<li>检查是不是硬件有无问题</li>
</ul>
<h2 id="yum-x2F-rpm"><a href="#yum-x2F-rpm" class="headerlink" title="yum&#x2F;rpm"></a>yum&#x2F;rpm</h2><ul>
<li>安装linux软件的方式 联网</li>
<li>yum search xxx</li>
<li>下载下来的一个安装包以rpm存储</li>
<li>yum install xxx</li>
</ul>
<h2 id="通讯命令"><a href="#通讯命令" class="headerlink" title="通讯命令"></a>通讯命令</h2><ul>
<li>ping + ip</li>
<li>telnet ip 端口 :检查对面的端口是不是开放</li>
<li>端口 ： 1-65535</li>
<li>两个机器要在一个网段</li>
<li>ping通就代表是网络ok</li>
</ul>
<h2 id="补充命令"><a href="#补充命令" class="headerlink" title="补充命令"></a>补充命令</h2><ul>
<li>which + 命令</li>
<li>whereis + 命令</li>
<li>查看linux或者某个软件的shell脚本是不是存在</li>
<li>which ： 是查看自己环境变量的命令存在吗</li>
<li>whereis ： 是查看全局变量的名利给的存在吗</li>
</ul>
<h2 id="修改机器名字"><a href="#修改机器名字" class="headerlink" title="修改机器名字"></a>修改机器名字</h2><ul>
<li>hostnamectl ： xxxx</li>
</ul>
<h2 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h2><ul>
<li>linux 对zip和gz可以解压</li>
<li>zip xxx.zip （-r） xxx文件（这里压缩可以多个）如果是文件夹则要加上-r</li>
<li>代表压缩到xxx.zip里</li>
<li>解压</li>
<li>unzip xxx.zip （-d xxx文件夹）</li>
<li>tar ：</li>
<li>例子 ： tar -cf xxx.tar xxx文件（可以多个）</li>
<li>解压：</li>
<li>例子 ： tar -xf xxx.tar -C xxx文件夹</li>
<li>可以不加-C就是默认解压当前文件目录</li>
<li>压缩：</li>
<li>用z命令</li>
<li>tar -zcf xxx.tar xxx文件（可以多个）</li>
<li>解压：</li>
<li>tar -zxf xxx.tar -C xxx文件夹</li>
<li>我们可以再加上v让他们显示详细得处理文件的过程</li>
<li>zxvf：同上</li>
<li>zxcf：同上</li>
</ul>
<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><ul>
<li>当用yum安装成功之后 ，可以直接用系统命令启动</li>
<li>比如 ： service name start|status|restart|stop  : centos6</li>
<li>syystemctl start|status|restart|stop name : centos7</li>
<li>查看进程</li>
<li>ps -ef</li>
<li>可以进行筛选</li>
<li>ps -ef|grep xxx名字</li>
<li>杀死进程 </li>
<li>kill -9 + 进程号</li>
<li>查端口：</li>
<li>netstat -nlp | grep xxxname</li>
<li>通过</li>
<li>:::80</li>
<li>ip:80</li>
<li>0.0.0.0:80</li>
<li>我们可以通过外部机器访问这个端口进入服务界面</li>
<li>kill -9 $(pgrep -f xxx名字)</li>
<li>下面的会强制把他们全杀掉 ， 包括子进程</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>hadoop</title>
    <url>/2022/11/11/11-10/</url>
    <content><![CDATA[<h1 id="hadoop简介"><a href="#hadoop简介" class="headerlink" title="hadoop简介"></a>hadoop简介</h1><ul>
<li>以阿帕奇软件 ，hadoop为主的生态圈 </li>
<li>狭义就是Hadoop</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>hdfs ： 存储海量的数据</li>
<li>mapreduce ： 计算分析</li>
<li>yarn ： 资源和作业的调度</li>
</ul>
<h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><ul>
<li>存储是第一位的</li>
<li>计算是第二位的</li>
</ul>
<h2 id="学习介绍"><a href="#学习介绍" class="headerlink" title="学习介绍"></a>学习介绍</h2><ul>
<li>官网进行学习</li>
<li><code>hadoop.apache.org</code></li>
<li>但是后面的其余框架对应的官网就是 把hadoop 改掉</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines, each offering local computation and storage. Rather than rely on hardware to deliver high-availability, the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="hadoop模块的简介"><a href="#hadoop模块的简介" class="headerlink" title="hadoop模块的简介"></a>hadoop模块的简介</h3><ul>
<li>hdfs ：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A distributed file system that provides high-throughput access to application data.</span><br></pre></td></tr></table></figure>

<ul>
<li>mapredurce :</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A YARN-based system for parallel processing of large data sets</span><br></pre></td></tr></table></figure>

<ul>
<li>yarm :</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A framework for job scheduling and cluster resource management</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="版本以及主流"><a href="#版本以及主流" class="headerlink" title="版本以及主流"></a>版本以及主流</h3><ul>
<li>版本 ： 1.x ， 2.x ， 3.x</li>
<li>主流 ： 2.x -》 3.x</li>
<li>公司所用 ： </li>
<li>apache 原生</li>
<li>cdh ： 5.x ， 6.x 从6.3之后开始收费</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ul>
<li>安装的是什么？</li>
<li>Hadoop有什么？</li>
<li>我们只用部署 yarn hdfs 因为mapredurce是java代码人员给我们的 ：都是主从架构的</li>
<li>hdfs ： </li>
<li>namenode : 老大 负责指挥数据的存储</li>
<li>datanode ： 主要负责数据的存储</li>
<li>seconderynamenode ： 负责辅助namenode的</li>
<li>yarn :</li>
<li>resourcemanager : 老大 负责资源分配</li>
<li>nodemanager ： 小弟负责资源分配给xxx</li>
</ul>
<h3 id="部署模式"><a href="#部署模式" class="headerlink" title="部署模式"></a>部署模式</h3><ul>
<li>单点模式 ：所有都在一台机器上</li>
<li>完全分布式模式 ：分布在多台机器上</li>
</ul>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul>
<li>部署平台 ： windows 和linux</li>
<li>一般linux用的多 ，而且在linux上最少2000台</li>
<li>jdk ： 安装java的要求</li>
<li>3.3-目前 ： java8 - 11</li>
<li>3.0-3.2 ： java8</li>
<li>2.7-2.10 ： java8</li>
<li>但是有些的java8 的版本也不行 ，详细参考官网</li>
<li>要下载补丁安装就好</li>
<li>ssh ： 默认centos是安装的，但是ubantu是没安装的</li>
<li>个人要求 ：创建hadoop用户 ，以后我们都用那个用户开发</li>
<li>而且创建 几个文件夹进行规范</li>
<li>app ：app</li>
<li>data ：数据 </li>
<li>log ：监控日志</li>
<li>project ：项目 </li>
<li>shell ： shell脚本</li>
<li>software ： 安装包</li>
<li>以前版本的apche 版本框架 在</li>
<li><code>archive.apache.org/dist</code></li>
<li>部署jdk</li>
<li>hadoop ： 无要求</li>
</ul>
<h3 id="配置开始"><a href="#配置开始" class="headerlink" title="配置开始"></a>配置开始</h3><ul>
<li>把文件解压</li>
<li>配置环境变量</li>
<li>个人 ： 修改 .&#x2F;bashrc </li>
<li>添加 exprot JAVA_HOME&#x3D; xxxx</li>
<li>export PATH&#x3D;${JAVA_HOME}&#x2F;bin:$PATH</li>
<li>export HADOOP_HOME&#x3D;mmm</li>
<li>export PATH&#x3D;${HADOOP_HOME}&#x2F;bin:${HADOOP_HOME}&#x2F;sbin:$PATH</li>
<li>上面xxxx和mmm</li>
<li>分别代表我们的java的和hadoop的解压目录</li>
<li>然后我们导入个人环境变量 ， </li>
<li>source ~&#x2F;.bashrc</li>
<li>然后验证安装 java -version 和 hadoop version</li>
<li>如果成功就代表安装成功了</li>
<li>接下来我们更改hadoop的配置文件</li>
<li>进入到hadoop的etc文件夹里</li>
<li>编辑 core-site.xml</li>
<li>在两个标签之间输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">	&lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">	&lt;value&gt;hdfs://你的机器名:9000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>编辑hdfs-site.xml</li>
<li>在两个标签之间输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">	&lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">	&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来我们进行开放访问 ， 我们先执行</li>
<li><code>ssh user@hostname [com]</code> 进行登录</li>
<li>然后通过输入密码登陆一次</li>
<li>上一条的的命令如果加上com则代表登录并执行这个命令</li>
<li>然后我们要设置免密登录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 0600 ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>然后继续上述的命令：看看能不能免密登录</li>
<li>成功之后，我们要更改文件格式 ： 相当于初始化操作</li>
<li>然后我们启动dhfs</li>
<li><code>start-dfs.sh</code></li>
<li>然后我们访问 <code>http://你的虚拟机ip:9870/</code></li>
<li>成功看见hadoop的web页面就好了</li>
<li>然后可以更简便的方法</li>
<li>在c盘找到 windows 然后进去system32</li>
<li>然后进去driver</li>
<li>然后进入etc文件</li>
<li>然后在hosts文件最后的加上我们在linux里的主机和ip映射</li>
<li>就可以通过 <code>http://你的虚拟机名称:9870/</code>访问我们的hadoop了</li>
</ul>
<h3 id="部署yarn"><a href="#部署yarn" class="headerlink" title="部署yarn"></a>部署yarn</h3><ul>
<li>对于部署单点的yarn</li>
<li>我们可以通过配置yarn的配置文件</li>
<li><code>mapred-site.xml</code> 和<code>yarn-site.xml</code></li>
</ul>
<h4 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h4><ul>
<li>对于这个文件我们这样更改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h4><ul>
<li>对于这个文件我们进行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">#设置web访问的端口</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;你的主机名称:9999&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">#设置运行在那个虚拟机上</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;你的主机名&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#下面两个要基本配置</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_HOME,PATH,LANG,TZ,HADOOP_MAPRED_HOME&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>配置完成之后我们要进行<code>start-yarn.sh</code></li>
<li>然后开启这个服务 ： 我们可以通过访问浏览器的 <code>xxx你的ip:9999</code> ,访问这个服务</li>
<li>这样我们的单点就算配置完成了</li>
</ul>
<h2 id="关于分布式的配置"><a href="#关于分布式的配置" class="headerlink" title="关于分布式的配置"></a>关于分布式的配置</h2><ul>
<li>分布式的配置就是把单点的配置分到多台机器上</li>
<li>比如 ： 把hdfs的namenode 和 datanode 和secondnamenode分到三台机器上</li>
<li>把yarn的部署也分到三台机器上</li>
</ul>
<h3 id="开始分布式"><a href="#开始分布式" class="headerlink" title="开始分布式"></a>开始分布式</h3><ul>
<li>首先我们要明确一点 ： namenode是老大 ，只能有一个</li>
<li>datanode是小弟 ：  可以有多个</li>
<li>secondnamenode ：是秘书只能有一个</li>
<li>对于yarn ： resourcemanager只能有一个</li>
<li>而 ：nodemanagers ：可有多个</li>
</ul>
<h4 id="开始之前的配置"><a href="#开始之前的配置" class="headerlink" title="开始之前的配置"></a>开始之前的配置</h4><ul>
<li>关于hdfs和上面部署的一样</li>
<li>只不过在配置免密登录的时候不同</li>
<li>因为我们现在要做三台机器互相免密</li>
<li>所以我们要用</li>
<li><code>ssh-keygen -t rsa</code> 然后三次回车生成公钥和私钥</li>
<li>然后三台机器都要用一遍</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ssh-copy-id 第一台机器名</span><br><span class="line">ssh-copy-id 第二台机器名</span><br><span class="line">ssh-copy-id 第三台机器名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>然后分别对三台机器用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ssh hadoop@第一台机器名</span><br><span class="line">ssh hadoop@第二台机器名</span><br><span class="line">ssh hadoop@第三台机器名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>最后分别ssh一下然后如果能成功就代表成功了</li>
</ul>
<h4 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h4><ul>
<li><code>core-site.xml</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">#设置存储位置</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/data/hadoopdate&lt;/value&gt;</span><br><span class="line"> &lt;/property&gt;</span><br><span class="line">#设置namenode在哪一台机器上运行</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://主机器的名称:9000&lt;/value&gt;</span><br><span class="line"> &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-<code>workers</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一台机器的名称</span><br><span class="line">第二台机器的名称</span><br><span class="line">第三台机器的名称</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>hdfs-site.xml</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"> #下面的values代表是几台机器，我这个是三台机器</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  #设置secondarynamenode的端口和在哪一台机器上</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;bigdata4:9868&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">#同上一个</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.secondary.https-address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;bigdata4:9869&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>然后三台机器都要配置相同的环境变量</li>
</ul>
<h4 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h4><ul>
<li><code>mapred-site.xml</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>yarn-site.xml</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">#设置resourcemanager其所占用的端口</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;bigdata5:9999&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">#设置resourcemanager其所在的机器</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;bigdata5&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">#下面两个是正常yarn的配置文件</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_HOME,PATH,LANG,TZ,HADOOP_MAPRED_HOME&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>同样三台机器也要配置相同的文件</li>
<li>然后我们要在我们的namenode机器上</li>
<li>开始初始化： <code>hdfs namenode -format</code></li>
<li>然后我们在namenode上开始运行<code>start-dfs.sh</code></li>
<li>然后我们在resourcemanager上开始运行<code>start-yarn.sh</code></li>
<li>然后我们可以用jps查看每个机器的进程</li>
<li>查看是不是符合我们的想法</li>
</ul>
<h3 id="关于datanode缺失"><a href="#关于datanode缺失" class="headerlink" title="关于datanode缺失"></a>关于datanode缺失</h3><ul>
<li>因为默认hadoop有一个id文件是在<code>/tmp/hadoop-hadoop/dfs</code>下的</li>
<li>我们默认启动的时候可能有多个原因 ，造成生成的id不一致</li>
<li>比如 ； 我们忘记关闭hadoop服务之类的，或者卸载的时候忘记删掉他了</li>
<li>这些都会造成id不一致的问题</li>
<li>解决方法： </li>
<li>如果dfs文件夹中没有重要的数据，那么删除dfs文件夹，再重新运行下列指令（格式化指令）</li>
<li>如果dfs文件中有重要的数据，那么在dfs&#x2F;name目录下找到一个current&#x2F;VERSION文件，记录clusterID并复制。然后dfs&#x2F;data目录下找到一个current&#x2F;VERSION文件，将其中clustreID的值替换成刚刚复制的clusterID的值即可</li>
</ul>
<h2 id="hdfs的命令"><a href="#hdfs的命令" class="headerlink" title="hdfs的命令"></a>hdfs的命令</h2><ul>
<li>创建文件夹 <code>hdfs dfs -mkdir xxx</code> : 创建xxx文件夹，可以多层创建文件夹</li>
<li>创建文件<code>hdfs dfs -touchz path</code></li>
<li>复制文件<code>hdfs dfs -cp 源目录 目标路径</code> ：这个是把整个文件夹结构都cp过去：属于hdfs的内部操作不是上传下载</li>
<li>移动文件<code>hdfs dfs -mv 源目录 目标目录</code></li>
<li>赋予权限<code>hdfs dfs -chmod 权限参数 </code></li>
<li>上传文件<code>hdfs dfs -put 源文件夹路径 目标文件夹路径</code></li>
<li>上传文件<code>hdfs dfs -copyFromLocal 源文件夹 目标文件夹</code></li>
<li>上传文件且删除本地文件<code>hdfs dfs -moveFromLocal 源文件 目标文件</code></li>
<li>下载文件<code>hdfs dfs -get 源文件夹路径 目标文件夹路径</code></li>
<li>查看文件内容 <code>hdfs dfs -cat path</code>从头看这个文件</li>
<li>查看文件内容 <code>hdfs dfs -tail path</code>查看这个文件的最后1k</li>
<li>删除文件<code>hdfs dfs -rm 文件路径</code></li>
<li>删除文件夹<code>hdfs dfs -rm -R 文件夹</code></li>
</ul>
<h2 id="javaapi的方式操作hdfs"><a href="#javaapi的方式操作hdfs" class="headerlink" title="javaapi的方式操作hdfs"></a>javaapi的方式操作hdfs</h2><ul>
<li><p>单元测试 ： 代表我们可以 ， 单独运行某个方法</p>
</li>
<li><p>进行部份调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.FileSystem;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.net.URISyntaxException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class hdfsapi &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public  void  mkdir() throws IOException, URISyntaxException, InterruptedException &#123;</span><br><span class="line">        // 获取程序入口</span><br><span class="line">        Configuration conf = new org.apache.hadoop.conf.Configuration(); //  配置参数</span><br><span class="line">        URI uri = new URI(&quot;hdfs://192.168.41.132:9000&quot;); //创建uri作为要连接的地址和端口</span><br><span class="line">        FileSystem fs = FileSystem.get( uri , conf , &quot;hadoop&quot;); // 开始链接 ，三个参数分别是其所在地地方，配置参数 ，用户名</span><br><span class="line">        Path path = new Path(&quot;/ggd&quot;); // 路径</span><br><span class="line">        boolean mkdir = fs.mkdirs(path); // 判断是不是执行成功</span><br><span class="line">        Assert.assertEquals(true , mkdir);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现创建文件夹并移动且改名</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.FileSystem;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class hdfsapi &#123;</span><br><span class="line"></span><br><span class="line">    static FileSystem  fs;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        conf.set(&quot;fs.defaultFS&quot; , &quot;hdfs://192.168.41.132:9000&quot;);</span><br><span class="line">        System.setProperty(&quot;HADOOP_USER_NAME&quot; ,&quot;hadoop&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            fs = FileSystem.get(conf);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 移动之前的文件存储路径</span><br><span class="line">        String url = args[1];</span><br><span class="line">        // 移动之后的文件存储路径</span><br><span class="line">        String det = args[2];</span><br><span class="line"></span><br><span class="line">        String hozhui = args[0];</span><br><span class="line"></span><br><span class="line">        // 要上传的文件目录</span><br><span class="line">        String pathlocalfile = args[3];</span><br><span class="line"></span><br><span class="line">        Integer date = Integer.parseInt(args[4]);</span><br><span class="line"></span><br><span class="line">        Integer up = Integer.parseInt(args[5]);</span><br><span class="line"></span><br><span class="line">        Integer down = Integer.parseInt(args[6]);</span><br><span class="line"></span><br><span class="line">        String[] string = new String[args.length - 7];</span><br><span class="line"></span><br><span class="line">        System.arraycopy(args , 7 , string , 0 , args.length - 7);</span><br><span class="line"></span><br><span class="line">        makeream(hozhui,url,det,pathlocalfile,date , up ,down , string);</span><br><span class="line"></span><br><span class="line">      //rm(20221115 , 1 , 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void rm(int m , int up ,int down ) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 通过递归调用本身函数，进行递归调用，删除不同日期的文件夹以及</span><br><span class="line">        while (up &gt; 0)&#123;</span><br><span class="line">            rm(m+1 , --up , 0);</span><br><span class="line">        &#125;</span><br><span class="line">        // 同上</span><br><span class="line">        while (down &gt; 0)&#123;</span><br><span class="line">            rm(m-1 , 0 ,--down);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 把数字改变成字符串</span><br><span class="line">        String uri = String.valueOf(m);</span><br><span class="line"></span><br><span class="line">        // 基础路径</span><br><span class="line">        Path path = new Path(&quot;/data/dt=&quot; + uri);</span><br><span class="line">        Path path1 = new Path(&quot;/data/hive&quot; + &quot;/&quot; + uri + &quot;-01.data&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fs.delete(path);</span><br><span class="line">            fs.delete(path1);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void makeream(String hozhui, String url , String det ,String pathlocalfile , int nowday , int up , int down , String ...args) &#123;</span><br><span class="line">        // 基礎路徑</span><br><span class="line">        String dataurl = null;</span><br><span class="line">        if (args.length &gt; 0)&#123;</span><br><span class="line">            String[] arg1 = new String[args.length-1];</span><br><span class="line">            System.arraycopy(args , 1 , arg1 ,0 ,args.length-1);</span><br><span class="line">            dataurl = args[0];</span><br><span class="line">            makeream(hozhui,url,det,pathlocalfile,nowday,up,down,arg1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dataurl = String.valueOf(nowday);</span><br><span class="line">            // 通过递归的方式 ， 进行创建文件夹等操作</span><br><span class="line">            while (up &gt; 0)&#123;</span><br><span class="line">                makeream(hozhui,url,det,pathlocalfile,nowday+1 , --up , 0);</span><br><span class="line">            &#125;</span><br><span class="line">            while (down &gt; 0)&#123;</span><br><span class="line">                makeream(hozhui,url,det,pathlocalfile,nowday-1 , 0 ,--down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取文件名字</span><br><span class="line">        String[] split = pathlocalfile.split(&quot;/&quot;);</span><br><span class="line">        String filname = split[split.length-1];</span><br><span class="line">        // 上传的文件路径</span><br><span class="line">        Path pathfile = new Path(pathlocalfile);</span><br><span class="line">        // 最后的文件的名字</span><br><span class="line">        String settotal = det+ &quot;/&quot; + dataurl + hozhui;</span><br><span class="line">        // 刚开始创建的文件目录</span><br><span class="line">        String urltotal = url + dataurl;</span><br><span class="line">        // 创建文件夹的Path</span><br><span class="line">        Path path = new Path(urltotal);</span><br><span class="line">        // 移动前的文件路径</span><br><span class="line">        Path pathfilehdfs = new Path( path + &quot;/&quot; + filname);</span><br><span class="line">        // 新的名字文件路径</span><br><span class="line">        Path newname = new Path(settotal);</span><br><span class="line"></span><br><span class="line">//        // 要移动到的路径</span><br><span class="line">//        Path detPath = new Path(url1);</span><br><span class="line"></span><br><span class="line">        // 后来的文件目录</span><br><span class="line">        // Path detpathfile = new Path(det + &quot;/&quot; + filname);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if(!fs.exists(new Path(det)))&#123;</span><br><span class="line">                fs.mkdirs(new Path(det));</span><br><span class="line">            &#125;</span><br><span class="line">            fs.mkdirs(path);</span><br><span class="line">            fs.copyFromLocalFile(pathfile , path);</span><br><span class="line">            // fs.rename(pathfilehdfs , detPath);</span><br><span class="line">            fs.rename(pathfilehdfs , newname);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>单词统计</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.FSDataInputStream;</span><br><span class="line">import org.apache.hadoop.fs.FileSystem;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IOUtils;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class wordcount &#123;</span><br><span class="line">    static FileSystem fs;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        conf.set(&quot;fs.defaultFS&quot; , &quot;hdfs://192.168.41.132:9000&quot;);</span><br><span class="line">        System.setProperty(&quot;HADOOP_USER_NAME&quot; ,&quot;hadoop&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            fs = FileSystem.get(conf);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        wordcounts(&quot;/2.log&quot; , &quot;,&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void wordcounts( String path ,  String regx ) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String basic = null;</span><br><span class="line"></span><br><span class="line">        try( FSDataInputStream fis = fs.open(new Path(path));</span><br><span class="line">             OutputStream outputStream = new FileOutputStream( new File(&quot;D:\\ bg1.txt&quot;) , false);</span><br><span class="line">             InputStream inputStream = new FileInputStream(new File(&quot;D:\\ bg1.txt&quot;));</span><br><span class="line">             )</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            IOUtils.copyBytes(fis,outputStream,4096 , true);</span><br><span class="line">            byte[] buffer = new byte[1024];</span><br><span class="line">            int len = 0;</span><br><span class="line">            while((len = inputStream.read(buffer)) != -1)&#123;</span><br><span class="line">                basic = new String(buffer, 0, len);</span><br><span class="line">                System.out.println(basic);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            String[] split = basic.split(regx);</span><br><span class="line"></span><br><span class="line">            Map&lt;String , Integer&gt; result = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            for (int i=0;i&lt;split.length;i++)&#123;</span><br><span class="line">                result.put(split[i] , result.getOrDefault(split[i] , 0 )+1);</span><br><span class="line">            &#125;</span><br><span class="line">                result.forEach((k,v)-&gt;System.out.println(k+&quot;,&quot;+v));</span><br><span class="line"></span><br><span class="line">            int[] flag = new int[split.length];</span><br><span class="line">            for (int i =0; i&lt; split.length; i++)&#123;</span><br><span class="line">                for (int j = 0; j&lt; split.length;j++)&#123;</span><br><span class="line">                    if (split[i].equals(split[j]))&#123;</span><br><span class="line">                        flag[i]++;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;--------------------------------------------------------&quot;);</span><br><span class="line">            for (int i =0; i&lt;split.length-1;i++)&#123;</span><br><span class="line"></span><br><span class="line">                if (!(split[i].equals(split[i+1])))&#123;</span><br><span class="line">                    System.out.println(split[i] + &quot;\t&quot; + flag[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">//            System.out.print(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">//            for (int i =0; i&lt; flag.length;i++)&#123;</span><br><span class="line">//                System.out.print(flag[i]);</span><br><span class="line">//                System.out.print(&quot;\t&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;--------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关于文件的存储"><a href="#关于文件的存储" class="headerlink" title="关于文件的存储"></a>关于文件的存储</h3><ul>
<li>架构设计 ： 面试必问</li>
<li>namenode —–nn</li>
<li>负责对外的访问接口</li>
<li>负责块的映射</li>
<li>元数据 ； 描述数据的数据</li>
<li>文件名称</li>
<li>文件的目录</li>
<li>文件的属性，权限，创建时间，副本数据</li>
<li>blockmap ： 块映射</li>
<li>一个 文件被分割成多个数据块，</li>
<li>块映射不会永久化这个存储</li>
<li>是通过集群运行的时候dn定期发送blockreport给nn进行维护</li>
<li>控制其数据块在哪一个节点上的</li>
<li>nn作用 ： 管理文件的命名空间 ，其实就算维护文件系统树的文件以及文件夹</li>
<li>是以两种的方式永久的存储在磁盘</li>
<li>镜像文件 ： fsimage</li>
<li>编辑日志文件 editlogs</li>
<li>seconderynamenode ——snn</li>
<li>去老大的节点上拿镜像文件和日志文件，进行合并和备份，然后换给nn</li>
<li>datanode —–dn</li>
<li>每个节点都会有这个进程</li>
<li>负责关于客户端的文件的读写</li>
<li>负责存储数据</li>
<li>存储数据块，以及对于数据块的校验</li>
<li>每隔3秒发送一次心跳给namenode ，告诉你我还在</li>
<li>每个一定时间（6h）发送一次块报告,这个报告，是扫描磁盘和内存之中的数据一不一样</li>
<li>目的 ： 生产上 ： 可能会发生文件块丢失或者损坏</li>
<li></li>
</ul>
<h2 id="mapreduce"><a href="#mapreduce" class="headerlink" title="mapreduce"></a>mapreduce</h2><ul>
<li>简介 ： 其设计理念是计算向数据靠拢，采用分而治之的策略，将庞大的数据分为很多个很多个小切片，并且为每个小切片单独的启动一个map任务</li>
<li>适合mapredurce处理的数据集要满足一个前提：待处理的数据集可以分解成许多更小的数据集，且每一个更小的数据集都可以并行的处理</li>
<li>其采用的是主从架构（master&#x2F;Slave），就是一个主服务器多个从服务器（salve），master上运行jobTracker，slaver运行TaskTracker</li>
</ul>
<h3 id="mapreduce体系架构"><a href="#mapreduce体系架构" class="headerlink" title="mapreduce体系架构"></a>mapreduce体系架构</h3><ul>
<li>其主要是由四个部分组成 ： 分别是Client , JobTracker,TaskTracker以及Task</li>
<li>Client ： 用户编写的Mapredurce程序通过Client提交到jobTracker</li>
<li>jobTracker(运行在主服务器上) : 负责监控和资源调度</li>
<li>监控所有的TaskTracker与job的健康情况，一旦发现失败，就把相应的任务转移到其他的节点</li>
<li>其会跟踪任务的执行调度，资源使用量，并将这些信息告诉任务调度器（TaskScheduler），而调度器会在资源调度器出现空闲时，选择合适的任务去使用这些资源</li>
<li>jobTracker（运行在服务器） </li>
<li>TaskTracker会周期性的通过心跳将本节点上资源的使用情况和任务运行进度汇报给jobTracker，同时接受jobTracker发送过来的命令并执行相应的操作（如 ： 启动新任务 ，杀死任务等）</li>
<li>TaskTracker使用“slot”等量划分本节点上的资源量（CPU ，内存）。一个Task获取到一个slot后才有机会运行，而hadoop调度器的作用就是将各个TaskTracker上的空闲slot分配给Task使用。slot分为Map slot和Reduce slot两种，分别提供Map Task和Redurce Task使用</li>
<li>Task</li>
<li>Map Task和Redurce Task 均由TaskTracker</li>
</ul>
<h3 id="mapreduce的工作流程"><a href="#mapreduce的工作流程" class="headerlink" title="mapreduce的工作流程"></a>mapreduce的工作流程</h3><ul>
<li>一个大的mapredurce任务，首先会被分为为若干个Map任务在多台机器上执行运行（map任务通常运行在存储节点上），每一个map任务会输出一个&lt;key , value&gt;形式的中间结果，一个map任务只有全部执行完成之后才会进行reduce任务，map的输出结果&lt;key, value&gt;（存储在本地磁盘） ， 具有相同的key会被发送到同一个reduce任务</li>
<li>注意 ：不同的map之间不会有通信</li>
<li>不同的reduce之间也不会</li>
<li>用户不能显式的从一台机器向另外一台机器发送消息，所有的信息交换都是通过Mapredurce框架自身去实现</li>
<li>map的输入文件，redurce任务的输出结果都是保存在hdfs分布式文件系统中，map的输出结果保存在本地磁盘文件中</li>
<li>当一个map任务处理全部结束之后，reduce任务才能开始去取相应的数据</li>
<li>只有map任务需要考虑数据局限性，实现计算向数据靠拢，reduce无需考虑数据局限性</li>
</ul>
<h4 id="各阶段执行内容"><a href="#各阶段执行内容" class="headerlink" title="各阶段执行内容"></a>各阶段执行内容</h4><ul>
<li>分为 ：5个阶段 预处理，map，shuffle，reduce，输出</li>
<li>预处理 ： 由inputFormat 进行格式验证以及逻辑上的分区inputSplit ， inputSplit经过redodrdreader</li>
<li>根据inputSplit的信息来处理inputSplit中的具体记录，转换为键值对 ，输入给map</li>
<li>map ： 接受来自RR键值对，进行分区，排序，合并，归并，得到&lt;key , value-list&gt;形式的中间结果，输入给reduce，此处包括map端的shuffle和reduce端的shuffle</li>
<li>reduce ： 接受shuffle输出的&lt;key , value&gt;,执行用户子自定义，输出给outputFromat</li>
<li>输出 ： outputFromat，模块会验证输出目录是不是已经存在以及输出结果是不是符合配置文件中的配置类型，如果满足，就输出reduce的结果到分布式文件系统</li>
</ul>
<h4 id="map的shuffle"><a href="#map的shuffle" class="headerlink" title="map的shuffle"></a>map的shuffle</h4><ul>
<li>过程有四部</li>
<li>输入数据并执行map任务</li>
<li>map任务结果输出，写入缓存</li>
<li>溢写 ： 如果输出结果超过了一定的比例，每一次溢写会在磁盘上生成一个磁盘文件，写入之前进行会分区，，排序，如果指定了commbiner还可以进行合并，这样经过溢写的磁盘文件就包含了多个分区，且分区内部都是经过排序的</li>
<li>merge ： 随着map任务的进行，当有多个溢写文件时（就是大于等于2的适合），就会发现merge，生成一个更大的磁盘文件，这个大的溢写文件也是经过排序和分区的，默认情况下每10个溢写会变成一个大文件，通常在merge过程中，如果文件数量大于3则进行combine操作，从而减少磁盘的数据量，如果只有一两个溢写，合并操作得不偿失</li>
</ul>
<h4 id="reduce的shuttle"><a href="#reduce的shuttle" class="headerlink" title="reduce的shuttle"></a>reduce的shuttle</h4><ul>
<li>领取数据 ： 经过map的suffle后，map的输出结果保存在磁盘，此时，需要将磁盘数据取回到reduce机器，此时如果线程被占满，同样会和map端一样开启溢写操作，reduce通过RPC询问JobTracker是不是还拥有未完成的map任务，如果有，将数据提取到reduce机器上，此时实际上是多个reduce机器，同时多线程从map机器领回数据</li>
<li>merge ： 一个map的shuffle结果因为拥有多个分区，所以会有不同的reduce机器取回自己的数据，而每一个reduce也从不同的map机器取回数据，如果每个reduce机器内存达到阈值，就进行溢写操作，溢写的时候一般有很多键值对可以进行merge，如果定义了combiner还可以进行合并，进行溢写操作的过程中还可以进行combine。并非是一个reduce程序从map机器上取回数据就生成一个溢写文件，而是缓存不够用，则发生溢写，如果缓存够用，则是直接在内存里进行操作</li>
<li>把数据输出给map任务（对一个reduce而言）：执行用户自定义的逻辑，最终输出</li>
</ul>
<h2 id="mapredurce里的数据类型"><a href="#mapredurce里的数据类型" class="headerlink" title="mapredurce里的数据类型"></a>mapredurce里的数据类型</h2><ul>
<li>intWritable</li>
<li>longWritable</li>
<li>等等，</li>
<li>就是基本数据类型加上Writable</li>
<li>在redurce里数据类型也是一样的</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>hadoop面试会问</title>
    <url>/2022/11/17/11-17/</url>
    <content><![CDATA[<h1 id="hdfs的写流程"><a href="#hdfs的写流程" class="headerlink" title="hdfs的写流程"></a>hdfs的写流程</h1><ul>
<li>面试|必备</li>
<li>通过客户端，写文件</li>
<li>首先客户端会调用 FileSystem 的creat</li>
<li>去和namenode进行通信 ， 是通过rpc通信</li>
<li>然后namenode会去检查这个路径的文件是不是存在并且检查你的权限</li>
<li>假如都ok ， 则执行你的操作</li>
<li>但是这个时候还没有写数据</li>
<li>是不关联任何block的</li>
<li>而namenode根据上传文件的大小，和块的大小，以及副本数</li>
<li>计算要上传多少块以及后续要在datanode上的什么位置</li>
<li>最后把信息返回到客户端</li>
<li>就是 ： fsdataoutputstream</li>
<li>Client 调用 fdsdataoutputstream</li>
<li>将第一个块的第一个副本数写第一个dn节点</li>
<li>写完去写第二个</li>
<li>然后是第三个</li>
<li>当三个都写完了 ， 会返回一个ack package</li>
<li>把确认包给dn2</li>
<li>当dn2确认并加上自己的</li>
<li>然后给dn3，同上</li>
<li>最后将ack package 返回给 fdsdataoutputstream</li>
<li>上面只是对于第一个块</li>
<li>当所有的块全部写完的时候，我们会调用</li>
<li>这个流对象的close方法</li>
<li>告诉namenode ，文件写入成功</li>
</ul>
<h1 id="hdfs读操作"><a href="#hdfs读操作" class="headerlink" title="hdfs读操作"></a>hdfs读操作</h1><ul>
<li>面试|必备</li>
<li>Cilent调用FS.open(filepath)</li>
<li>nn和pc进行通信，返回该文件的部分或者全部的block列表</li>
<li>以fdsdatainputstream的形式</li>
<li>Client的FSDDataInputstream的read方法</li>
<li>会去和最近的dn进行匹配，读取完成</li>
<li>会check，假如ok，就关闭通信</li>
<li>假如读取失败</li>
<li>会记录dn+block信息</li>
<li>下次就也不会从这个节点读取，转而从其他的节点读取</li>
<li>然后会去和第二块的最近的dn进行读取，以此类推</li>
<li>当整个block全部读取完之后，文件还没读取完，就会继续调用fs的方法进行下一次block的读取</li>
<li>以此类推</li>
<li>最后用close方法关闭</li>
</ul>
<h1 id="hdfs的副本放置策略"><a href="#hdfs的副本放置策略" class="headerlink" title="hdfs的副本放置策略"></a>hdfs的副本放置策略</h1><ul>
<li>机架</li>
<li>生产上读写操作，选择dn节点进行读取</li>
<li>第一副本 ： </li>
<li>放置在client上传的dn节点</li>
<li>client 不在dn节点 ，就随机选择一个dn</li>
<li>第二副本 ： </li>
<li>放置在第一个副本不同的机架上的一个dn节点</li>
<li>第三副本 ： </li>
<li>和第二副本相同机架但是不同节点</li>
<li>补充 ；</li>
<li>副本数是三</li>
<li>上述都是以副本数为3的情况</li>
<li>如果是4就多几个随机</li>
</ul>
<h1 id="hdfs的安全模式"><a href="#hdfs的安全模式" class="headerlink" title="hdfs的安全模式"></a>hdfs的安全模式</h1><ul>
<li>什么时候会发生安全模式</li>
<li>刚启动hadoop的时候</li>
<li>hsdf发生故障的时候 ： 集群文件大量会丢失</li>
<li>人为进入</li>
<li>命令 ： <code>hdfs dfsadmin -safemode &lt;enter | leave | get | wait | forceExit&gt;</code></li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>kill 命令 不只有一个-9</li>
<li>还有很多 ： 目前我所看见的至少有64个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP</span><br><span class="line">6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1</span><br><span class="line">11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM</span><br><span class="line">16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP</span><br><span class="line">21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR</span><br><span class="line">31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1    64) SIGRTMAX</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这个简单介绍几个 ： </li>
<li>1 ： 重新加载合格进程</li>
<li>9 ： 杀死一个进程</li>
<li>15 ： 正常停止一个进程</li>
</ul>
<h1 id="公司内部的逻辑"><a href="#公司内部的逻辑" class="headerlink" title="公司内部的逻辑"></a>公司内部的逻辑</h1><ul>
<li>一般一个组件都会有一个用户进行管理</li>
<li>比如 ： mysql ： 可以创建一个mysql用户</li>
<li>等</li>
<li>创建数据库的流程 ： </li>
<li><code>create dataase dl2262;</code></li>
<li><code>grant all priviledges on dl2262 identified by &quot;1234546;&quot;</code></li>
<li><code>flush priviledges;</code></li>
</ul>
<h1 id="hdfs生产最佳实践"><a href="#hdfs生产最佳实践" class="headerlink" title="hdfs生产最佳实践"></a>hdfs生产最佳实践</h1><ul>
<li>如何查看hdfs的文件块是不是丢失<br>-<code>hdfs fsck&lt;path&gt;</code></li>
</ul>
<h2 id="hdfs-的block块丢失了如何解决"><a href="#hdfs-的block块丢失了如何解决" class="headerlink" title="hdfs 的block块丢失了如何解决"></a>hdfs 的block块丢失了如何解决</h2><ul>
<li>第一种 ： 不用解决 ，也因为hdfs会自动回复，一般是6h ， 就是dn上传的时候</li>
<li>第二种 ： 手动进行回复</li>
<li><code>hdfs debug recoverLease -path &lt;filename&gt; retries num</code> </li>
<li>后面的是重试次数</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2022/11/02/11-2/</url>
    <content><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><ul>
<li>文件命名 ： 结尾一般以.sh结尾</li>
<li>不要编译 </li>
<li>文件第一行 ，一般写一个编辑器 ，就比如：#！bin&#x2F;bash</li>
<li>编写脚本</li>
<li>添加权限</li>
<li>chmod添加权限</li>
</ul>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul>
<li>sh .&#x2F;xxx.sh（脚本名字）</li>
<li>如果给予了执行权限就可以直接执行</li>
<li>debug</li>
<li>在 #！bin&#x2F;bash 后面加一个 -x</li>
<li>就可以看见程序运行的过程</li>
<li>还可以用 sh -x xxx脚本名字</li>
</ul>
<h1 id="在shell里定义变量以及引用"><a href="#在shell里定义变量以及引用" class="headerlink" title="在shell里定义变量以及引用"></a>在shell里定义变量以及引用</h1><ul>
<li>用read xx xx xx ：代表要从键盘输入3次，以空格分割 ， 如果要在自变量里面定义空格可以用 “xxx xxx” 这样就可以当成一个变量输入了</li>
<li>key&#x3D;value ： 定义变量</li>
<li>等号前后不能有空格</li>
<li>引用变量则用$xxx（变量的名字）</li>
<li>但是其中有单引号和双引号和反引号的区别</li>
<li>如果是单引号和双引号都是默认定义成字符串</li>
<li>如果是反引号&#96;&#96; 里面的会被解释成系统命令，并且执行</li>
<li>引用变量一般是要通过${} 而不是$</li>
<li>因为如果要拼接字符串的时候 ，我们就可以${name}xxxx（要拼接的内容）</li>
</ul>
<h2 id="特殊的命令"><a href="#特殊的命令" class="headerlink" title="特殊的命令"></a>特殊的命令</h2><ul>
<li>如果要在里面定义参数 ， 则$1代表脚本的第一个需要输入的参数 ， $2 ,$3…要第二个第三个。。。</li>
<li>而$0 :获取当前的文件名字</li>
<li>$? : 返回执行之后的状态 ： 0是正常执行 ， 非0是错误</li>
<li>$*代表所有传入的内容</li>
<li>$#代表传入的数量</li>
<li>$$代表是当前进程的进程号</li>
<li>$@把传入的参数作为一个字符串输出，但是里面仍然认为由多个字符串而$*则是认为他只有一个字符串</li>
<li>转义字符 ： 和c一样</li>
<li>定义数组 ： arr&#x3D;（zs lis ww zl wrm）</li>
<li>获取数组里的元素 ： ${arr[*]} :这个是获取所有的 。 </li>
<li>但是这个里面不能由；</li>
<li>如果要查看单个和java里一样，把【】中的换成从0开始的数字</li>
<li>代表查看数组里的元素个数 ： <code>$&#123;井号arr[*]&#125;</code></li>
<li>两种括号的形式</li>
<li>由子shell执行 ，不会影响到这个shell <code>（）</code></li>
<li>由当前shell执行 ，会影响到这个shell <code>&#123;&#125;</code></li>
<li>权限判断：</li>
<li><code>-r</code> ：读权限</li>
<li><code>-w</code> ：写权限</li>
<li><code>-x</code> ：执行权限</li>
<li><code>-e</code> ：文件是不是存在</li>
<li><code>-d</code> ：是不是目录</li>
<li><code>-f</code> ：是不是文件</li>
<li><code>-c</code> ：是不是字符设备</li>
<li><code>-b</code> ：是不是块设备</li>
<li><code>-s</code> ：文件是不是非空</li>
<li><code>-l</code> ：符号连接</li>
</ul>
<h2 id="对变量以及字符串的操作"><a href="#对变量以及字符串的操作" class="headerlink" title="对变量以及字符串的操作"></a>对变量以及字符串的操作</h2><ul>
<li><code>$&#123;num:-val&#125;</code> : 若num存在则是num , 要不然就是val</li>
<li><code>$&#123;num!=val&#125;</code> : 如果num存在，则是num 要不然就是val 且将num赋值为val</li>
</ul>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul>
<li><code>if else</code></li>
<li><code>if condition(条件判断);then</code></li>
<li><code>command</code></li>
<li><code>else</code></li>
<li><code>command</code></li>
<li><code>fi</code> </li>
<li><code>condition</code> ： [] 比如：[ 1 &#x3D;&#x3D; 2 ] 变量以及判断符号前后有空格</li>
<li>值判断 ：</li>
<li>常规的都可以用</li>
<li><code>=</code> 等于</li>
<li><code>==</code>等于</li>
<li><code>-ne</code> 数值不等</li>
<li><code>-eq</code> 数值相等</li>
<li><code>-gt</code> 大于</li>
<li><code>-ge</code> 大于等于</li>
<li><code>-le</code> 小于等于</li>
<li><code>-lt</code> 小于</li>
<li><code>if con; then</code></li>
<li><code>command</code></li>
<li><code>elif con; then</code></li>
<li><code>com</code></li>
<li><code>....</code></li>
<li>后面<code>elif</code>可以无限加</li>
<li>同时也有<code>break</code>和<code>countinue</code></li>
</ul>
<h2 id="与或非"><a href="#与或非" class="headerlink" title="与或非"></a>与或非</h2><ul>
<li>与 <code>||</code></li>
<li>或 <code>&amp;&amp;</code></li>
</ul>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul>
<li><code>for var in con1 con2 con3</code></li>
<li><code>do</code></li>
<li><code>程序段</code></li>
<li><code>done</code></li>
<li><code>for((i=0;i&lt;10;i++))</code></li>
<li><code>do</code></li>
<li><code>程序段</code></li>
<li><code>done</code></li>
</ul>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><ul>
<li><code>while【con】</code></li>
<li><code>do</code></li>
<li><code>程序段</code></li>
<li><code>done</code></li>
</ul>
<h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><ul>
<li><code>until【con】</code></li>
<li><code>do</code></li>
<li><code>程序段</code></li>
<li><code>done</code></li>
<li>这个和<code>while</code>相反 ，条件为错，一直执行</li>
<li>上述的程序段中可以用let i++等</li>
<li>这个<code>con</code>可以应用（（））或者中括号都行</li>
</ul>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><ul>
<li><code>case $变量名 in</code></li>
<li><code>&quot;值 1&quot;）</code></li>
<li><code>如果变量的值等于1 ，则执行程序1</code></li>
<li><code>；；</code></li>
<li><code>&quot;值 2&quot;）</code></li>
<li><code>如果变量的值等于2 ，则执行程序2</code></li>
<li><code>；；</code></li>
<li><code>。。。还可以衔接很多的</code></li>
<li><code>*)</code></li>
</ul>
<h2 id="对字符串的操作"><a href="#对字符串的操作" class="headerlink" title="对字符串的操作"></a>对字符串的操作</h2><ul>
<li>字符串的长度 ： <code>$&#123;井号xxx&#125;</code></li>
<li>从下标n处开始进行提取 ： <code>$&#123;xxx:n&#125;</code></li>
<li>从下表为n处提取m个 ： <code>$&#123;xxx:n:m&#125;</code></li>
<li>用new替换xxx中出现的第一个mm ： <code>$&#123;xxx/mm/new&#125;</code></li>
<li>用new替换xxx中出现的所有mm ： <code>$&#123;xxx//mm/new&#125;</code></li>
<li>IFS变量进行字符串分割</li>
<li></li>
</ul>
<h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><ul>
<li>函数名（）{}</li>
<li>fnction 函数名（）{}</li>
<li>函数的返回值可以应用return来进行结束</li>
</ul>
<h1 id="shell分析工具"><a href="#shell分析工具" class="headerlink" title="shell分析工具"></a>shell分析工具</h1><ul>
<li>cut ：剪</li>
<li>cut[选项参数] filename</li>
<li><code>-f</code> 列号，第几列</li>
<li><code>-f 2 </code>：代表第二列</li>
<li><code>-f 2-</code> ：代表第二列之后的所有</li>
<li><code>-d</code> 分隔符，按照指定的分隔符分割列，默认是\t</li>
<li><code>-c</code> 按照字符切割 后面夹n表示第几列 如-c1</li>
<li><code>awk</code> : 文本分析工具 或者叫 gawk</li>
<li><code>awk[选项参数] &#39;/pattern1&#123;action1&#125; /pattern2/&#123;action2&#125;...&#39; (filename)</code></li>
<li>选项参数</li>
<li><code>-F</code> ：指定输入文件分隔符</li>
<li><code>-v</code> ：赋值一个用户自己定义的变量</li>
<li>打印第一和第二列 ： <code>awk &#39;&#123;print $1，$2&#125;&#39; （filename）</code></li>
<li>awk一般和cat联用 ： <code>cat xxx | awk &#39;&#123;print $1，$2&#125;&#39;</code></li>
<li>也可以这样 ： <code>cat xxx | awk &#39;&#123;print $1&quot;,&quot;$2&#125;&#39;</code> : 这样代表会让其中两列用，分割的形式表示出来</li>
<li>还可以加上 ：<code>cat xxx | awk &#39;BEGINH&#123;print xxx&#125;&#123;print $1&quot;,&quot;$2&#125;END&#123;print mmm&#125;&#39;</code> ：就会在开始及结束的时候分别加上xxx和mmm</li>
<li><code>-f</code> 则是执行脚本</li>
<li>还可以 <code>cat xxx | awk -v i=1 -F &quot;:&quot; &#39;&#123;print $3 +i&#125;&#39;</code> :代表xxx文件的由：分割的第3列都加一在输出</li>
<li>内置变量</li>
<li><code>FILENAME</code> ：文件名</li>
<li><code>NR</code> ： 已读的记录数（行号）</li>
<li><code>NF</code> ： 浏览记录的域的个数（切割后的列的个数）</li>
<li>获取第一行 <code>cat xxx | awk &#39;NR==1&#123;print&#125;&#39;</code></li>
<li>里面的条件&#x3D;&#x3D;可以换成  &gt; &lt; &gt;&#x3D; &lt;&#x3D;</li>
<li></li>
<li><code>sed</code> : 文本替换(回去自己查)</li>
<li>把文本中 d 替换成 m ,每行第一次遇见a才会替换</li>
<li><code>sed -i &#39;s/d/m/&#39;</code> xxx文件名</li>
<li>全文替换</li>
<li><code>sed -i &#39;s/d/m/g&#39;</code> xxx文件名</li>
<li>把值路径替换成&#x2F;root</li>
<li><code>sed -i &#39;s//fata/spark//root</code> xxx文件’</li>
<li>不过会爆错</li>
<li>不过加上\就对了</li>
<li><code>sed -i &#39;s\/fata\/spark\/root&#39;</code> xxx文件’</li>
<li><code>sed -i &#39;s#/root#/data/spark#g&#39;</code> xxx文件</li>
</ul>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><ul>
<li>模糊式的匹配搜索</li>
<li>pattern</li>
<li>最简单的正则 ： 直接给一个关键字 就是grep的时候</li>
<li>特殊字符</li>
<li>^作为一行的开头 ：比如^a 代表以a开头</li>
<li>$作为一行的结束 ：比如n$ 代表以n结尾</li>
<li>正则可以多种一起应用</li>
<li>比如 ^$代表空行</li>
<li>grep -n显示行号</li>
<li>通配符 ： . 代表匹配一个任意的字符</li>
<li>比如 ： r..t :代表r和t中间有两个字符的</li>
<li>特殊字符 ： * ：代表一个字符出现任意次数</li>
<li>比如 o* 代表o出现任意次数</li>
<li>.*则表示任意一个字符出现任意次数 ，甚至可以匹配空字符串</li>
<li>于是可以和上面的联用 ： ^a.*b$</li>
<li>代表以a开头 b结尾 中间任意字符的</li>
<li>字符区间：</li>
<li>[]表示匹配其中范围内的字符</li>
<li>比如[0-9]* ：任意长度的数字</li>
<li>[0,7] : 0或7</li>
<li>还可以这样写 ： [a-c , b-f]</li>
<li>[ab]* ：代表任意以ab组成的 比如 ：aab<br> abb 等</li>
<li>转义字符 \</li>
<li>当我们要搜索$等关键字的时候</li>
<li>要’反斜杠$’ :表示转义 ，才可以用做搜索</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li>匹配手机号</li>
<li><code>^1[345678][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$</code></li>
<li><code>^1[345678][0-9]&#123;9&#125;$</code></li>
<li>但是下面的花括号是扩展</li>
<li>要用<code>grep -E ^1[345678][0-9]&#123;9&#125;$ </code>才可以</li>
<li>但是上面的最开始的是都可以支持的</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>mapreduce</title>
    <url>/2022/11/21/11-21/</url>
    <content><![CDATA[<h1 id="续讲Hadoop"><a href="#续讲Hadoop" class="headerlink" title="续讲Hadoop"></a>续讲Hadoop</h1><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>关于mapreduce的操作模式就是模板模式，加上自定义的变量</p>
<h3 id="模板模式-1"><a href="#模板模式-1" class="headerlink" title="模板模式"></a>模板模式</h3><p>关于模板模式，就是三步走</p>
<p>开始阶段 ： map阶段</p>
<p>处理阶段 ： reduce阶段</p>
<p>结束阶段 ： 关闭流并输出</p>
<h3 id="自定义的变量"><a href="#自定义的变量" class="headerlink" title="自定义的变量"></a>自定义的变量</h3><p>BooleanWriteable : 布尔类型</p>
<p>ByteWriteable : Byte类型</p>
<p>DoubleWriteable : double类型</p>
<p>FloatWriteable ：float类型</p>
<p>intWriteable ： int类型</p>
<p>…（等等）</p>
<h3 id="mapreduce的核心方法"><a href="#mapreduce的核心方法" class="headerlink" title="mapreduce的核心方法"></a>mapreduce的核心方法</h3><ul>
<li>input : InputFormat &#x3D;&gt; 如何加载数据</li>
<li>查看源码发现有DBInputFormat 和 FileInputFormat，代表我们可以从db（数据库中），或者文件中加载数据（上述两个是抽象类，我们实例化的时候其实是实例化其子类）</li>
<li>简单来说就是读取数据的方法</li>
<li>默认实例化的时候是实例化 TextInputFormat</li>
<li>关于TextInputFormat ： 其有两个参数<ul>
<li>key 和 value<ul>
<li>key 是 读取文件的位置</li>
<li>value 是 一行一行的内容<ul>
<li>在value中有个属性 判断文件可不可以被切分 ： isSpiltable<ul>
<li>map task 数据 是由 input 的切片数量决定的 ， 当不可被切片的时候对应的数量就是1，对应一个map task</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>creatRecordReader</p>
<h2 id="一个文件加载的时候会被切分成几个切片"><a href="#一个文件加载的时候会被切分成几个切片" class="headerlink" title="一个文件加载的时候会被切分成几个切片"></a>一个文件加载的时候会被切分成几个切片</h2><p>前提 ： 文件可以被切分</p>
<p>当一个文件 在hdfs上的时候是按我们的大小进行切分的 以128m为基础单位</p>
<p>而我们的map的切片是按照blocksize进行切分的简单来说就是以blocksize的大小进行切分</p>
<p>总结  ：</p>
<ul>
<li>文件大小小于128m<ul>
<li>那么切分成1片</li>
</ul>
</li>
<li>如果文件大于128m<ul>
<li>filesize&#x2F;splitesize &#x3D; num 切片数</li>
<li>filesize剩余的部分 ： 和splitesize的10%比较<ul>
<li>如果大，则开启一个切片文件</li>
<li>如果小，则是和上面最后一个合并到一起</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>不能被切分的文件： 某些被压缩文件</p>
<ul>
<li>关于这个切片大小的标准 ：<ul>
<li>在hdfs上是128m</li>
<li>但是在idea上是32m（在源码里能看）</li>
</ul>
</li>
</ul>
<h2 id="redurce-task-个数是由上面决定"><a href="#redurce-task-个数是由上面决定" class="headerlink" title="redurce task 个数是由上面决定?"></a>redurce task 个数是由上面决定?</h2><p>默认是 1</p>
<p>如果要更改要手动更改</p>
<p>setNumReduceTasks(数量)</p>
<p>如果 reduce阶段数量变多</p>
<p>则会把相同的文件拉到一起，就是按照一个规则进行的分区</p>
<p>默认是走的hashcode ： 这个按照规则来分的就是分区</p>
<p>一般来说 ： 分区的结果是 suffler 的输出结果是 reduce的输入</p>
<h3 id="简单需求"><a href="#简单需求" class="headerlink" title="简单需求"></a>简单需求</h3><p>基于phone的存储数据 ，进行分文件存储</p>
<p>比如</p>
<p>13开头的存储在一个上</p>
<p>15开头的在一个文件上</p>
<p>这就要自定义分区</p>
<p>通过继承Partitioner类实现方法然后导入方法</p>
<p>实现getPartition方法进行分区 ： 以下是一个简单的分区函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Partitioner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myPartionit</span> <span class="keyword">extends</span> <span class="title class_">Partitioner</span>&lt;Text , IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPartition</span><span class="params">(Text text, IntWritable intWritable, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text.toString().equals(<span class="string">&quot;ANALYST&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (text.toString().equals(<span class="string">&quot;CLERK&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (text.toString().equals(<span class="string">&quot;MANAGER&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (text.toString().equals(<span class="string">&quot;PRESIDENT&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (text.toString().equals(<span class="string">&quot;SALESMAN&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们要在我们的主程序中调用这个类 ， test类：就是我们的主类，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxwang</span></span><br><span class="line"><span class="comment"> * 11 18 14:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * driver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现问题最少两个参数&quot;</span>);</span><br><span class="line">System.exit(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">        String input=args[<span class="number">0</span>];</span><br><span class="line">String output=args[<span class="number">1</span>];</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"><span class="comment">//0.todo... 删除目标路径</span></span><br><span class="line">FileUtils.deletePath(conf,output);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.设置 作业名称</span></span><br><span class="line"><span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(conf, <span class="string">&quot;WCAPP&quot;</span>);</span><br><span class="line"><span class="comment">//2.设置map reduce 执行代码的主类</span></span><br><span class="line">job.setJarByClass(test.class);</span><br><span class="line">job.setMapperClass(MyMapper.class);</span><br><span class="line">job.setReducerClass(MyReducer.class);</span><br><span class="line"><span class="comment">//3.指定 oupput kv类型</span></span><br><span class="line">job.setOutputKeyClass(Text.class);</span><br><span class="line">job.setOutputValueClass(IntWritable.class);</span><br><span class="line">job.setNumReduceTasks(<span class="number">6</span>);</span><br><span class="line">job.setPartitionerClass(myPartionit.class);</span><br><span class="line"><span class="comment">//4. 设置数据源路径 数据输出路径</span></span><br><span class="line">FileInputFormat.addInputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(input));</span><br><span class="line">FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(output));</span><br><span class="line"><span class="comment">//5. 提交mr yarn</span></span><br><span class="line">System.exit(job.waitForCompletion(<span class="literal">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyMapper</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;Object, Text, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.按照分隔符 进行拆分 每个单词 ，每个单词赋值为1</span></span><br><span class="line"><span class="comment">             * (word ,1)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">String[] words = value.toString().split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                String[] split = word.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">context.write(<span class="keyword">new</span> <span class="title class_">Text</span>(split[<span class="number">2</span>]) ,<span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reducer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyReducer</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  (word ,1)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  (word,&lt;1,1,1,1&gt;)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  1.聚合value</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  2.写出去</span></span><br><span class="line"><span class="comment">*  (word ,3)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">                sum +=Integer.parseInt(value.toString());</span><br><span class="line">&#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> <span class="title class_">IntWritable</span>(sum));</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sql-vs-mr-mapreduce"><a href="#sql-vs-mr-mapreduce" class="headerlink" title="sql vs mr(mapreduce)"></a>sql vs mr(mapreduce)</h2><ul>
<li>sql  :<ul>
<li>group by</li>
<li>distinct</li>
<li>join</li>
<li>order by</li>
<li>union<ul>
<li><p>group by 用mr实现</p>
</li>
<li><p>就是再map阶段进行处理reduce阶段进行合并</p>
</li>
<li><p>distinct</p>
</li>
<li></li>
<li><p>去重 ： sql ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>(ename) <span class="keyword">from</span> emp;</span><br><span class="line">#或者可以通过分组进行去重</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">group</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure></li>
<li><p>通过上述我们可知group by 也可以进行去重 ，所以后面我们能用group by 就要用group by</p>
</li>
<li><p>因为distinct只有一个task进行处理</p>
</li>
<li><p>而group by 则是多个task 进行处理 ， 所以效率会比较高</p>
</li>
<li><p>接下来是在mr里实现</p>
</li>
<li><p>order by</p>
</li>
<li><p>mr :</p>
</li>
<li><p>全局排序 ： reduce task 是 1</p>
</li>
<li><p>分区排序 ： reduce task 是 多个</p>
</li>
<li><p>mr : 实现</p>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>如果你的reduce task 大于分区数 ： 会有空白文件</p>
<p>如果 reduce task 小于分区数 且大于1 ： 则会报错</p>
<p>如果 reduce task 且分区数 等于 1 ： 则会把东西整合到一个文件</p>
<h2 id="关于mapreduce在linux上运行的学习，官方提供了源码库"><a href="#关于mapreduce在linux上运行的学习，官方提供了源码库" class="headerlink" title="关于mapreduce在linux上运行的学习，官方提供了源码库"></a>关于mapreduce在linux上运行的学习，官方提供了源码库</h2><p>地址在github上：</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>mapreduce</title>
    <url>/2022/11/24/11-24/</url>
    <content><![CDATA[<h1 id="typeScript"><a href="#typeScript" class="headerlink" title="typeScript"></a>typeScript</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>ts：typescript ： 简单来说就是js的超集，可以向下兼容js，所以我们使用ts不用对js进行更改，ts会自动转换成js</p>
<p>因为现在的浏览器不支持ts的语法 ： ts的编译环境是node.js</p>
<p>安装运行 ： npm install -g typescript</p>
<p>安装之后用tsv -v 查看</p>
<p>与逆行的时候下载一个json</p>
<p>命令行 : tsc -init</p>
<p>然后运行命令 ： ts-node .&#x2F;文件名</p>
<p>下面是关于ts的简单介绍</p>
<p>首先ts是静态类型，js是动态类型</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>静态类型是编译阶段就会发现问题，而动态类型则是直到运行阶段才会问问题的</p>
<p>所以相比较而言，静态类型，比动态类型更加可控</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ts的类型 ：</p>
<p>包括 : 布尔 ， 数值，字符串， null , symbol , BigInt,undefined</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone :<span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span> = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">number</span> = <span class="title class_">Infinity</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">my</span>: <span class="built_in">string</span> = <span class="string">&#x27;yon&#x27;</span></span><br><span class="line"><span class="keyword">let</span> o : <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">nme</span>: <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">alertName</span>(<span class="params"></span>) : <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;my first name&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="built_in">any</span>[] = [<span class="string">&quot;hello&quot;</span> , <span class="number">1</span> , <span class="literal">true</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ids</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">names</span>: <span class="title class_">String</span>[] = [<span class="string">&quot;xxx&quot;</span> , <span class="string">&quot;yyy&quot;</span> , <span class="string">&quot;zzzz&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">book</span>: <span class="title class_">Object</span>[] = [&#123;<span class="attr">name1</span>:<span class="string">&#x27;tom&#x27;</span> , <span class="attr">animal</span>:<span class="string">&#x27;cont&#x27;</span>&#125;,&#123;<span class="attr">name1</span>:<span class="string">&#x27;gggg&#x27;</span>,<span class="attr">animal</span>:<span class="string">&#x27;hhhh&#x27;</span>&#125;];</span><br><span class="line">ids.<span class="title function_">push</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>:(<span class="built_in">string</span>|<span class="built_in">number</span>|<span class="built_in">boolean</span>)[]=[<span class="string">&#x27;aslkdjla&#x27;</span>,<span class="number">1</span>,<span class="literal">true</span>]; <span class="comment">// 这个是三个值</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person1</span>:[<span class="built_in">string</span>,<span class="built_in">number</span>,<span class="built_in">boolean</span>]=[<span class="string">&#x27;sdfjkl&#x27;</span>,<span class="number">1</span>,<span class="literal">true</span>]; <span class="comment">// 这个是一个值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(isDone)<span class="keyword">let</span> isDone :<span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span> = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">number</span> = <span class="title class_">Infinity</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">my</span>: <span class="built_in">string</span> = <span class="string">&#x27;yon&#x27;</span></span><br><span class="line"><span class="keyword">let</span> o : <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">nme</span>: <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">alertName</span>(<span class="params"></span>) : <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;my first name&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(isDone)</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>我们定义接口的方式如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> a&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">isP</span>:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上述数组的作用一样，不过这样定义可以增强复用性，随便让一个东西继承一下他，就可以了</p>
<p>比如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> a&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">isP</span>:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>:a=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;kjds&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">11</span>,</span><br><span class="line">    <span class="attr">isP</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数合上述的接口很像，他是在接口创建了几个方法，如下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> s&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">eat</span>(<span class="attr">name</span>:<span class="built_in">string</span>):<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">j</span>:s=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;lkasdj&#x27;</span>,</span><br><span class="line">    <span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;eat$&#123;name&#125;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span>,c?:<span class="built_in">number</span>|<span class="built_in">string</span></span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问号代表从后面的类型里选数据，这里是number和string</p>
<p>上面的是lambad多</p>
<p>把ts转换成js的语法是any</p>
<h2 id="Dom和类型转换"><a href="#Dom和类型转换" class="headerlink" title="Dom和类型转换"></a>Dom和类型转换</h2><p>ts无法像js一样进行访问dom这个就意味着ts无法确定这些dom是不是存在，所以使用非空断言，我们可用明确的告诉他，这个表达式是null&#x2F;undefined</p>
<p>非空断言 X! 代表把x中的null和undefined给去除了</p>
<p>例如 ：下面是关于ts和获取dom的</p>
<p><code>const link = document.querySelector(&#39;a&#39;);</code></p>
<p>当我们要通过class来选择一个dom元素的时候，可以进行一层转化</p>
<p>例如 ： <code>const from = document.getElementById(&#39;form&#39;) as HTMLAnchorElement</code></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>和java中的类异常类似</p>
<p>比如 ： </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Preson</span> &#123; </span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">iscool</span>:<span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">n:<span class="built_in">string</span>,c:<span class="built_in">boolean</span>,a:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=n</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">iscool</span>=c</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span>=a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayhai</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi,wosshi$&#123;this.name&#125;,jinnnan$&#123;this.age&#125;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的修饰符</p>
<p>readonly,privatee,protected,public</p>
<p>简单的介绍就到这里为止，具体以后再慢慢补充</p>
]]></content>
      <categories>
        <category>杂货技术栈</category>
      </categories>
  </entry>
  <entry>
    <title>yarn</title>
    <url>/2022/11/28/11-28/</url>
    <content><![CDATA[<h1 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>主从架构 ： resourcemanager(资源的分配) : nodemanager(资源的供给与隔离)</p>
<h3 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h3><p>通过rm把nm的资源分配给我们的 task上</p>
<h3 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h3><p>nm按照要求给task提供资源，保证提供的资源具有独占性</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>nm指挥分配的资源</p>
<p>一个task对应一个container ： cpu&#x2F;mem（cpu和内存）</p>
<p>每个container之间是相互隔离的</p>
<h2 id="yarn的架构设计"><a href="#yarn的架构设计" class="headerlink" title="yarn的架构设计"></a>yarn的架构设计</h2><p>作业提交的流程：<br>client &#x3D;&gt; 给rm 的apps 发送请求 去运行 jar （app master）</p>
<p>apps 分配一个container 去运行 app master</p>
<p>app master 会向apps manager 去注册我的作业</p>
<p>app master 向resource scheduler 申请资源去运行 我的代码</p>
<p>nodemanager 会开启资源 container 去运行map task 以及reduce task</p>
<p>tsak 会向 app master 汇报代码与运行情况 </p>
<p>当代码运行完成 app master 会给apps 发送请求 ，通知我的作业完成了</p>
<p>apps manager 收到请求之后会通知你的客户端 ，告诉已经运行完成</p>
<p>输入阶段 ： map tsak 的个数 &#x3D;》container 的申请个数 redurce task 同理</p>
<h2 id="面试会问"><a href="#面试会问" class="headerlink" title="面试会问"></a>面试会问</h2><p>yarn的架构设计 &#x3D;&#x3D;mr作业提交流程</p>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>FIFO ：</p>
<ul>
<li>先进先出</li>
<li>单队列</li>
</ul>
<p>Capacity ：容量调度器</p>
<ul>
<li>多队列</li>
<li>先进先出（针对一个队列）</li>
<li>每个队列之间互不影响</li>
<li>每个队列之间是事先定好的</li>
</ul>
<p>Fair：公平调度器</p>
<ul>
<li>多队列</li>
<li>每个队列之间的每个job是有影响的 不是先进先出</li>
<li>哪一个job的优先级高就执行哪一个</li>
<li>如果相同优先级，则是顺序</li>
</ul>
<p>主流的中小企业：Capacity</p>
<p>大公司会用：fair</p>
<h3 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h3><p>容量调度器</p>
<p>通过调度器进行其作业调度</p>
<h2 id="yarn的web界面的简介"><a href="#yarn的web界面的简介" class="headerlink" title="yarn的web界面的简介"></a>yarn的web界面的简介</h2><p>左侧侧边栏 ： 有几个选项卡 ： 分别是 </p>
<h2 id="yarn资源的调优"><a href="#yarn资源的调优" class="headerlink" title="yarn资源的调优"></a>yarn资源的调优</h2><p>container? </p>
<p>一定比例的cpu和mem</p>
<p>刀片服务器的配置 ： 128G 16 core :假设一个机器的配置</p>
<p>刀片服务器 装完系统 消耗内存 1G </p>
<p>系统预留 ： 预留 20%左右 包含装完成系统 消耗的1G</p>
<p>原因 ：给未来部署组件预留空间，防止全部使用 ： 会导致系统夯住 就是卡住 ，oom机制【linux系统】：系统会自己杀死进程当内存不足的时候</p>
<p>预留空间 ： 128 * 0.2 &#x3D; 26G</p>
<p>其余空间用于大数据 102G</p>
<p>hadoop ： </p>
<ul>
<li>datanode  进程内存 ： 默认 1G &#x3D;》 生产上 2G</li>
<li>nodemanager 进程内存 ： ，默认 1G &#x3D;》 生产上 4G</li>
</ul>
<p>接下来还有96G全部给我们的yarn资源 ： 96G</p>
<p>container的资源分配 ： </p>
<p>内存</p>
<p>cpu</p>
<p>相比：cpu更重要一些</p>
<p>container的内存划分 ：默认是86G</p>
<p>其最小是 1G（默认）</p>
<p>最大是 8G（默认） 但是可以设置</p>
<p>注意 container的内存会自动增加 默认以1G递增</p>
<p>container cpu ： 是虚拟核 &#x3D;》 考虑初衷是不同节点的cpu性能不同</p>
<p>比如 ： 一个cpu是另外一个cpu的2倍</p>
<p>第一机器 ： pcore ：vcore &#x3D; 1：2 相当于1个物理核当成两个虚拟核用</p>
<p>给container的核数 ： 默认是8core</p>
<p>总数 ： </p>
<p>最小:1c  (默认)</p>
<p>最大:4c（默认）</p>
<p>实际开发角度 ：</p>
<p>mem</p>
<p>cpu ： cloudera的公司推荐一个container的core最好不要超过5</p>
<p>配置core  ：在yarn-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;4096&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1024&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;2048&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">cpu： </span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.resource.pcores-vcores-multiplier&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;4&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.scheduler.minimum-allocation-vcores&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.scheduler.maximum-allocation-vcores&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="mapreduce"><a href="#mapreduce" class="headerlink" title="mapreduce"></a>mapreduce</h2><p>map task :mem  : 默认是1024m ，一个map task 申请的资源是1024m ， 但是如果实际使用的资源的内存量超过这个值，你的task会强制被杀死 ，reduce task 也一样</p>
<p>map task :vcore ： 默认是1</p>
<p>reduce task :mem : 默认是1024m</p>
<p>reduce task :vcore : 默认是1</p>
<p>mr作业是进程级别 &#x3D;》 jvm</p>
<p>map task</p>
<p>reduce task </p>
<p>jvm参数调优 ： </p>
<p>存储 hdfs</p>
<p>存储文件</p>
<p>压缩</p>
<ul>
<li>为什么使用压缩？</li>
<li>节省空间</li>
<li>节省时间<ul>
<li>网络io核磁盘io会减少</li>
<li>指的是mapreduce数据计算过程中</li>
<li>经过网络传输的数据会变少，</li>
<li>同样到磁盘上的时候，数据量少也会减少磁盘的io</li>
</ul>
</li>
<li>使用场景<ul>
<li>采用压缩 ， 对机器的cpu要求比较高</li>
<li>存储数据的空间不够了，才会用压缩</li>
</ul>
</li>
<li>两面性</li>
<li>采用压缩的确会让空间和时间减少</li>
<li>cpu消耗 cpu利用率高 &#x3D;》会导致处理的时间变长一点</li>
<li>如何使用压缩？</li>
</ul>
<p>常见的压缩格式</p>
<ul>
<li>gzip</li>
<li>bzip2</li>
<li>Lzo</li>
<li>Snappy</li>
<li>LZ4</li>
</ul>
<p>常见的压缩注意点：</p>
<p>压缩比 Bzip2 30%  GZIP    snappy、lzo 50%</p>
<p>解压速度 ： snappy、lzo GZIP   Bzip2</p>
<p>压缩文件可不可以一被切分 </p>
<p>假设一个 5G文件 不能被切分 split 意味着 只能使用一个map task去处理</p>
<p>map task  5G</p>
<p>假设一个 5G文件 能被切片  splits 10map task 去并行处理</p>
<p>5*1024 &#x2F;10 &#x3D; 一个map task 处理的数据</p>
<p>能否被切分 决定了 你的 一个map task处理的数据量有多少</p>
<p>压缩后的文件是否支持分割？<br>            gzip  不可分割<br>            bzip2  可分割<br>            lzo   带索引的可以分割 (默认是不支持分割的)<br>            snappy 不可分割的</p>
<p>mapreduce 每个阶段该如何采用这些算法？</p>
<p>input &#x3D;》 maps &#x3D;》 reduce &#x3D;》 output</p>
<p>input：<br>    1.Bzip2 ：支持分割 多个map task 进行出</p>
<p>map out：</p>
<ul>
<li>snappy 、lzo</li>
<li>shuffle 过程 要选择一个解压 速度快的压缩格式</li>
</ul>
<p>reduce out ：</p>
<ul>
<li>1.高的压缩比 + 支持分片  &#x3D;》 节省空间</li>
<li>2.bzip2  、lzo带索引的</li>
</ul>
<p>reduce out 数据 作为下一个<br>map 的输入咋办？<br>建议使用bzip2【如果采用压缩的话】</p>
<p>进行压缩配置的两种方式 ： </p>
<p>job &#x3D;》 code 针对少数job生产生效</p>
<p>集群所有的job 在配置文件里配置</p>
<p>对mapreduce 进行配置 </p>
<ul>
<li><p>配置压缩的codec</p>
</li>
<li><p>map reduce 输出配置</p>
<ul>
<li>先打开压缩的开关</li>
<li>配置codec即可</li>
</ul>
</li>
<li><p>hadoop是不是支持哪些压缩 ，通过命令 ：或者配置文件</p>
</li>
<li><p>core-site.xm</p>
<ul>
<li>配置支持的压缩有什么</li>
<li>原生的hadoop默认不支持lzo的算法，因为lzo要把整个hadooop重新编译一遍才可以重新实行</li>
<li>&#96;&#96;&#96;<property>
        <name>io.compression.codecs</name>
        <value>org.apache.hadoop.io.compress.BZip2Codec,
        org.apache.hadoop.io.compress.SnappyCodec,
        org.apache.hadoop.io.compress.GzipCodec,
        org.apache.hadoop.io.compress.DefaultCodec
        </value>
</property>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mapred-site.xml:</span><br><span class="line"></span><br><span class="line">* 1.先打开压缩的开关</span><br><span class="line">* 2.map reduce 输出 压缩算法</span><br><span class="line"></span><br><span class="line">reduce： 开关</span><br><span class="line"></span><br><span class="line">* mapreduce.output.fileoutputformat.compress</span><br><span class="line">* ```</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">          &lt;name&gt;mapreduce.output.fileoutputformat.compress&lt;/name&gt;</span><br><span class="line">          &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>&#96;&#96;&#96;</p>
<property>
        <name>mapreduce.output.fileoutputformat.compress.codec</name>
        <value>org.apache.hadoop.io.compress.BZip2Codec</value>
</property>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">各个datanode数据节点的平衡</span><br><span class="line"></span><br><span class="line">* DN1 存储空间 90%</span><br><span class="line">* DN2 存储空间 60%</span><br><span class="line">* DN3 存储空间 80%</span><br><span class="line"></span><br><span class="line">如何做呢？</span><br><span class="line"></span><br><span class="line">* sbin/start-balancer.sh</span><br><span class="line"></span><br><span class="line">parameters = Balancer.BalancerParameters</span><br><span class="line"></span><br><span class="line">[BalancingPolicy.Node, threshold = 10.0, max idle iteration = 5</span><br><span class="line"></span><br><span class="line">数据平衡的默认阈值：threshold = 10.0</span><br><span class="line"></span><br><span class="line">每个节点的磁盘使用率 - 平均的磁盘使用率 &lt;10%</span><br><span class="line"></span><br><span class="line">DN1 存储空间 90%  -76% = 14% 说明这个节点数据多 往别的节点迁移数据 出</span><br><span class="line">DN2 存储空间 60%  -76% = -12% 说明这个节点数据少 别的节点迁移数据 进</span><br><span class="line">DN3 存储空间 80%  -76% = 4% 	说明这个节点数据多 往别的节点迁移数据</span><br><span class="line"></span><br><span class="line">avg=90 + 80 +60 /3 = 76%</span><br><span class="line"></span><br><span class="line">生产上 从现在开始 start-balancer.sh -threshold 10  每天要定时做的</span><br><span class="line"></span><br><span class="line">放到业务低谷期去做 数据平衡操作</span><br><span class="line"></span><br><span class="line">注意： 不要在业务高峰期做</span><br><span class="line"></span><br><span class="line">1.数据平衡 数据传输  带宽有关</span><br><span class="line"></span><br><span class="line">调优参数 ：平衡的网络带宽  w</span><br><span class="line"></span><br><span class="line">dfs.datanode.balance.bandwidthPerSec 100m 【2.x 默认是10m】</span><br><span class="line"></span><br><span class="line">每个节点数据几十T  需要数据平衡的数据 几十T  可以申请维护窗口时间 ：</span><br><span class="line"></span><br><span class="line">dfs.datanode.balance.bandwidthPerSec 临时调大 200M</span><br><span class="line"></span><br><span class="line">单个DN节点 多块磁盘的数据平衡</span><br><span class="line"></span><br><span class="line">投产前规划：</span><br><span class="line">		DN 机器   10块 2T 【不做raid】  =》 20T   副本的</span><br><span class="line"></span><br><span class="line">1.dn 配置多个磁盘</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<property>
      <name>dfs.datanode.data.dir</name>
      <value>/data01,/data02,/data03</value>
</property></li>
</ul>
<pre><code>
2.为什么要使用多块物理磁盘？

1.存储
2.因为多个磁盘的io也是叠加的
每块磁盘 磁盘io 每秒 100m
三块磁盘 1s 能 300m文件内容
一块磁盘 1s 100m

3.可以让服务一直运行，加入一个磁盘挂了，服务不会减少

做多个磁盘数据均衡
    dfs.disk.balancer.enabled  true 【3.x有这个功能 cdh 2.x 也有】 apache 2.x 没有这个功能

得通过命令去解决磁盘数据均衡？

hdfs diskbalancer

1.步骤

    hdfs diskbalancer -plan  bigdata32  =&gt; 生成一个  bigdata32.plan.json 文件
        hdfs diskbalancer -execute bigdata32.plan.json =》 执行disk 数据均衡计划文件
        hdfs diskbalancer -query bigdata32

生产上 当你发现 磁盘写入不均衡 可以做一下 【一般 一个月 半个月 做一次即可】
</code></pre>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2022/11/03/11-3/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>关系型数据库</li>
<li>非关系型数据库 ： nosql</li>
<li>存储方式 ， 类似excel</li>
<li>学习 ： 基于官网</li>
<li>版本 ：</li>
<li>5.7 ：主流</li>
<li>5.6 ：也有</li>
<li>8.x ：不是主流 ： java团队</li>
<li>极限是在几tb级别 秒级别 毫秒级别 添加索引还可以更快</li>
</ul>
<h1 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h1><ul>
<li>5.7</li>
<li>安装包种类</li>
<li>rpm ： 不可以完成二次开发，只能用mysql官网的</li>
<li>tar ： 相当于自己魔改的有很多官方没有的功能</li>
<li>rpm ； 要注意el7的 是centos7的</li>
<li>用lazz</li>
<li>上传 ：rz</li>
<li>下载 ：sz</li>
</ul>
<h2 id="mysql的卸载"><a href="#mysql的卸载" class="headerlink" title="mysql的卸载"></a>mysql的卸载</h2><ul>
<li>在windows下 ， mysql 是先在控制面板里卸载，</li>
<li>然后把安装目录卸载掉</li>
<li>在c盘的 ProgramData 里也有文件残留，不过是隐藏文件要自己打开的</li>
<li>然后删除注册表上的</li>
<li>linux</li>
<li>先停掉mysql</li>
<li>然后通过&#96;rpm - qa | grep mysql | xargs -n1 rpm -e –nodeps</li>
<li>然后找到mysql生成的文件</li>
<li>find &#x2F; -name <code>&quot;*mysql*&quot;</code></li>
<li>把该删的文件全部删掉</li>
<li>然后重新安装</li>
</ul>
<h2 id="mysql的安装linux版本"><a href="#mysql的安装linux版本" class="headerlink" title="mysql的安装linux版本"></a>mysql的安装linux版本</h2><ul>
<li>这里安装的是mysql的tar包</li>
<li>首先要解压  :  通过<code>tar -vxf xxxxxxxxxx</code></li>
<li>一般安装mysql的软件的时候要卸载一个东西 ，就是<code>mariadb-libs-5.5.56-2.el7.x86_64</code></li>
<li>通过<code>rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64</code></li>
<li>就卸载了</li>
<li>然后再进行安装</li>
<li>我是创建了一个sh脚本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rpm -ivh mysql-community-common-5.7.28-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.28-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-compat-5.7.28-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-5.7.28-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-5.7.28-1.el7.x86_64.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
然后运行脚本</li>
<li>安装成功了之后，我们初始化mysql</li>
<li>mysqld initialize user&#x3D;mysql</li>
<li>然后启动mysql</li>
<li>systemctl start mysql</li>
<li>然后查看&#x2F;var&#x2F;log&#x2F;mysql.log</li>
<li>就可以查看到我们的初始密码</li>
<li>然后通过</li>
<li>mysql -uroot -pxxx</li>
<li>就可以进行登录</li>
<li>而如果有敏感字符，则要用转义字符的方式比如 / : 代表一个 &#x2F;</li>
<li>然后再进行设置密码</li>
<li>&#96;set password &#x3D; password(“xxxxxxxx”)</li>
<li>再通过flash privileges 进行更改</li>
</ul>
<h1 id="mysql的操作"><a href="#mysql的操作" class="headerlink" title="mysql的操作"></a>mysql的操作</h1><ul>
<li>show databases;</li>
<li>展示数据库</li>
<li>展示的数据库的软件 ： </li>
<li>navcat</li>
<li>sqlyog</li>
<li>dbvear</li>
<li>但是当他是<code>root@localhost</code>的时候，我们只能通过本机访问</li>
<li>但是可以改成 ：<code> root@%: xxxx(密码)</code></li>
<li>就可以通过任意机器访问</li>
<li>通过use xxx更改到xxx数据库</li>
<li>通过show tables 查看表</li>
<li>选择字段 ： select xxx form xxx表 比如 ： <code>select host,user from user;</code></li>
<li>修改表中数据 ： update 比如 ： <code>update mysql.user set host=&quot;%&quot; where user=&quot;root&quot;;</code> </li>
<li>而后通过 ： <code>flash privileges</code> 进行权限修改</li>
<li>然后再自己的wins上通过远程访问的软件访问他</li>
<li>语法 ：</li>
<li>sql语法 ：</li>
<li>ddl ： 数据定义语言</li>
<li>dml ： 数据操作语言</li>
<li>dcl ： 数据控制语言</li>
<li>都不区分大小写</li>
<li>‘null’ ： 字符串字段</li>
<li>‘’ ： 同上</li>
<li>NULL ： 空</li>
<li>上述三个是不一样的意义</li>
<li>字符集 ： 5.7 默认的字符集是拉丁的</li>
<li>我们可以在创建表的时候更改字符集</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE `name` (</span><br><span class="line">  `id` int(3) DEFAULT NULL,</span><br><span class="line">  `age` int(3) DEFAULT NULL,</span><br><span class="line">  `name` varchar(3) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=UTF-8 // 字符集</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>它支持嵌套<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select name ,age_max ,age_avg </span><br><span class="line">from(</span><br><span class="line">select </span><br><span class="line">name,</span><br><span class="line">max(age) as age_max,</span><br><span class="line">min(age) as age_min,</span><br><span class="line">count(age) as age_count,</span><br><span class="line">avg(age) as age_avg</span><br><span class="line">from xxx</span><br><span class="line">group by name) as res </span><br><span class="line">where age_avg &gt;18;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><ul>
<li>过滤条件</li>
<li><code>&gt;</code></li>
<li><code>&lt;</code></li>
<li><code>=</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;=</code></li>
<li><code>&lt;&gt;</code> (也可以是<code>!=</code>)</li>
<li><code>and</code> <code>or</code> <code>in</code> <code>notin</code></li>
<li>根据本意就好 下面的一行代表复合查询</li>
<li><code>select * from xx where name in (&#39;要查询的东西&#39; ， &#39;要查询的东西&#39; ，..);</code></li>
<li><code>not in</code> 同上</li>
<li><code>between and</code> : 代表在。。。之间的</li>
<li></li>
</ul>
<h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><ul>
<li>like rlike regexp ： 模糊匹配</li>
<li><code> select * from where name like &quot;z%&quot;</code> : 代表查找第一个是z的</li>
<li>占位符 ： _ : 占位一个</li>
<li><code> select * from where name like &quot;_s%&quot;</code> :第二个是s的</li>
</ul>
<h3 id="合并表"><a href="#合并表" class="headerlink" title="合并表"></a>合并表</h3><ul>
<li>合并成一个纵向的表</li>
<li><code>union</code> ： 去重</li>
<li><code>union all</code> ： 不去重</li>
</ul>
<h3 id="查询限制"><a href="#查询限制" class="headerlink" title="查询限制"></a>查询限制</h3><ul>
<li>limit</li>
<li><code>select * from xxx limit 2</code></li>
<li>代表只显示两条</li>
<li>但是底层已经查完了</li>
<li>只是只显示两条</li>
</ul>
<h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><ul>
<li>清除有无用的数据</li>
<li>就是null的</li>
<li>工作中一般不会删除数据 ，就是单纯的过滤数据 ，也不让更改数据</li>
<li>一般用 is null 或者 is not null</li>
<li>要把null输出0，并显示</li>
<li>处理空值的函数 </li>
<li>ifnull(xxx,xxx,…)</li>
<li>coalesce(xxx ,xxx ,xxxx…)</li>
<li>他们都是如果里面的值是空那么就会验证下一个数值，如果不为空就输出 ，为空 就继续往下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">name</span><br><span class="line">id</span><br><span class="line">clalesce(age, 0) as age_alias</span><br><span class="line">...</span><br><span class="line">from xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ddl"><a href="#ddl" class="headerlink" title="ddl"></a>ddl</h2><ul>
<li>creat drop alter show（？）</li>
<li></li>
<li>创建数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">creat &#123;DATABASE | SCHEMA&#125; [IF NOT ExISTS] db_name</span><br><span class="line">[creat_option]</span><br><span class="line">creat_option : &#123;CHARACT&#125;</span><br><span class="line">create table name (create_definition)</span><br><span class="line">例子 ：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table try (</span><br><span class="line">id int(3) not null auto_increment,</span><br><span class="line">name varchar(3) comment &#x27;名字注释&#x27;,</span><br><span class="line">age int(3),</span><br><span class="line">create_user varchar(5),</span><br><span class="line">create_time timestamp not null default  current_timestamp,</span><br><span class="line">update_time timestamp not null default current_timestamp on update current_timestamp,--更新显示时间</span><br><span class="line">primary key(id)--主键</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>表名字 一定是英文 ， 不要写中文 ，可以汉语拼音</li>
<li>一般公司有建表风格</li>
<li>可以加注释 ： comment</li>
<li>空格不宜过多，最好全部贴着最前面</li>
<li>注意括号不能是中文版的</li>
</ul>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul>
<li>把多行数据聚合成一行 ： </li>
<li>sum </li>
<li>max</li>
<li>min</li>
<li>avg</li>
<li>count<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">sum(age) as age,</span><br><span class="line">max(age) as age,</span><br><span class="line">min(age) as age,</span><br><span class="line">count(age) as age,</span><br><span class="line">avg(age) as age </span><br><span class="line">from xxx </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h3><ul>
<li>group by colum</li>
<li><code>select * from xxx group by age;</code></li>
<li><code>select * from xxx where id &gt; 1 having group by age;</code></li>
<li>如果group by 两个 则他的维度就变了</li>
<li>就会变得更细</li>
<li>而且针对于分组之后的结果进行过滤 ，要用having</li>
<li><code>select * from xxx group by age having id &gt; 1;</code></li>
<li>group by 之后你不可以用where</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><ul>
<li>多表联查</li>
<li>join</li>
<li>内连接 ： 他们的公共的部分 <code> select * from a （inner） join b on a.id=b.id</code></li>
<li>外连接 ： </li>
<li>左连接 ：以左表为主 ，右表来匹配 匹配的上 就是可以 匹配不上就是null<code> select * from a left join b on a.id=b.id</code></li>
<li>右连接 ：以右表为主 ， 同上 ： <code>select * from a right join b on a.id=b.id</code></li>
<li>全连接 ： 左右表数据都是全的 ： <code>select * from a Full join b on a.id=b.id</code> 无重复的 （mysql里不支持全连接）</li>
</ul>
<h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">show &#123;databases | schemas&#125;</span><br><span class="line">[LIKE &#x27;pattern&#x27; | WHERE expr]</span><br><span class="line"></span><br><span class="line">show [FULL] tables : 不一定是要切换到这个数据库下才可以</span><br><span class="line">[&#123;FROM | IN&#125; db_name]</span><br><span class="line">[&#123;LIKE &#x27;pattern&#x27; | WHERE expr&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><ul>
<li>use xxx数据库</li>
</ul>
<h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h3><ul>
<li>drop tablename</li>
</ul>
<h2 id="dml"><a href="#dml" class="headerlink" title="dml"></a>dml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">insert select update delete</span><br><span class="line">insert[LOW_PRIORITY | DELAYED | HIGH_PRORITY] [IGNORE]</span><br><span class="line">[INTO]</span><br><span class="line">[(col_name[,col_name]...)]</span><br><span class="line">&#123;VALUES | VALUE&#125; (value_list) [, (value_list)] ...</span><br><span class="line">[ON DUPLICATE KEY UPDATE assignment_list]</span><br><span class="line">比如 ：INSERT into user_table (name,age)VALUES (&#x27;zs&#x27;,10) , (&#x27;ad&#x27; ,19);</span><br><span class="line">* 表示所有字段</span><br><span class="line">select *</span><br><span class="line">from user_table;</span><br><span class="line">select name,age from user_table;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="desc"><a href="#desc" class="headerlink" title="desc"></a>desc</h3><ul>
<li>描述这个表的字段（列）</li>
</ul>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><ul>
<li>update [low_priority] [ignore] table_reference</li>
<li>set assignment_list</li>
<li>[where where_condition]</li>
<li>[order by ..]</li>
<li>[limit row_count]</li>
<li><code>update user_info set age=30; // 这个是对整个表进行更改</code></li>
<li><code>update user_info set age=30 where id=1; // 这个是对id=1的一列进行更改</code></li>
</ul>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><ul>
<li>删除数据</li>
<li>delete [low_priority] [quick] [ignore] from tablename</li>
<li>[partition(partition_name [, partition_name …])]</li>
<li>[where where_condition]</li>
<li>[order by ..]</li>
<li>[limit row_count]</li>
<li><code>delete from user_info where id=1; // 删除id=1的那个行 </code></li>
<li><code>delete from user_info ; // 删除整个表</code></li>
</ul>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><ul>
<li>我们通过order by xxx 让输出的顺序是按照某一个列进行排序的</li>
<li>默认是升序 asc</li>
<li>可以降序 desc</li>
<li><code> select * from try where name in (&#39;zi&#39;,&#39;hi&#39;) order by age desc;</code></li>
<li><code> select * from try where name in (&#39;zi&#39;,&#39;hi&#39;) order by age asc;</code></li>
<li>还可以进行嵌套使用</li>
<li><code>select * from try where name in (&#39;zi&#39;,&#39;hi&#39;) order by age desc , name desc;</code></li>
<li>代表如果age一样，则按照name的降序来</li>
</ul>
<h2 id="dcl"><a href="#dcl" class="headerlink" title="dcl"></a>dcl</h2><p>- </p>
<h2 id="常用字符类型"><a href="#常用字符类型" class="headerlink" title="常用字符类型"></a>常用字符类型</h2><ul>
<li><p>数值类型 ： int整形 long长整型 float单精度小数 double双精度 decimal小数，可以自己指定精度的</p>
</li>
<li><p>字符串 ： char字符（长度0-255 不足会自动补齐 补空格） varchar字符串（长度 0-65535 不会自己补空格）</p>
</li>
<li><p>日期 ：</p>
</li>
<li><pre><code>    date 日期 ： YYYY-MM-DD
</code></pre>
</li>
<li><pre><code>  time 时间 ： HH:mm:ss
</code></pre>
</li>
<li><pre><code>  datetime : 年月日时分秒  YYYY-MM-DD  HH:mm:ss
</code></pre>
</li>
<li><pre><code>  timesatmp ：和java里一样
</code></pre>
</li>
</ul>
<h1 id="mysql的优化"><a href="#mysql的优化" class="headerlink" title="mysql的优化"></a>mysql的优化</h1><ul>
<li>避免使用select * 因为这会造成过多的资源浪费 ，  可以应用 where id &#x3D; xx 筛选出要有需要的行</li>
<li>用union all 代替 union</li>
<li>用小表驱动大表 ： 简单来说 就是 判断条件用小表 ， 搜索用大表 ： 比如  ：in左大右小 ， exists左小右大</li>
<li>做增量操作 ： 比如 ：insert into 是可以一条语句插入多个数据的 但是最好不要超过500条</li>
<li>多用limit ：</li>
<li>in中的值太多用limit限制</li>
<li>增量查询</li>
<li>高效的分页</li>
<li>用连接查询代替子查询</li>
<li>join的加入不宜过多 ， 根据电脑来的 ，但是 一般是不超过3个</li>
<li>控制索引的数量 : 一般小于5个</li>
<li>选择合理的字段</li>
<li>提升gropu by 的效率</li>
<li>大数据一般用 hive 和 hbase</li>
<li>不要求 速度</li>
<li>但是可以presto等工具桥接</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>jdbc</title>
    <url>/2022/11/07/11-7/</url>
    <content><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</li>
<li>注意是工具</li>
</ul>
<h2 id="Maven的配置以及idea使用"><a href="#Maven的配置以及idea使用" class="headerlink" title="Maven的配置以及idea使用"></a>Maven的配置以及idea使用</h2><h3 id="下载及解压"><a href="#下载及解压" class="headerlink" title="下载及解压"></a>下载及解压</h3><ul>
<li>首先在Maven的官网下载Maven</li>
<li><a href="http://maven.apache.org/download.cgi" title="Maven官网">Maven官网</a></li>
<li>我们windows一般下载 ： Binary zip archive的</li>
<li>我这里下载的是 apache-maven-3.8.6-bin.zip</li>
<li>下载完之后 ， 解压到一个文件目录下 </li>
<li>我是新建了个文件目录 命名为 maven</li>
<li>如何解压到文件目录下</li>
</ul>
<h3 id="配置相关文件"><a href="#配置相关文件" class="headerlink" title="配置相关文件"></a>配置相关文件</h3><ul>
<li>解压成功之后 ，我们会获得几个文件夹</li>
<li>bin</li>
<li>boot</li>
<li>conf</li>
<li>lib</li>
<li>这个里conf是maven的配置文件</li>
<li>我们在这个目录下新建maven_repossitory文件夹</li>
<li>这个文件夹可以作为，我们的本地仓库</li>
<li>接下来，我们要修改 conf 文件夹下</li>
<li>settings.xml文件</li>
<li>我们先找到</li>
<li><code>&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code></li>
<li>这条语句的位置</li>
<li>把它更改成</li>
<li><code>&lt;localRepository&gt;你的maven_repossitory路径&lt;/localRepository&gt;</code></li>
<li>这样我们就自己创建了个</li>
<li>因为一般maven的默认仓库是</li>
<li><code>C:\Users\Administrator\.m2\repository</code></li>
<li>接下来 ， 我们进行设置国内镜像源</li>
<li>找到 mirrors 标签</li>
<li>在mirrors里</li>
<li>加上：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">	&lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">	&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">	&lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">	&lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>这个是阿里云的镜像 ， 如果不好使 可以以换成腾讯云 和网易的</li>
<li>添加方法和上面一样</li>
<li>接下来我们可以为maven配置全局的jdk，这样我们在创建maven项目时就会自动使用该jdk版本，我配置的是jdk1.8</li>
<li>找到标签 <profiles></profiles></li>
<li>然后在标签里加入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- java版本 --&gt; </span><br><span class="line">&lt;profile&gt;</span><br><span class="line">  &lt;id&gt;jdk-1.8&lt;/id&gt;</span><br><span class="line">  &lt;activation&gt;</span><br><span class="line">	&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">	&lt;jdk&gt;1.8&lt;/jdk&gt;</span><br><span class="line">  &lt;/activation&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">	&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">	&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">	&lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">&lt;/profile&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="更改idea的maven"><a href="#更改idea的maven" class="headerlink" title="更改idea的maven"></a>更改idea的maven</h3><ul>
<li>file 文件里的 setting</li>
<li>在上面搜索 maven</li>
<li>点进去之后</li>
<li>把Maven home directory</li>
<li>配置成自己的解压的文件夹</li>
<li>然后设置user setting file</li>
<li>把他设置成解压的文件的setting.xml</li>
<li>然后把 local repository</li>
<li>设置成之前自己配置的本地仓库</li>
<li>关于idea的配置就完成了</li>
</ul>
<h2 id="简单的链接mysql"><a href="#简单的链接mysql" class="headerlink" title="简单的链接mysql"></a>简单的链接mysql</h2><ul>
<li>首先创建maven项目</li>
<li>然后在pom.xml中加上</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.1.28&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在<dependencies>标签中加上</li>
<li>然后import change</li>
<li>然后在主程序的java项目包里</li>
<li>写上：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Hello world!</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class App </span><br><span class="line">&#123;</span><br><span class="line">    public static void main( String[] args )</span><br><span class="line">    &#123;</span><br><span class="line">        String url = &quot;jdbc:mysql://192.168.41.131:3306/try&quot;;</span><br><span class="line">        String user = &quot;root&quot;;</span><br><span class="line">        String passwd = &quot;liuzihan010616&quot;;</span><br><span class="line"></span><br><span class="line">        Connection conect = dbutils.getConnection(url , user , passwd);</span><br><span class="line"></span><br><span class="line">        System.out.println(conect);</span><br><span class="line">        dbutils.closeConnection(conect);</span><br><span class="line"></span><br><span class="line">        System.out.println( &quot;Hello World!&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-然后创建一个dbutils</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author sxwang</span><br><span class="line"> * 11 07 15:02</span><br><span class="line"> */</span><br><span class="line">public class dbutils &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取mysql 连接</span><br><span class="line">     * @param url</span><br><span class="line">     * @param user</span><br><span class="line">     * @param passwd</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Connection getConnection(String url, String user, String passwd)&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                connection = DriverManager.getConnection(url, user, passwd);</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关闭连接</span><br><span class="line">     * @param conn</span><br><span class="line">     */</span><br><span class="line">    public static void closeConnection(Connection conn)&#123;</span><br><span class="line"></span><br><span class="line">        if(conn !=null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Mysql对表的操作"><a href="#Mysql对表的操作" class="headerlink" title="Mysql对表的操作"></a>Mysql对表的操作</h2><ul>
<li>alter table 旧表名 rename to 新表名 ： 更改表名字</li>
<li>alter table 表名 modify 列名 数据类型 ： 修改数据类型</li>
<li>alter table 表名 change 旧表名 新列名 数据类型 ： 修改列名</li>
<li>alter table 表名 drop 列名 ： 删除列</li>
<li>alter table 表名 add 新列名 数据类型</li>
<li>alter table 表名 modify 列名1 数据类型 after 列名2；</li>
<li>alter table 表明 modify 列名1 数据类型 first</li>
<li>清空表 </li>
<li>建议</li>
<li>truncate table xxx<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">insert into xxx</span><br><span class="line">select xxx from xxx</span><br></pre></td></tr></table></figure></li>
<li>create</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">create table ...like xxxx</span><br><span class="line">create table xxx like mmm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>基于xxx表创建新表</li>
<li>但是，是空表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">create table ..[as]select xxxx from kkk</span><br><span class="line">create table emp_dev01 as select ename,job</span><br><span class="line">from emp</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>基于其select的表给生成一个表</li>
<li>叫ctas</li>
<li>可以用别名该表头</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/11/08/11-8/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</li>
<li>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</li>
<li>记录文件变化的 ，之后可以指定版本恢复</li>
</ul>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul>
<li>本地 ： 常用 ：简单 ， 缺点 ： 容易出错 ， 集成效率低下</li>
<li>集中 ： svn ： 缺点 ： 中央服务器出现故障就全完了</li>
<li>分布（目前的主流）： 解决单点故障的问题 ： git</li>
<li>git 可以分支 ，，且支持文件备份 ， 多个工作流</li>
<li></li>
</ul>
<h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><ul>
<li>从远程仓库中克隆 Git 资源作为本地仓库</li>
<li>从本地仓库中checkout代码然后进行代码修改</li>
<li>在提交本地仓库前先将代码提交到暂存区</li>
<li>提交修改，提交到本地仓库；本地仓库中保存修改的各个历史版本</li>
<li>在需要和团队成员共享代码时，可以将修改代码push到远程仓库</li>
<li>git 的核心概念 ： 工作区、暂存区、版本库、远程仓库</li>
<li>Workspace： 工作区，就是你平时存放项目代码的地方</li>
<li>Index &#x2F; Stage： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul>
<li>每次的提交Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里这个分支叫主分支，即master分支。HEAD指针严格来说不是指向提交，而是指向master，master才是指向提交的。</li>
</ul>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul>
<li>远程仓库分为公有远程仓库和私有远程仓库。</li>
</ul>
<h1 id="公有远程仓库"><a href="#公有远程仓库" class="headerlink" title="公有远程仓库"></a>公有远程仓库</h1><ul>
<li>本质和本地仓库无异，只是这个仓库①不在本地②大家可能都知道③需要将代码共享到远程仓库④可以被其他人克隆同步代码等。</li>
<li>一般情况下在企业中会有一个搭建在公司的远程仓库，可以让本公司内部的开发人员同步开发。而业界最富盛名的远程仓库则为github；它上面存放了非常多的开源组织、个人、企业等的开放源码库，任何都可以从上面获取源码。</li>
</ul>
<h1 id="私有远程仓库"><a href="#私有远程仓库" class="headerlink" title="私有远程仓库"></a>私有远程仓库</h1><ul>
<li>远程仓库实际上和本地仓库一样，纯粹为了7x24小时开机并交换大家的修改。GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</li>
<li>在本地创建了一个Git仓库，又想让其他人来协作开发，此时就可以把本地仓库同步到远程仓库，同时还增加了本地仓库的一个备份。</li>
<li>常用的远程仓库就是github：<a href="https://github.com/">https://github.com/</a></li>
<li>Github支持两种同步方式“https”和“ssh”。如果使用https很简单基本不需要配置就可以使用，但是每次提交代码和下载代码时都需要输入用户名和密码。而且如果是公司配置的私有git服务器一般不提供https方式访问。</li>
</ul>
<h1 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h1><ul>
<li>在工程中，并不是所有文件都需要保存到版本库中的，例如“target”目录及目录下的文件就可以忽略。Git忽略文件详解可参考Git忽略文件.gitignore详解</li>
</ul>
<h1 id="常用Git命令"><a href="#常用Git命令" class="headerlink" title="常用Git命令"></a>常用Git命令</h1><ul>
<li>经常使用 Git ，但是很多命令还是记不住。但要熟练掌握，恐怕要记住40~60个命令，所以整理了一份常用Git命令清单。可以参考常用Git命令</li>
</ul>
<h2 id="常用的git"><a href="#常用的git" class="headerlink" title="常用的git"></a>常用的git</h2><h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">$ git --version   # 查看git的版本信息</span><br><span class="line">$ git config --global user.name   # 获取当前登录的用户</span><br><span class="line">$ git config --global user.email  # 获取当前登录用户的邮箱</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="登录git"><a href="#登录git" class="headerlink" title="登录git"></a>登录git</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 如果刚没有获取到用户配置，则只能拉取代码，不能修改  要是使用git，你要告诉git是谁在使用</span><br><span class="line">$ git config --global user.name &#x27;userName&#x27;    # 设置git账户，userName为你的git账号，</span><br><span class="line">$ git config --global user.email &#x27;email&#x27;</span><br><span class="line"># 获取Git配置信息，执行以下命令：</span><br><span class="line">$ git config –list</span><br></pre></td></tr></table></figure>
<h3 id="配置https和ssh推送时保存用户名和密码"><a href="#配置https和ssh推送时保存用户名和密码" class="headerlink" title="配置https和ssh推送时保存用户名和密码"></a>配置https和ssh推送时保存用户名和密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># https提交保存用户名和密码</span><br><span class="line">$ git config --global credential.helper store</span><br><span class="line"># 生成公钥私钥，将公钥配置到GitHub，ssh提交就可以免输入用户名密码</span><br><span class="line"># 三次回车即可生成 ssh key</span><br><span class="line">$ ssh-keygen -t rsa</span><br><span class="line"># 查看已生成的公钥</span><br><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<h3 id="推送到远程仓库正确流程"><a href="#推送到远程仓库正确流程" class="headerlink" title="推送到远程仓库正确流程"></a>推送到远程仓库正确流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git init # 初始化仓库</span><br><span class="line">git add .(文件name) # 添加文件到暂存区</span><br><span class="line">git commit -m &quot;first commit&quot; # 添加文件到本地仓库并提交描述信息</span><br><span class="line">git remote add origin 远程仓库地址 # 链接远程仓库，创建主分支</span><br><span class="line">git pull origin master --allow-unrelated-histories # 把本地仓库的变化连接到远程仓库主分支</span><br><span class="line">git push -u origin master # 把本地仓库的文件推送到远程仓库</span><br></pre></td></tr></table></figure>
<h3 id="新建本地仓库"><a href="#新建本地仓库" class="headerlink" title="新建本地仓库"></a>新建本地仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 创建一个文件夹</span><br><span class="line">$ mkdir GitRepositories    # 创建文件夹GitRepositories</span><br><span class="line">$ cd GitRepositories       # 切换到GitRepositories目录下</span><br><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="配置-全局和项目"><a href="#配置-全局和项目" class="headerlink" title="配置(全局和项目)"></a>配置(全局和项目)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</span><br><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="增加-x2F-删除文件"><a href="#增加-x2F-删除文件" class="headerlink" title="增加&#x2F;删除文件"></a>增加&#x2F;删除文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1][file2] ...</span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
<h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>
<h3 id="分支-1"><a href="#分支-1" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br><span class="line">#强制删除分支</span><br><span class="line">$ git branch -D [branch-name]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看目录</span><br><span class="line">$ ls -al	或者$ ll</span><br><span class="line"># 查看仓库状态，显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br><span class="line"># 以图形化界面展示 分支的commit 历史</span><br><span class="line">$ git log --oneline --gragh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line">$ git fetch 也同上</span><br><span class="line">$ git pull 相当 fetch ＋ merge</span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br><span class="line">$ push推的是分支不是代码</span><br><span class="line"># 可以选择那个远程仓库那个分支</span><br><span class="line">$ git push [&lt;repository&gt; [&lt;分支的名字&gt;]]</span><br><span class="line">$ git fetch</span><br><span class="line">$ git fetch --all</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"># 从工作区撤回文件</span><br><span class="line">$ git restore --staged xxxx xxx xxx... </span><br><span class="line">#从暂存区到工作区撤回</span><br><span class="line">$ git restore xxx xxx xxx..</span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 从当前目录的所有文件中查找文本内容：</span><br><span class="line">$ git grep &quot;Hello&quot;</span><br><span class="line"># 在某一版本中搜索文本：</span><br><span class="line">$ git grep &quot;Hello&quot; v2.5</span><br><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>当工作区和暂存区都有的时候</li>
<li>直接更改工作区的文件 通过</li>
<li>commit -am “xx”</li>
<li>可以直接把修改了的文件传到本地仓库</li>
<li>merge : 经过merge的文件 ， 相当于把其他地方的分支给回收回来 ，</li>
</ul>
<h3 id="git文件夹的目录介绍"><a href="#git文件夹的目录介绍" class="headerlink" title=".git文件夹的目录介绍"></a>.git文件夹的目录介绍</h3><ul>
<li>HEAD ： 当前项目正在工作的分支</li>
<li>config ： 我们当前项目的一些配置信息（我们本地的配置信息）</li>
<li>可以通过 <code>git config --local user.name &quot;xxx&quot;</code> 来进行设置</li>
<li>或者直接在这个文件按照格式改也一样</li>
<li>同样 ， 有set就有get</li>
<li>refs ： 指向的是那个分支的指向</li>
<li>commit 的hash值对应的是什么内容的</li>
<li>object : git真正的存储对象 </li>
<li><code>git cat-file</code> </li>
<li><code>-t</code> : 文件类型</li>
<li><code>-p</code> : 文件内容</li>
<li><code>tree</code> ： 代表是文件夹</li>
<li><code>blob</code> ： 代表文件内容</li>
<li>git 存储文件高效的原因 ： 不同的文件只要有相同的地方就是一个blob</li>
</ul>
<h3 id="查看git文件存储的方法"><a href="#查看git文件存储的方法" class="headerlink" title="查看git文件存储的方法"></a>查看git文件存储的方法</h3><ul>
<li>我们先进入到.git的object文件夹里 ，因为object文件夹是git存储的首要位置</li>
<li>接下来 ，我们找到refs的文件 ，然后进入到heads里</li>
<li>找到文件 ，里面有我们的commit的哈希值</li>
<li>通过哈希值的前两个字母</li>
<li>我们在object文件夹下 ，找到这两个字符的文件夹</li>
<li>点进去查看文件名字</li>
<li>然后我们在命令行</li>
<li>输入<code>git cat-file -p</code></li>
<li>和<code>git cat-file -t</code></li>
<li>就可以查看到文件的类型和文件的内容</li>
<li>对于文件的内容，我们可以对于上次-p出来的文件再次进行 -p操作 哈希值 ，</li>
<li>就可以看见了</li>
<li>修改之前的某个commit的message</li>
<li>可以用 <code>git rebase</code></li>
<li>git rebase -i &lt;after - this - commit&gt;: 交互式 : 基于前一个commit 进行修改当前的commit ，这样修改了之后所有的hash值会改变，因为变头了 ，但是如果先进行了 ， <code>git cherry-pick</code>操作,则会把吗，master和以前的分支都改变（hash），但是一般是不带master等其他分支的</li>
<li>常用的操作</li>
<li>-p ： </li>
<li>-r ： 重写一个commit的message</li>
<li>-e ： </li>
<li>-s ： 合并多个commit的message</li>
<li>输入上面的那个命令之后我们要进入到一个界面</li>
<li>把要修改的前面改成 r</li>
<li>然后保存退出</li>
<li>然后就会跳转到另外可以编辑这个要编辑的conmmit的地方</li>
<li>就改掉message就好</li>
<li>合并本地message 要在本地合并 ，不能在远程合并</li>
<li>把多个commit合并成一个commit的操作和上面一样 ，只不过是把r改成s了</li>
<li>但是这样合并之后，你相当于把这些信息合并到一起 ，就把最上面的那个看成是一个集合</li>
<li>这样之后一般会放到 .git文件之下的 ， rebase</li>
</ul>
<h2 id="忽略文件-1"><a href="#忽略文件-1" class="headerlink" title="忽略文件"></a>忽略文件</h2><ul>
<li><code>.gitignore</code>文件就是忽略文件</li>
</ul>
<h2 id="仓库备份"><a href="#仓库备份" class="headerlink" title="仓库备份"></a>仓库备份</h2><ul>
<li>git clone ： 就是克隆&#x2F;备份</li>
<li>克隆一个仓库到一个新的文件夹</li>
<li>git clone &lt;仓库&gt; &lt;名字&gt;</li>
<li>这个仓库是本地或者远程仓库</li>
<li>仓库 ： 可以接url，或者本地的.git文件</li>
<li>克隆到名字的文件夹里 ，如果么没有则创建</li>
<li>本地备份本地不常用</li>
<li>一般都是备份远程仓库</li>
<li>对于远程仓库的地址 ，则是为我们通过查看远程仓库的地址进行</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/11/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">$ hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>把jar包打包成exe</title>
    <url>/2022/11/19/jar%E5%88%B0exe/</url>
    <content><![CDATA[<h1 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h1><ul>
<li>我们所使用的工具是exe4j 和 inno setup</li>
</ul>
<h2 id="exe4j"><a href="#exe4j" class="headerlink" title="exe4j"></a>exe4j</h2><ul>
<li>简单来说这个就是个工具，可以把java的jar包打包成exe的</li>
<li>可以让其他由java运行环境的机器运行这个jar</li>
<li>而且还可以稍微做到保密的程度</li>
<li>exe4j 是一个帮助你集成 Java 应用程序到 Windows 操作环境的 java 可执行文件生成工具，无论这些应用是用于服务器，还是图形用户界面（GUI）或命令行的应用程序。如果你想在任务管理器中及 Windows XP 分组的用户友好任务栏里以你的进程名取代 java.exe 的出现，那么 exe4j 可以完成这个工作。exe4j 帮助你以一种安全的方式启动你的 java 应用程序，来显示本地启动画面，检测及发布合适的 JRE 和 JDK，以及进行启动时所发生的错误处理等，以至于更多。</li>
<li>关于exe4j的破解我就不多赘述了，懂的都懂</li>
<li>接下来是实际操作</li>
<li>下面是开始界面</li>
<li><img src="https://pic.imgdb.cn/item/6378540416f2c2beb192c11f.jpg" alt="开始界面"></li>
<li>然后接下来</li>
<li>选择jar到exe的模式</li>
<li><img src="https://pic.imgdb.cn/item/6378546916f2c2beb1932dfa.jpg"></li>
<li>然后接下来要选择你的输出路径</li>
<li><img src="https://pic.imgdb.cn/item/637854cd16f2c2beb193c56c.jpg"></li>
<li>接下来选择我们的启动方式，我选择的是控制台启动</li>
<li><img src="https://pic.imgdb.cn/item/6378550616f2c2beb1942a62.jpg"></li>
<li>接下来选择可以在32位和64位机器上都可以运行</li>
<li><img src="https://pic.imgdb.cn/item/6378553316f2c2beb194a3be.jpg"></li>
<li><img src="https://pic.imgdb.cn/item/6378556516f2c2beb1952fa9.jpg"></li>
<li>接下来选择我们exe要执行的主类</li>
<li>我这个项目是boot项目，所以选择的是这个</li>
<li><img src="https://pic.imgdb.cn/item/6378558416f2c2beb195719f.jpg"></li>
<li>然后设置我们的jdk版本</li>
<li><img src="https://pic.imgdb.cn/item/637855bd16f2c2beb195f1d6.jpg"></li>
<li><img src="https://pic.imgdb.cn/item/637855dc16f2c2beb1962843.jpg"></li>
<li>最后一直点击next就好了</li>
<li><img src="https://pic.imgdb.cn/item/6378564016f2c2beb196ce41.jpg"></li>
<li>这样我们就打包完成了</li>
<li>但是这样的打包只能再有jdk的环境中运行</li>
<li>接下来我们要为这个添加依赖</li>
</ul>
<h2 id="inno-setup"><a href="#inno-setup" class="headerlink" title="inno setup"></a>inno setup</h2><ul>
<li>简单来说就是个绑定依赖的程序</li>
<li>打开</li>
<li><img src="https://pic.imgdb.cn/item/6378572316f2c2beb198e2a2.jpg"></li>
<li><img src="https://pic.imgdb.cn/item/6378577616f2c2beb199aecb.jpg"></li>
<li><img src="https://pic.imgdb.cn/item/6378579d16f2c2beb19a1b5f.jpg"></li>
<li>然后配置我们的名称和版本号</li>
<li>然后选择我们，刚刚弄个出来的exe程序</li>
<li><img src="https://pic.imgdb.cn/item/637858cd16f2c2beb19b780b.jpg"></li>
<li>然后就一直傻瓜式next</li>
<li><img src="https://pic.imgdb.cn/item/6378593316f2c2beb19be141.jpg"></li>
<li>设置输出文件夹</li>
<li>图标</li>
<li>以及运行时的密码</li>
<li>然后一直next就好</li>
<li>然后会跳出两个对话框</li>
<li>全部选择是</li>
<li>最后会出现这个东西</li>
<li><img src="https://pic.imgdb.cn/item/637859e916f2c2beb19d21f9.jpg"></li>
<li>就代表导入依赖了</li>
<li>接下来我们要对他进行修改</li>
<li><img src="https://pic.imgdb.cn/item/63785a3d16f2c2beb19d8050.jpg"></li>
<li>这个是自己电脑本机的jdk路径</li>
<li>然后还有要在这里加上MYjrename</li>
<li><img src="https://pic.imgdb.cn/item/63785a8116f2c2beb19dd2fa.jpg"></li>
<li>最后运行就成功了</li>
<li>他会给你成一个setup文件，通过这个文件安装的exe</li>
<li>就会自己带环境了</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>杂货技术栈</category>
      </categories>
  </entry>
  <entry>
    <title>java面试题</title>
    <url>/2022/10/15/java%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/</url>
    <content><![CDATA[<h1 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载发生在同一个类里，方法名必须相同，参数类型不同，个数不同，顺序不同，方法的返回值和访问修饰符可以不同，发生在编译时</p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>发生在父类和子类中，方法名，参数列表相同，返回值范围小于等于父类，<br>抛出异常小于等于父类，访问修饰符大于等于父类，若父类的方法是private则不能重写</p>
<h1 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>list是有序的，按照插入对象的顺序进行访问的，可重复，，可以有多个null元素，可以用iterator取出所有元素，在逐一遍历还可以用get（index）获取指定元素</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>set是无序的，不可重复，，最多有一个null对象取元素的时候只能用iterator接口取出所有元素，再逐一遍历</p>
<h1 id="谈谈Concurrent-Hash-Map的扩容机制"><a href="#谈谈Concurrent-Hash-Map的扩容机制" class="headerlink" title="谈谈Concurrent Hash Map的扩容机制"></a>谈谈Concurrent Hash Map的扩容机制</h1><h2 id="1-7jdk"><a href="#1-7jdk" class="headerlink" title="1.7jdk"></a>1.7jdk</h2><ul>
<li><p>1.ConcurrentHashMap是基于Segment来实现的</p>
</li>
<li><p>2.每个Segment相当于是一个小型的HashMap</p>
</li>
<li><p>3.每个Segment内部都会进行扩容，和HashMap的扩容逻辑相同</p>
</li>
<li><p>4.先生成一个新的数组，然后转移元素到新数组中</p>
</li>
<li><p>5.扩容的判断也是每个Segment单独进行判断的</p>
</li>
</ul>
<h2 id="1-8jdk"><a href="#1-8jdk" class="headerlink" title="1.8jdk"></a>1.8jdk</h2><ul>
<li><p>1.到了1.8 就不基于Segment了</p>
</li>
<li><p>2.当某个线程进行put的时，如果发现有扩容的，就会优先跟着一起进行扩容，</p>
</li>
<li><p>3.如果发现没有进行扩容的，就会把key-value添加到ConcurrentHashMap中然后判断超过阈值了吗超过了则进行扩容</p>
</li>
<li><p>4.ConcurrentHashMap是支持多线程同时扩容的</p>
</li>
<li><p>5.扩容之前也先生成一个新数组</p>
</li>
<li><p>6.转移元素之前先将元素分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或者多组的元素转移工作</p>
</li>
</ul>
<h1 id="jdk1-7到1-8HashMap发生了什么变化"><a href="#jdk1-7到1-8HashMap发生了什么变化" class="headerlink" title="jdk1.7到1.8HashMap发生了什么变化"></a>jdk1.7到1.8HashMap发生了什么变化</h1><h2 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h2><p>其底层是数组加链表<br>使用的是头插法<br>哈希算法比较复杂</p>
<h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p>其底层是数组+链表和红黑树加入红黑树的目的是加快查找效率<br>其用的是尾插法，要先遍历数组的每个元素，判断数组中的元素个数<br>哈希算法进行了优化，节省cpu资源</p>
<h1 id="接口可以多继承接口"><a href="#接口可以多继承接口" class="headerlink" title="接口可以多继承接口"></a>接口可以多继承接口</h1><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><p>浅拷贝是指只会拷贝基础类型的值<br>浅拷贝是指拷贝的地址指向同一目标</p>
<h1 id="CopyOnwriteArrayList底层"><a href="#CopyOnwriteArrayList底层" class="headerlink" title="CopyOnwriteArrayList底层"></a>CopyOnwriteArrayList底层</h1><ul>
<li><p>1.首先其内部也是通过数组实现的，在向其中加元素的时候时，会复制一个新数组 ， 并在新数组上进行进行写操作 ， 读操作在原数组上进行</p>
</li>
<li><p>2.并且写操作会加锁，防止出现写入数据丢失的问题</p>
</li>
<li><p>3.写操作结束之后会把原数组指向新数组</p>
</li>
<li><p>4.CopyOnWriteArrayList允许在写数据的同时进行读数据，大大提高了效率因此适合读多写少的场景，但其比较占内存，因此读到的数据并不是最新的，因此适用与实时性不强的地方</p>
</li>
</ul>
<h1 id="什么是字节码-字节码的好处"><a href="#什么是字节码-字节码的好处" class="headerlink" title="什么是字节码 字节码的好处"></a>什么是字节码 字节码的好处</h1><p>编译器Javac会将java源文件编译为.class可以做到一次编译到此处运行，例如，windows上编译好的.class可以在linux上运行。</p>
<h2 id="采用字节码的好处"><a href="#采用字节码的好处" class="headerlink" title="采用字节码的好处"></a>采用字节码的好处</h2><p>一方面实现了跨平台，另外一方面提高了代码的执行效率，让编译器可以在编译时进行优化</p>
<h1 id="在java的异常处理机制中，什么时候要抛出异常，什么时候捕获异常"><a href="#在java的异常处理机制中，什么时候要抛出异常，什么时候捕获异常" class="headerlink" title="在java的异常处理机制中，什么时候要抛出异常，什么时候捕获异常"></a>在java的异常处理机制中，什么时候要抛出异常，什么时候捕获异常</h1><p>异常相当于一种提示 ， 若我们抛出异常，就相当于告诉上层方法，我抛出了一个异常，我处理不了这个异常给你来处理，如果上层也处理不了，就继续往上抛，或者捕获</p>
<h1 id="java中异常体系是怎么样的"><a href="#java中异常体系是怎么样的" class="headerlink" title="java中异常体系是怎么样的"></a>java中异常体系是怎么样的</h1><p>java中所有异常都来自于顶级父类 Throwable<br>Throwable下有两个子类Exceptio 和 erro<br>error属于重大错误：包括但不限于 虚拟机，磁盘，操作系统层面的问题<br>Exception属于普通编译器报错，其还分为运行时异常和编译时异常</p>
<h1 id="包装类型传参数的时候按照基本类型算，只传值，不传地址"><a href="#包装类型传参数的时候按照基本类型算，只传值，不传地址" class="headerlink" title="包装类型传参数的时候按照基本类型算，只传值，不传地址"></a>包装类型传参数的时候按照基本类型算，只传值，不传地址</h1><h1 id="java中的类加载机制"><a href="#java中的类加载机制" class="headerlink" title="java中的类加载机制"></a>java中的类加载机制</h1><p>jdk中自带了三个类加载器：</p>
<h2 id="BootStrap-ClassLoader"><a href="#BootStrap-ClassLoader" class="headerlink" title="BootStrap ClassLoader"></a>BootStrap ClassLoader</h2><p>BootStrap是Ext的父类加载器默认负责加载%JAVA_HOME%lib下面的lib和class</p>
<h2 id="Ext-ClassLoader"><a href="#Ext-ClassLoader" class="headerlink" title="Ext ClassLoader"></a>Ext ClassLoader</h2><p>Ext ClassLoader是AppClassLoader的父类，默认加载%JAVA_HOME%&#x2F;lib&#x2F;ext文件夹下的jar包和class</p>
<h2 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h2><p>AppClassLoader是自定义器的加载器的父类，负责加载classpath下的</p>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>简单来说就是当问题从最下面的类加载器进入的时候会先让最上面的类加载器加载，然后逐级往下，最后才是自己定义的类加载器</p>
<h1 id="排查JVM问题"><a href="#排查JVM问题" class="headerlink" title="排查JVM问题"></a>排查JVM问题</h1><h2 id="对于还可以正常运行的系统"><a href="#对于还可以正常运行的系统" class="headerlink" title="对于还可以正常运行的系统"></a>对于还可以正常运行的系统</h2><ul>
<li><p>可以使用jmap来查看各个区域的情况</p>
</li>
<li><p>可以通过jstack来查看线程的运行情况，比如xxx线程阻塞；是不是死锁等</p>
</li>
<li><p>可以通过jstat命令查看垃圾回收的情况 ， 特别是fullgc若fullgc比较多就要考虑调优了</p>
</li>
<li><p>通过各个命令的结果，或者jvisualvm等工具进行分析</p>
</li>
<li><p>猜测fullgc多的原因：如果无内存溢出，那么表示fullgc是回收了很多对象，所以这些对象最好能在younggc过程中直接回收，避免进入老年代，对于这些情况就要考虑存活区间是不是比较小，导致年轻代放不下，直接到了老年代，尝试加大年轻代的区间若改完fullgc变小，则猜想正确</p>
</li>
</ul>
<h2 id="对于已发生了OOM的系统"><a href="#对于已发生了OOM的系统" class="headerlink" title="对于已发生了OOM的系统"></a>对于已发生了OOM的系统</h2><ul>
<li>一般生产中都会设置系统发生了OOM时，生成当时的dump文件（-xx:+HeapDumpOnOutOfMemoryError -xx:HHEapDump Path &#x3D; &#x2F;user&#x2F;local&#x2F;base)</li>
<li>我们可以用jsvisualvm等工具进行分析dump</li>
<li>根据dump找到异常实例和线程（占用cpu高），定位到具体代码。</li>
<li>之后再做细致的分析</li>
</ul>
<h1 id="一个对象从加载到jvm到被Gc清楚都经历了什么"><a href="#一个对象从加载到jvm到被Gc清楚都经历了什么" class="headerlink" title="一个对象从加载到jvm到被Gc清楚都经历了什么"></a>一个对象从加载到jvm到被Gc清楚都经历了什么</h1><ul>
<li>先把字节码文件内容加载到方法区</li>
<li>然后再根据类信息在堆区域创建对象</li>
<li>对象首先会分配在堆中年轻代的Eden区经过一次Minorc之后会进入Survivor区，在后续的每次MinorGC中若一直存活，则会在Suvivor区来回拷贝，每拷贝一次每移动一次年龄加1</li>
<li>当年龄过15，若对象仍存活，会进入老年态</li>
<li>若经过fullgc，被标记为垃圾对象，那么会被gc线程清楚</li>
</ul>
<h1 id="jvm有哪些垃圾回收算法"><a href="#jvm有哪些垃圾回收算法" class="headerlink" title="jvm有哪些垃圾回收算法"></a>jvm有哪些垃圾回收算法</h1><h2 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h2><ul>
<li>标记阶段：把垃圾内存标记出来</li>
<li>清除阶段：直接把垃圾内存回收</li>
<li>问题：会产生大量的内存碎片</li>
</ul>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ul>
<li>为了解决标记清除的内存碎片的问题</li>
<li>将内存分为两份，每次只使用其中一半，垃圾回收时将当前这一块的存活对象完全拷贝到另外一半，而后当前这一半可直接清除，这种无内存碎片，但是浪费空间，且放弃和存活对象的个数相关</li>
</ul>
<h2 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h2><ul>
<li>为了解决复制算法的缺陷，就提出了标记压缩算法，这种算法在标记阶段跟标记清除算法是一样的，但是在完成之后不是直接清理，而是将存活的对象往一端移动，而后面将边界以外的所有内存清除</li>
</ul>
<h1 id="什么是STW"><a href="#什么是STW" class="headerlink" title="什么是STW"></a>什么是STW</h1><p>Stw-stop-the-world,是在垃圾回收算法执行过程中要将JVM内存冻结的一种状态，在STW状态下，java的所有线程都是停止执行的——GC除外，native方法可执行；但是不能与jvm交互GC各种算法的优化的重点便是减少STW,是jvm调优的重点</p>
<h1 id="jvm参数"><a href="#jvm参数" class="headerlink" title="jvm参数"></a>jvm参数</h1><ul>
<li>标注指令：开头这个是所有Hotspot都支持的参数，可以用java-help</li>
<li>非标注指令:-x开头；与特定的hotspot对立的用java-x打印</li>
<li>不稳定参数：-xx开头，与上面一样</li>
</ul>
<h1 id="对守护线程的理解"><a href="#对守护线程的理解" class="headerlink" title="对守护线程的理解"></a>对守护线程的理解</h1><p>线程分为 守护线程和用户线程</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>是jvm的后台线程，比如垃圾回收器，守护线程会在其他线程都停止之后自动关闭，我们可以通过设置thread.setDemon（true）来把一个线程设置成守护线程</p>
<h2 id="普通线程"><a href="#普通线程" class="headerlink" title="普通线程"></a>普通线程</h2><p>普通用户的线程</p>
<h1 id="ThreadLocal的底层原理"><a href="#ThreadLocal的底层原理" class="headerlink" title="ThreadLocal的底层原理"></a>ThreadLocal的底层原理</h1><p>其是java中所提供的线程本地存储机制，可利用该机制将数据存储到一个线程内部，该线程可在任意时刻，任意的方法，获取其存储的数据</p>
<ul>
<li>其底层是通过ThreadLocalMap来实现的，Map的key为ThreadLocal对象，Map的value为需要缓存的值</li>
<li>如果在线程池中使用ThreadLocal会造成内存泄露，因为当ThreadLoccal对象用完之后应该把设置的key value 也就是Entry的对象进行回收，但是线程池的线程不会进行回收，而线程对象是通过强引用指向ThreadLocalMap而ThreadLocalMap也是通过强引用的方法指向Entry的对象，线程也就不会被回收，从而出现内存泄露。</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>在使用了ThreadLocal对象之后，手动调Thread Local的remove方法，手动清除Entry，其经典应用是用在连接管理上</li>
</ul>
<h1 id="并发-并行-穿行的区别"><a href="#并发-并行-穿行的区别" class="headerlink" title="并发,并行,穿行的区别"></a>并发,并行,穿行的区别</h1><ul>
<li>串行：一个任务执行完才可以执行下一个</li>
<li>并发：两个任务看起来是一起执行的，在底层，两个任务被拆成了很多份，从而后一个执行，但是在更高处看，两个任务是一起执行的</li>
<li>并行：两个可以一起执行</li>
</ul>
<h1 id="java死锁如何避免"><a href="#java死锁如何避免" class="headerlink" title="java死锁如何避免"></a>java死锁如何避免</h1><ul>
<li>一个资源每次只被一个线程调用</li>
<li>一个线程在阻塞资源的时候不释放已经占有的资源</li>
<li>一个线程已经获得的资源在使用之前不可被强行剥夺</li>
<li>若干个线程形成头尾相接的循环等待状</li>
</ul>
<h1 id="说一下HashMap的put方法"><a href="#说一下HashMap的put方法" class="headerlink" title="说一下HashMap的put方法"></a>说一下HashMap的put方法</h1><h2 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h2><ul>
<li><p>1.根据key通过哈希算法与与运算得出数组的下标</p>
</li>
<li><p>2.如果数组下标的元素为空 ， 则将key和value封装为entry对象（1.7中是Entry ， 1.8里是node对象）并放入该位置</p>
</li>
</ul>
<h2 id="如果数组下标不为空，分情况讨论"><a href="#如果数组下标不为空，分情况讨论" class="headerlink" title="如果数组下标不为空，分情况讨论"></a>如果数组下标不为空，分情况讨论</h2><h3 id="1-7jdk-1"><a href="#1-7jdk-1" class="headerlink" title="1.7jdk"></a>1.7jdk</h3><ul>
<li>要先判断是不是要扩容，如果不扩容就生成Entry对象，并且用头插法添加到当前位置的链表中</li>
</ul>
<h3 id="1-8jdk-1"><a href="#1-8jdk-1" class="headerlink" title="1.8jdk"></a>1.8jdk</h3><ul>
<li>会先判断当前位置上node的类型，看是红黑树node还是链表node</li>
<li>如果是红黑树node，则会将key和value封装为一个红黑树节点并添加到红黑树中去，这个过程中会判断是不是有当前key，如果存在则更新value</li>
<li>如果此位置是node对象是链表节点，则将key和value封装为一个链表node并通过尾插法插到链表最后去，因为是尾插法所以要遍历整个链表，在遍历链表的过程中会判断是不是存在当前的key如果存在就更新key，当遍历完链表后，将新node插入到链表中，插入链表1后会看到当前链表的节点个数，如果大于等于8就会把这个链表转化为红黑树</li>
<li>将key和value封装为node插入到链表或红黑树中再判断是不是需要扩容如果需要就扩容，不需要就结束put方法</li>
</ul>
<h1 id="线程池的底层工作原理"><a href="#线程池的底层工作原理" class="headerlink" title="线程池的底层工作原理"></a>线程池的底层工作原理</h1><ul>
<li>线程池内部是通过队列＋线程实现的，当我们用线程池执行任务的时候</li>
<li>如果此时线程池中的线程数量小于CorePoolSize，即使线程池中都处于空闲状态，也同样要创建新的线程来处理被添加的任务</li>
<li>如果此时线程池中的线程数量等于CorePoolSize, 但是缓存队列workQueue未满，且线程池中的数量小于maximumPoolsize</li>
</ul>
<h1 id="线程池为什么是先添加队列而不是先创建最大线程"><a href="#线程池为什么是先添加队列而不是先创建最大线程" class="headerlink" title="线程池为什么是先添加队列而不是先创建最大线程"></a>线程池为什么是先添加队列而不是先创建最大线程</h1><p>当线程池中的核心线程在忙时如果继续往线程池中添加任务，那么任务还会放入队列，队列满了之后，才会开始新的线程，这就相当于，一个公司本来有10个程序员，本来这10个程序员能正常处理各种需求，但是随着公司的发展，需求在慢慢增加，但是一开始这些需求只会增加在待开发列表中，然后这10个程序员加班加点的从待开发列表中获取需求并进行处理，但是某一天待开发列表满了，所以员工处理不过来了，所以就开始招募新员工了。</p>
<h1 id="ReentrantLock中的公平锁和非公平锁的底层实现"><a href="#ReentrantLock中的公平锁和非公平锁的底层实现" class="headerlink" title="ReentrantLock中的公平锁和非公平锁的底层实现"></a>ReentrantLock中的公平锁和非公平锁的底层实现</h1><p>首先不管是公平锁还是非公平锁他们的底层都是通过AQS来实现排队的，他们的区别在于：线程使用lock（）方法加锁的时候，如果是公平锁，会先检查AQS队列中是不是存在线程在排队，如果存在，则当前线程也会进行排队，如果是非公平锁，则不会去检查是不是有线程在排队，而是直接竞争锁，不管是公平锁还是非公平锁，一旦没竞争到锁，就会进行排队，当锁释放的时候都是唤醒最前面的线程，所以非公平锁只是体现在了线程加锁的阶段，而没有体现在线程被唤醒的阶段。</p>
<h1 id="ReentrantLock中tryLock-和lock（）方法的区别"><a href="#ReentrantLock中tryLock-和lock（）方法的区别" class="headerlink" title="ReentrantLock中tryLock()和lock（）方法的区别"></a>ReentrantLock中tryLock()和lock（）方法的区别</h1><ul>
<li>tryLock()表示尝试加锁，可能加到，也可能加不到，该方法不会阻止线程，如果加到锁就返回true，没有加到则返回false</li>
<li>lock（）则表示线程阻塞加锁，线程会阻塞直到加上锁，而且也没有返回值</li>
</ul>
<h1 id="CountDownLatch和Semaphore的区别和底层原理"><a href="#CountDownLatch和Semaphore的区别和底层原理" class="headerlink" title="CountDownLatch和Semaphore的区别和底层原理"></a>CountDownLatch和Semaphore的区别和底层原理</h1><ul>
<li>CountDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用CountDownLatch的await（）将会被阻塞，其他线程可以调用CountDownlatch的countDown（）方法来对CountDownLacth中的数字减一，当一个数字被减为0之后则会将AQS中排队的线程依次唤醒</li>
<li>Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过acquire来获取许可，如果没有许可可用则用线程阻塞，并通过ASQ来排队，可以通过release的方法释放许可当某一个线程释放死锁之后会从ASQ的第一个线程开始依次唤醒，直到没有空闲许可</li>
</ul>
<h1 id="Sychronized"><a href="#Sychronized" class="headerlink" title="Sychronized"></a>Sychronized</h1><ul>
<li>偏向锁： 在锁对象的对象头中记录下当前获取到该锁的线程id，该线程下次如果又来获取该锁就可以直接获取到了</li>
<li>轻量级锁：由偏向锁升级而来，当一个线程获取到锁之后，此时这把锁是偏向锁，此时如果由第二个线程来竞争这个锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁是为了和重量级锁分开，轻量级锁底层是通过自旋来实现的，并不会阻塞线程。</li>
<li>如果自旋次数过多扔无法获取锁，则会升级为重量级锁，重量级锁会导致线程阻塞</li>
<li>自旋锁：自旋锁就是在线程获取锁的过程中，不回去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是要操作系统中去实现的，比较耗费时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取去过获取到，则表式获取到了锁，这个过程线程一直在运行，相对而言没有使用太多的操作系统资源，比较轻量</li>
</ul>
<h1 id="Sychronized和ReentrantLock的区别"><a href="#Sychronized和ReentrantLock的区别" class="headerlink" title="Sychronized和ReentrantLock的区别"></a>Sychronized和ReentrantLock的区别</h1><ul>
<li>前一个是关键字，后一个是一个类</li>
<li>前一个会自动加锁和释放锁，后面一个需要手动加锁和个释放锁</li>
<li>前一个底层是jvm层面 ， 后面一个底层是api层面</li>
<li>前一个是非公平锁 ， 后面一个是可以选非公平或者公平</li>
<li>前一个锁的是对象所信息保存在对象头中，后面一个是通过代码中int型的state标识符状态</li>
<li>前一个底层有个锁升级的过程</li>
</ul>
<h1 id="谈谈你对AQS的理解，AQS如何实现可重入锁"><a href="#谈谈你对AQS的理解，AQS如何实现可重入锁" class="headerlink" title="谈谈你对AQS的理解，AQS如何实现可重入锁"></a>谈谈你对AQS的理解，AQS如何实现可重入锁</h1><ul>
<li>AQS是一个java线程同步的框架，是jdk中很多锁的工具核心框架</li>
<li>在AQS中，维护了信号量state和一个线程的双向链表队列，其中这个线程队列，就是用来给线程排队的而state就像是个红绿灯，用来控制排队</li>
<li>在不同的场景下，有不同的意义</li>
<li>在可重入锁这个场景下state用来保证加锁的次数，0表示标识无锁，每次加锁，states就加1，释放就减少1</li>
</ul>
<h1 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a>谈谈你对IOC的理解</h1><ul>
<li>通常我们任务spring有两大特性IoC和AOP</li>
<li>IoC进行了对象的反转，就是对象控制权的转移</li>
</ul>
<h1 id="单例和Bean"><a href="#单例和Bean" class="headerlink" title="单例和Bean"></a>单例和Bean</h1><ul>
<li>单例表示这个类只能实例化一次</li>
<li>而bean并不表示jvm里只存在一个类的Bean</li>
</ul>
<h1 id="Spring的事务传播机制"><a href="#Spring的事务传播机制" class="headerlink" title="Spring的事务传播机制"></a>Spring的事务传播机制</h1><ul>
<li>多个事务方法互相调用的时候，事务是如何在这些方法之间传播的</li>
<li>REQUIRED（默认的传播机制）：如果没有事务，就自己创建一个新的事务，如果存在事务，就加入</li>
<li>SUPPIORTS：当前存在事务，则加入，如果不存在就按照不存在的来</li>
<li>MANDATORY：当前存在事务则加入，不存在则抛出异常</li>
<li>REQUIRES_NEW：创建一个新事务，如果存在这个事务，就挂起他</li>
<li>NOT_SUPPORTED:用非事务的方式执行，如果当前存在事务，则挂起事务</li>
<li>NEVER：不使用事务如果事务存在，则会抛出异常</li>
<li>NESTED：如果当前事务存在，则在嵌套事务中执行要不然就和REQUIRED一样</li>
</ul>
<h1 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h1><ul>
<li>线程与协程的区别： </li>
<li>1：包含关系：一个进程可以有多个协程，一个线程也可以有多个协程 </li>
<li>2：同步：线程进程是同步，协程是异步 </li>
<li>3：协程能保留上一次重入的状态，当程序重新调用时，可以直接进入上一次的调用的位置 </li>
<li>4：资源占用：线程是抢占式，协程是非抢占式，也就是会所在同一时间只能有一个协程运行，相当于单线程 </li>
<li>5：与线程调用关系：协程并不能代替线程，线程是分割的CPU资源，协程是执行的代码，协程并不会直接调用线程，它会调用线程的执行器</li>
</ul>
<h1 id="myysql的索引以及他们的好处和坏处"><a href="#myysql的索引以及他们的好处和坏处" class="headerlink" title="myysql的索引以及他们的好处和坏处"></a>myysql的索引以及他们的好处和坏处</h1><ul>
<li>优点： 1.大大加快数据的检索速度 </li>
<li>2.通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能 </li>
<li>缺点： 1.时间方面：创建索引和维护索引要耗费时间，索引需要动态的维护 </li>
<li>2.空间方面：需要占物理空间</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li>现代操作系统中，进程是分配资源的最小单位，运行一个程序，就创建一个进程，一个进程里可以包括多个线程，线程是系统调度的基本单位， 每个线程里都拥有各自的程序计数器，堆栈，局部变量表等属性，并且共享进程里面的资源，处理器在这些线程之间高速切换，使使用者误以为这些线程是同时执行的。 </li>
<li>对于最简单的输出hello world程序，就包括四个线程， main，清除reference的线程，和finalize方法有关的线程，处理jvm信号的线程， </li>
<li>之所以使用多线程是因为多线程有个好处 </li>
<li>1.现代计算机是多核处理器，而一个线程同一时刻只能运行在一个处理器上，对于单线程程序，同一时刻只能使用一个处理器，显然这是一种资源浪费， 而对于多线程程序，可以把计算逻辑分配给不同的处理器，极大的提高的程序的执行效率 </li>
<li>2.可以把复杂的业务逻辑种的对数据一致性要求不强的操作，比如生成订单快照分配给其他的线程去处理（也可以使用消息队列），极大的提高了程序的响应时间 </li>
<li>3.java提供了一个良好的多线程模型，能是开发者专注于业务的开发</li>
</ul>
<h1 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h1><ul>
<li>Java保证线程安全的方式有很多,其中较为常用的有三种,按照资源占用情况由轻到重排列,这三种保证线程安全的方式分别是原子类、volatile、锁。 </li>
<li>JDK从1.5开始提供了java.util.concurrent.atomic包,这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</li>
<li>在atomic包里一共提供了17个类,按功能可以归纳为4种类型的原子更新方式,分别是原子更新基本类型、原子更新引用类型、原子更新属性、原子更新数组。</li>
<li>无论原子更新哪种类型,都要遵循“比较和替换”规则,即比较要更新的值是否等于期望值,如果是则更新,如果不是则失败。 </li>
<li>volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”,从而可以保证单个变量读写时的线程安全。</li>
<li>可见性问题是由处理器核心的缓存导致的,每个核心均有各自的缓存,而这些缓存均要与内存进行同步。</li>
<li>volatile具有如下的内存语义：当写一个volatile变量时,该线程本地内存中的共享变量的值会被立刻刷新到主内存；当读一个volatile变量时,该线程本地内存会被置为无效,迫使线程直接从主内存中读取共享变量。</li>
<li>原子类和volatile只能保证单个共享变量的线程安全,锁则可以保证临界区内的多个共享变量的线程安全,Java中加锁的方式有两种,分别是synchronized关键字和Lock接口。</li>
<li>synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。</li>
<li>若想通过升级的方式让它支持这些相对复杂的功能,则需要大改它的语法结构,不利于兼容旧代码。</li>
<li>因此,JDK的开发团队在1.5新增了Lock接口,并通过Lock支持了上述的功能,即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。 </li>
<li>加分回答 实现线程安全的方式有很多,除了上述三种方式之外,还有如下几种方式： </li>
<li><ol>
<li>无状态设计 线程安全问题是由多线程并发修改共享变量引起的,如果在并发环境中没有设计共享变量,则自然就不会出现线程安全问题了。这种代码实现可以称作“无状态实现”,所谓状态就是指共享变量。</li>
</ol>
</li>
<li><ol start="2">
<li>不可变设计 如果在并发环境中不得不设计共享变量,则应该优先考虑共享变量是否为只读的,如果是只读场景就可以将共享变量设计为不可变的,这样自然也不会出现线程安全问题了。具体来说,就是在变量前加final修饰符,使其不可被修改,如果变量是引用类型,则将其设计为不可变类型（参考String类）。</li>
</ol>
</li>
<li><ol start="3">
<li>并发工具 java.util.concurrent包提供了几个有用的并发工具类,一样可以保证线程安全：</li>
</ol>
</li>
<li>Semaphore：就是信号量,可以控制同时访问特定资源的线程数量。 </li>
<li>CountDownLatch：允许一个或多个线程等待其他线程完成操作。 </li>
<li>CyclicBarrier：让一组线程到达一个屏障时被阻塞,直到最后一个线程到达屏障时,屏障才会打开,所有被屏障拦截的线程才会继续运行。 </li>
<li><ol start="4">
<li>本地存储 我们也可以考虑使用ThreadLocal存储变量,ThreadLocal可以很方便地为每一个线程单独存一份数据,也就是将需要并发访问的资源复制成多份。这样一来,就可以避免多线程访问共享变量了,它们访问的是自己独占的资源,它从根本上隔离了多个线程之间的数据共享。</li>
</ol>
</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul>
<li><ol>
<li>死锁 两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。</li>
</ol>
</li>
<li><ol start="2">
<li>产生死锁的必要条件 虽然进程在运行过程中,可能发生死锁,但死锁的发生也必须具备一定的条件,死锁的发生必须具备以下四个必要条件：</li>
</ol>
</li>
<li><ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用,即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源,则请求者只能等待,直至占有资源的进程用毕释放；</li>
</ul>
</li>
<li><ul>
<li>请求和保持条件：指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放；</li>
</ul>
</li>
<li><ul>
<li>不剥夺条件：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放；</li>
</ul>
</li>
<li><ul>
<li>环路等待条件：指在发生死锁时,必然存在一个进程——资源的环形链,即进程集合 {P0,P1,P2,···,Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源,……,Pn 正在等待已被 P0 占用的资源。</li>
</ul>
</li>
</ul>
<h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><ul>
<li>进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket： </li>
<li><ol>
<li>管道 管道也叫无名（匿名）管道,它是是 UNIX 系统 IPC（进程间通信）的最古老形式,所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区,Linux 系统中通过 pipe() 函数创建管道,会生成两个文件描述符,分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。</li>
</ol>
</li>
<li><ol start="2">
<li>命名管道 匿名管道,由于没有名字,只能用于亲缘关系的进程间通信。为了克服这个缺点,提出了有名管道（FIFO）,也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联,以 FIFO 的文件形式存在于文件系统中,并且其打开方式与打开一个普通文件是一样的,这样即使与 FIFO 的创建进程不存在亲缘关系的进程,只要可以访问该路径,就能够彼此通过 FIFO 相互通信,因此,通过 FIFO 不相关的进程也能交换数据。</li>
</ol>
</li>
<li><ol start="3">
<li>信号 信号是 Linux 进程间通信的最古老的方式之一,是事件发生时对进程的通知机制,有时也称之为软件中断,它是在软件层次上对中断机制的一种模拟,是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。</li>
</ol>
</li>
<li><ol start="4">
<li>消息队列 消息队列就是一个消息的链表,可以把消息看作一个记录,具有特定的格式以及特定的优先级,对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程则可以从消息队列中读走消息,消息队列是随内核持续的。</li>
</ol>
</li>
<li><ol start="5">
<li>共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分,因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中,并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比,这种 IPC 技术的速度更快。</li>
</ol>
</li>
<li><ol start="6">
<li>内存映射 内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件。</li>
</ol>
</li>
<li><ol start="7">
<li>信号量 信号量主要用来解决进程和线程间并发执行时的同步问题,进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作,P 操作是将信号量的值减 1,V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后,再进行 P 操作时,当前进程或线程会被阻塞,直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。</li>
</ol>
</li>
<li><ol start="8">
<li>Socket 套接字（Socket）,就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端,提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。</li>
</ol>
</li>
</ul>
<h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><ul>
<li>MVC是一种设计模式,在这种模式下软件被分为三层,即Model（模型）、View（视图）、Controller（控制器）。</li>
<li>Model代表的是数据,View代表的是用户界面,Controller代表的是数据的处理逻辑,它是Model和View这两层的桥梁。</li>
<li>将软件分层的好处是,可以将对象之间的耦合度降低,便于代码的维护。 </li>
<li>Model：指从现实世界中抽象出来的对象模型,是应用逻辑的反应；它封装了数据和对数据的操作,是实际进行数据处理的地方（模型层与数据库才有交互）。</li>
<li>在MVC的三个部件中,模型拥有最多的处理任务。被模型返回的数据是中立的,模型与数据格式无关,这样一个模型能为多个视图提供数据,由于应用于模型的代码只需写一次就可以被多个视图重用,所以减少了代码的重复性。 </li>
<li>View：负责进行模型的展示,一般就是我们见到的用户界面。 </li>
<li>Controller：控制器负责视图和模型之间的交互,控制对用户输入的响应、响应方式和流程；它主要负责两方面的动作,一是把用户的请求分发到相应的模型,二是吧模型的改变及时地反映到视图上。 </li>
<li>加分回答 为了解耦以及提升代码的可维护性,服务端开发一般会对代码进行分层,服务端代码一般会分为三层：表现层、业务层、数据访问层。在浏览器访问服务器时,请求会先到达表现层 最典型的MVC就是jsp+servlet+javabean模式。 </li>
<li>以JavaBean作为模型,既可以作为数据模型来封装业务数据,又可以作为业务逻辑模型来包含应用的业务操作。 JSP作为视图层,负责提供页面为用户展示数据,提供相应的表单（Form）来用于用户的请求,并在适当的时候（点击按钮）向控制器发出请求来请求模型进行更新。 </li>
<li>Serlvet作为控制器,用来接收用户提交的请求,然后获取请求中的数据,将之转换为业务模型需要的数据模型,然后调用业务模型相应的业务方法进行更新,同时根据业务执行结果来选择要返回的视图。 当然,这种方式现在已经不那么流行了,</li>
<li>Spring MVC框架已经成为了MVC模式的最主流实现。 </li>
<li>Spring MVC框架是基于Java的实现了MVC框架模式的请求驱动类型的轻量级框架。前端控制器是DispatcherServlet接口实现类,映射处理器是HandlerMapping接口实现类,视图解析器是ViewResolver接口实现类,页面控制器是Controller接口实现类</li>
</ul>
<h1 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a>redis的数据类型</h1><ul>
<li>Redis主要提供了5种数据结构：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)。Redis还提供了Bitmap、HyperLogLog、Geo类型,但这些类型都是基于上述核心数据类型实现的。</li>
<li>5.0版本中,Redis新增加了Streams数据类型,它是一个功能强大的、支持多播的、可持久化的消息队列。 </li>
<li>string可以存储字符串、数字和二进制数据,除了值可以是String以外,所有的键也可以是string,string最大可以存储大小为2M的数据。 </li>
<li>list保证数据线性有序且元素可重复,它支持lpush、blpush、rpop、brpop等操作,可以当作简单的消息队列使用,一个list最多可以存储2^32-1个元素 hash的值本身也是一个键值对结构,最多能存储2^32-1个元素 </li>
<li>set是无序不可重复的,它支持多个set求交集、并集、差集,适合实现共同关注之类的需求,一个set最多可以存储2^32-1个元素 zset是有序不可重复的,它通过给每个元素设置一个分数来作为排序的依据,一个zset最多可以存储2^32-1个元素。 </li>
<li>加分回答 每种类型支持多个编码,每一种编码采取一个特殊的结构来实现 各类数据结构内部的编码及结构： </li>
<li>string：编码分为int、raw、embstr；</li>
<li>int底层实现为long,当数据为整数型并且可以用long类型表示时可以用long存储；</li>
<li>embstr底层实现为占一块内存的SDS结构,当数据为长度不超过32字节的字符串时,选择以此结构连续存储元数据和值；</li>
<li>raw底层实现为占两块内存的SDS,用于存储长度超过32字节的字符串数据,此时会在两块内存中分别存储元数据和值。 </li>
<li>list：编码分为ziplist、linkedlist和quicklist（3.2以前版本没有quicklist）。</li>
<li>ziplist底层实现为压缩列表,当元素数量小于2且所有元素长度都小于64字节时,使用这种结构来存储；</li>
<li>linkedlist底层实现为双端链表,当数据不符合ziplist条件时,使用这种结构存储；</li>
<li>3.2版本之后list一般采用quicklist的快速列表结构来代替前两种。 </li>
<li>hash：编码分为ziplist、hashtable两种,</li>
<li>其中ziplist底层实现为压缩列表,当键值对数量小于2,并且所有的键值长度都小于64字节时使用这种结构进行存储；</li>
<li>hashtable底层实现为字典,当不符合压缩列表存储条件时,使用字典进行存储。 </li>
<li>set：编码分为inset和hashtable,intset底层实现为整数集合,当所有元素都是整数值且数量不超过2个时使用该结构存储,否则使用字典结构存储。 </li>
<li>zset：编码分为ziplist和skiplist,当元素数量小于128,并且每个元素长度都小于64字节时,使用ziplist压缩列表结构存储,否则使用skiplist的字典+跳表的结构存储。</li>
</ul>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><ul>
<li>乐观锁：乐观锁总是假设最好的情况,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型,这样可以提高吞吐量**,像数据库提供的类似于write_condition机制,其实都是提供的乐观锁。 </li>
<li>悲观锁：悲观锁总是假设最坏的情况,每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用,其它线程阻塞,用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制,比如行锁,表锁等,读锁,写锁等,都是在做操作之前先上锁。 加分回答 两种锁的使用场景 乐观锁： GIT,SVN,CVS等代码版本控制管理器,就是一个乐观锁使用很好的场景,</li>
<li>例如：A、B程序员,同时从SVN服务器上下载了code.html文件,当A完成提交后,此时B再提交,那么会报版本冲突,此时需要B进行版本处理合并后,再提交到服务器。这其实就是乐观锁的实现全过程。如果此时使用的是悲观锁,那么意味者所有程序员都必须一个一个等待操作提交完,才能访问文件,这是难以接受的。 悲观锁： 悲观锁的好处在于可以减少并发,但是当并发量非常大的时候,由于锁消耗资源、锁定时间过长等原因,很容易导致系统性能下降,资源消耗严重。因此一般我们可以在并发量不是很大,并且出现并发情况导致的异常用户和系统都很难以接受的情况下,会选择悲观锁进行。</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li>创建型包括：单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式； </li>
<li>结构型包括：代理模式、装饰模式、适配器模式、组合模式、桥梁模式、外观模式和享元模式； </li>
<li>行为型包括：模板方法模式、命令模式、责任链模式、策略模式、迭代器模式、中介者模式、观察者模式、备忘录模式、访问者模式、状态模式和解释器模式。 面试中不要求23种设计模式全部了解,但至少应掌握单例模式和工厂模式。 加分回答 可以说出知道的框架所用到的设计模式或底层设计模式,例如Spring中的单例模式、工厂模式,AQS的模板模式等等。</li>
</ul>
]]></content>
      <categories>
        <category>Java中的易错点</category>
      </categories>
  </entry>
  <entry>
    <title>作业10-21</title>
    <url>/2022/10/21/%E4%BD%9C%E4%B8%9A10-21/</url>
    <content><![CDATA[<h1 id="3、用文件名过滤器实现输出指定目录下的所有java文件的文件名称"><a href="#3、用文件名过滤器实现输出指定目录下的所有java文件的文件名称" class="headerlink" title="3、用文件名过滤器实现输出指定目录下的所有java文件的文件名称"></a>3、用文件名过滤器实现输出指定目录下的所有java文件的文件名称</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 项目实训;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">import 作业.file;</span><br><span class="line"></span><br><span class="line">public class file过滤 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		File M = new File(&quot;D:\\&quot; , &quot;try&quot;);</span><br><span class="line">		chakan(M);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void chakan(File M) &#123;</span><br><span class="line">		File[] k = M.listFiles();</span><br><span class="line">		System.out.println(k);</span><br><span class="line">		for (int i = 0; i &lt; k.length; i++) &#123;</span><br><span class="line">			File[] t = k[i].listFiles();</span><br><span class="line">			if(t == null) &#123;</span><br><span class="line">				String g =  k[i].getName();</span><br><span class="line">				String d = g.substring(k[i].getName().lastIndexOf(&quot;.&quot;));</span><br><span class="line">				if(d.equals(&quot;.java&quot;)) &#123;</span><br><span class="line">					System.out.println(g.substring(0, k[i].getName().lastIndexOf(&quot;.&quot;)));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				chakan(k[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>重点字符串的相等要用equals，递归</li>
</ul>
<h1 id="判断指定路径下的所有子文件或是目录，如果是子文件则全部删除"><a href="#判断指定路径下的所有子文件或是目录，如果是子文件则全部删除" class="headerlink" title="判断指定路径下的所有子文件或是目录，如果是子文件则全部删除"></a>判断指定路径下的所有子文件或是目录，如果是子文件则全部删除</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static void SHANCHU(File k) &#123;</span><br><span class="line">File[] ds =	k.listFiles(); </span><br><span class="line">for (int i = 0; i &lt; ds.length ; i++ ) &#123;</span><br><span class="line">	File[] h = ds[i].listFiles();</span><br><span class="line">	if(h == null) &#123;</span><br><span class="line">		System.out.println(&quot;这个是个文件&quot;);</span><br><span class="line">		ds[i].delete();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		k.delete();</span><br><span class="line">		SHANCHU(ds[i]);</span><br><span class="line">			&#125;</span><br><span class="line">	k.delete();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重点：递归</li>
</ul>
<h1 id="5、查找API（File），通过程序创建指定的目录。假设在D盘下创建一个目录102班级，在102班级下又有一个子目录javaSE作业（D-102班级-javaSE作业）"><a href="#5、查找API（File），通过程序创建指定的目录。假设在D盘下创建一个目录102班级，在102班级下又有一个子目录javaSE作业（D-102班级-javaSE作业）" class="headerlink" title="5、查找API（File），通过程序创建指定的目录。假设在D盘下创建一个目录102班级，在102班级下又有一个子目录javaSE作业（D:\102班级\javaSE作业）"></a>5、查找API（File），通过程序创建指定的目录。假设在D盘下创建一个目录102班级，在102班级下又有一个子目录javaSE作业（D:\102班级\javaSE作业）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">File G = new File(&quot;D:\\\\102班级\\\\javaSE作业&quot;);</span><br><span class="line"></span><br><span class="line">G.mkdirs();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="从磁盘读取一个文件到内存中，再打印到控制台"><a href="#从磁盘读取一个文件到内存中，再打印到控制台" class="headerlink" title="从磁盘读取一个文件到内存中，再打印到控制台"></a>从磁盘读取一个文件到内存中，再打印到控制台</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 项目实训;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class lkdjfslasfj &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			InputStream is = new FileInputStream(&quot;D:/a.txt&quot;);</span><br><span class="line">//				while(is.available() != 0) &#123;</span><br><span class="line">//					System.out.println((char)is.read()); // 默认一次只读一个字符</span><br><span class="line">//				&#125;</span><br><span class="line">			</span><br><span class="line">			byte[] buffer = new byte[10]; // 通过设置缓冲区进行扩展一次可读的字符数量，如果是字符型，那这个byte要变char</span><br><span class="line">			int len = 0; // 设置个长度</span><br><span class="line">			while((len = is.read(buffer)) != -1) // 判断我是不是超出缓冲区的限定，如果超出，就只读取超出的部分</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.print(new String(buffer , 0 , len)); </span><br><span class="line">			&#125;</span><br><span class="line">			is.close();</span><br><span class="line">			&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="模拟用户登录："><a href="#模拟用户登录：" class="headerlink" title="模拟用户登录："></a>模拟用户登录：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class login &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		File basic = new File(&quot;D://&quot; , &quot;a.txt&quot;);</span><br><span class="line">		try(InputStream in = new FileInputStream(basic);</span><br><span class="line">			Reader re = new InputStreamReader(in , &quot;UTF-8&quot;);	</span><br><span class="line">			) &#123;</span><br><span class="line">			Map db = new HashMap();</span><br><span class="line">			Scanner scanner = new Scanner(re);</span><br><span class="line">			while(scanner.hasNext()) &#123;</span><br><span class="line">			String usertotal = scanner.nextLine();</span><br><span class="line">			String[] username = usertotal.split(&quot; &quot;);</span><br><span class="line">//			System.out.println(username[0]);</span><br><span class="line">//			System.out.println(username[1]);</span><br><span class="line">			db.put(username[0],username[1]);</span><br><span class="line">//			System.out.println(db);</span><br><span class="line">			&#125;</span><br><span class="line">			Scanner name = new Scanner(System.in);</span><br><span class="line">			String usename;</span><br><span class="line">			String password;</span><br><span class="line">			while(true) &#123;</span><br><span class="line">			while(true) &#123;</span><br><span class="line">			System.out.println(&quot;请输入账号：&quot;);</span><br><span class="line">			 usename = name.nextLine();</span><br><span class="line">			if(usename == null) &#123;</span><br><span class="line">				System.out.println(&quot;姓名不能为空&quot;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			while(true) &#123;</span><br><span class="line">				System.out.println(&quot;请输入密码&quot;);</span><br><span class="line">				 password = name.nextLine();</span><br><span class="line">						</span><br><span class="line">				if(password == null) &#123;</span><br><span class="line">					System.out.println(&quot;密码不能为空&quot;);</span><br><span class="line">					</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">					break;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(password.equals(db.get(usename))) &#123;</span><br><span class="line">				System.out.println(&quot;登陆成功&quot;);</span><br><span class="line">				break;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				System.out.println(&quot;输入错误请重新输入&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e1) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package 作业;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class login &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		File basic = new File(&quot;D://&quot; , &quot;a.txt&quot;);</span><br><span class="line">		try(InputStream in = new FileInputStream(basic);</span><br><span class="line">			Reader re = new InputStreamReader(in , &quot;UTF-8&quot;);	</span><br><span class="line">			) &#123;</span><br><span class="line">			Map db = new HashMap();</span><br><span class="line">			Scanner scanner = new Scanner(re);</span><br><span class="line">			while(scanner.hasNext()) &#123;</span><br><span class="line">			String usertotal = scanner.nextLine();</span><br><span class="line">			String[] username = usertotal.split(&quot; &quot;);</span><br><span class="line">//			System.out.println(username[0]);</span><br><span class="line">//			System.out.println(username[1]);</span><br><span class="line">			db.put(username[0],username[1]);</span><br><span class="line">//			System.out.println(db);</span><br><span class="line">			&#125;</span><br><span class="line">			Scanner name = new Scanner(System.in);</span><br><span class="line">			String usename;</span><br><span class="line">			String password;</span><br><span class="line">			while(true) &#123;</span><br><span class="line">			while(true) &#123;</span><br><span class="line">			System.out.println(&quot;请输入账号：&quot;);</span><br><span class="line">			 usename = name.nextLine();</span><br><span class="line">			if(usename == null) &#123;</span><br><span class="line">				System.out.println(&quot;姓名不能为空&quot;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			while(true) &#123;</span><br><span class="line">				System.out.println(&quot;请输入密码&quot;);</span><br><span class="line">				 password = name.nextLine();</span><br><span class="line">						</span><br><span class="line">				if(password == null) &#123;</span><br><span class="line">					System.out.println(&quot;密码不能为空&quot;);</span><br><span class="line">					</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">					break;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(password.equals(db.get(usename))) &#123;</span><br><span class="line">				System.out.println(&quot;登陆成功&quot;);</span><br><span class="line">				System.out.println(&quot;输入1进行修改密码&quot;);</span><br><span class="line">				int m = Integer.parseInt(name.nextLine());</span><br><span class="line">				if(m == 1) &#123;</span><br><span class="line">					if(db.containsKey(usename)) &#123;</span><br><span class="line">						System.out.println(&quot;请输入更改之后的密码&quot;);</span><br><span class="line">						String newpassword = name.nextLine();</span><br><span class="line">						db.put(usename, newpassword);</span><br><span class="line">					&#125; </span><br><span class="line">				&#125;</span><br><span class="line">				break;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				System.out.println(&quot;输入错误请重新输入&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e1) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
  </entry>
  <entry>
    <title>sql练习</title>
    <url>/2022/11/05/sql%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">create database bigdata;</span><br><span class="line">use bigdata;</span><br><span class="line"></span><br><span class="line">--部门表</span><br><span class="line">dept部门表(deptno部门编号/dname部门名称/loc地点)</span><br><span class="line">create table dept (</span><br><span class="line">    deptno numeric(2),</span><br><span class="line">    dname varchar(14),</span><br><span class="line">    loc varchar(13)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into dept values (10, &#x27;ACCOUNTING&#x27;, &#x27;NEW YORK&#x27;);</span><br><span class="line">insert into dept values (20, &#x27;RESEARCH&#x27;, &#x27;DALLAS&#x27;);</span><br><span class="line">insert into dept values (30, &#x27;SALES&#x27;, &#x27;CHICAGO&#x27;);</span><br><span class="line">insert into dept values (40, &#x27;OPERATIONS&#x27;, &#x27;BOSTON&#x27;);</span><br><span class="line"></span><br><span class="line">--工资等级表</span><br><span class="line">salgrade工资等级表(grade 等级/losal此等级的最低/hisal此等级的最高)</span><br><span class="line">create table salgrade (</span><br><span class="line">    grade numeric,</span><br><span class="line">    losal numeric,</span><br><span class="line">    hisal numeric</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into salgrade values (1, 700, 1200);</span><br><span class="line">insert into salgrade values (2, 1201, 1400);</span><br><span class="line">insert into salgrade values (3, 1401, 2000);</span><br><span class="line">insert into salgrade values (4, 2001, 3000);</span><br><span class="line">insert into salgrade values (5, 3001, 9999);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--员工表</span><br><span class="line">emp员工表(empno员工号/ename员工姓名/job工作/mgr上级编号/hiredate受雇日期/sal薪金/comm佣金/deptno部门编号)</span><br><span class="line">工资 ＝ 薪金 ＋ 佣金</span><br><span class="line"></span><br><span class="line">create table emp (</span><br><span class="line">    empno numeric(4) not null,</span><br><span class="line">    ename varchar(10),</span><br><span class="line">    job varchar(9),</span><br><span class="line">    mgr numeric(4),</span><br><span class="line">    hiredate datetime,</span><br><span class="line">    sal numeric(7, 2),</span><br><span class="line">    comm numeric(7, 2),</span><br><span class="line">    deptno numeric(2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into emp values (7369, &#x27;SMITH&#x27;, &#x27;CLERK&#x27;, 7902, &#x27;1980-12-17&#x27;, 800, null, 20);</span><br><span class="line">insert into emp values (7499, &#x27;ALLEN&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1981-02-20&#x27;, 1600, 300, 30);</span><br><span class="line">insert into emp values (7521, &#x27;WARD&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1981-02-22&#x27;, 1250, 500, 30);</span><br><span class="line">insert into emp values (7566, &#x27;JONES&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1981-04-02&#x27;, 2975, null, 20);</span><br><span class="line">insert into emp values (7654, &#x27;MARTIN&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1981-09-28&#x27;, 1250, 1400, 30);</span><br><span class="line">insert into emp values (7698, &#x27;BLAKE&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1981-05-01&#x27;, 2850, null, 30);</span><br><span class="line">insert into emp values (7782, &#x27;CLARK&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1981-06-09&#x27;, 2450, null, 10);</span><br><span class="line">insert into emp values (7788, &#x27;SCOTT&#x27;, &#x27;ANALYST&#x27;, 7566, &#x27;1982-12-09&#x27;, 3000, null, 20);</span><br><span class="line">insert into emp values (7839, &#x27;KING&#x27;, &#x27;PRESIDENT&#x27;, null, &#x27;1981-11-17&#x27;, 5000, null, 10);</span><br><span class="line">insert into emp values (7844, &#x27;TURNER&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1981-09-08&#x27;, 1500, 0, 30);</span><br><span class="line">insert into emp values (7876, &#x27;ADAMS&#x27;, &#x27;CLERK&#x27;, 7788, &#x27;1983-01-12&#x27;, 1100, null, 20);</span><br><span class="line">insert into emp values (7900, &#x27;JAMES&#x27;, &#x27;CLERK&#x27;, 7698, &#x27;1981-12-03&#x27;, 950, null, 30);</span><br><span class="line">insert into emp values (7902, &#x27;FORD&#x27;, &#x27;ANALYST&#x27;, 7566, &#x27;1981-12-03&#x27;, 3000, null, 20);</span><br><span class="line">insert into emp values (7934, &#x27;MILLER&#x27;, &#x27;CLERK&#x27;, 7782, &#x27;1982-01-23&#x27;, 1300, null, 10);</span><br><span class="line"></span><br><span class="line">1.查询出部门编号为30的所有员工的编号和姓名</span><br><span class="line"></span><br><span class="line">	table： emp</span><br><span class="line">	查什么： </span><br><span class="line">		1.维度：group by</span><br><span class="line">		2.指标: 聚合函数</span><br><span class="line">		3.普普通通的字段：	编号和姓名</span><br><span class="line">	怎么查：</span><br><span class="line">		where：</span><br><span class="line">			部门编号为30</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.找出部门编号为10中所有经理，和部门编号为20中所有销售员的详细资料。</span><br><span class="line">3.查询所有员工详细信息，用工资降序排序，如果工资相同使用入职日期升序排序</span><br><span class="line">4.列出薪金大于1500的各种工作及从事此工作的员工人数。</span><br><span class="line">5.列出在销售部工作的员工的姓名，假定不知道销售部的部门编号。</span><br><span class="line">6.查询姓名以S开头的\以S结尾\包含S字符\第二个字母为L  __</span><br><span class="line">7.查询每种工作的最高工资、最低工资、人数</span><br><span class="line">8.列出薪金 高于 公司平均薪金的所有员工号，员工姓名，所在部门名称，上级领导，工资，工资等级</span><br><span class="line">9.列出薪金  高于  在各自部门工作的员工的平均薪金的员工姓名和薪金、部门名称。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">80% sqlboy sqlgirl</span><br><span class="line">20% 大数据平台</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="结题"><a href="#结题" class="headerlink" title="结题"></a>结题</h1><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><ul>
<li>查询出部门编号为30的所有员工的编号和姓名</li>
<li>确定部门编号的条件 where deptno &#x3D; 30</li>
<li>确定所要的信息 ename ， epmpno</li>
<li>从员工表里筛选</li>
<li><code> select empno ,ename from emp where deptno = 30;</code></li>
<li><code> select empno ,ename from emp where deptno in (30);</code></li>
</ul>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><ul>
<li>找出部门编号为10中所有经理，和部门编号为20中所有销售员的详细资料。</li>
<li>确定条件 ： </li>
<li>职业为经理的（MANAGER） ，部门编号为 10</li>
<li>职业为销售员的（SALESMAN） ， 部门编号为 20</li>
</ul>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul>
<li><code>select * from emp where job = &quot;MANAGER&quot; and deptno = 10;</code></li>
<li><code>select * from emp where job = &quot;SALESMAN&quot; and  deptno = 20;</code></li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><ul>
<li><code>select * from emp where job in (&quot;MANAGER&quot;) and deptno = 10;</code></li>
<li><code>select * from emp where job in (&quot;SALESMAN&quot;) and  deptno = 20;</code></li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><ul>
<li><code>select * from emp where job in (&quot;SALESMAN&quot;) and  deptno = 20;</code></li>
<li><code>select * from emp where job in (&quot;MANAGER&quot;) and deptno = 10;</code></li>
</ul>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><ul>
<li><code>select * from emp where (job, deptno) in ((&quot;SALESMAN&quot;, 20));</code></li>
<li><code>select * from emp where (job, deptno) in ((&quot;MANAGER&quot;, 10));</code></li>
</ul>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><ul>
<li><code>select * from emp where (job, deptno) in ((&quot;SALESMAN&quot;, 20)  , (&quot;MANAGER&quot;, 10));</code></li>
</ul>
<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><ul>
<li>查询所有员工详细信息，用工资降序排序，如果工资相同使用入职日期升序排序</li>
<li>条件 ：工资和入职时间</li>
<li>工资 ＝ 薪金 ＋ 佣金</li>
<li>但是mysql里一个值和null相加会变成null</li>
<li>通过 ifnull  或者 coalesce  进行转化</li>
<li>所以要转化 </li>
<li>这个题有两种解法</li>
</ul>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><ul>
<li>先转化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">(sal + yy) as hh ,</span><br><span class="line">(sal + kk) as ii,</span><br><span class="line">hiredate</span><br><span class="line">from (</span><br><span class="line">    select</span><br><span class="line">    hiredate,</span><br><span class="line">    sal,</span><br><span class="line">    ifnull(comm , 0) as yy,</span><br><span class="line">    coalesce(comm , 0) as kk</span><br><span class="line">    from emp</span><br><span class="line">) as hyy</span><br><span class="line">order by hh desc,hiredate asc;</span><br></pre></td></tr></table></figure>

<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><ul>
<li>转化和展示一起做</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">hiredate,</span><br><span class="line">ifnull((sal + comm) , sal) as total,</span><br><span class="line">coalesce((sal + comm) , sal) as ti</span><br><span class="line">from emp</span><br><span class="line">order by total desc , hiredate asc;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><ul>
<li>列出薪金大于1500的各种工作及从事此工作的员工人数</li>
<li>条件 ： 薪金 就是<code>sal &gt; 1500</code> 的<code>工作</code> 求<code>人数</code></li>
<li>薪金的条件可以用<code>where</code> 或者<code>having</code></li>
<li>工作可以用<code>group by job</code></li>
<li>人数可以用count</li>
</ul>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h3><ul>
<li><code>select job, count(*) from emp where sal &gt; 1500 group by job;</code></li>
</ul>
<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><ul>
<li>列出在销售部工作的员工的姓名，假定不知道销售部的部门编号</li>
<li>条件 ：  不知道部门编号 但是我们可以从表中获取</li>
</ul>
<h3 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h3><ul>
<li><code>select ename from emp left join dept on dept.deptno = emp.deptno where dname = &quot;SALES&quot; ;</code></li>
</ul>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select ename from emp where (</span><br><span class="line">    select </span><br><span class="line">    deptno</span><br><span class="line">    from dept</span><br><span class="line">    where dname = &quot;SALES&quot; </span><br><span class="line">) = emp.deptno ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select ename from emp where deptno in (</span><br><span class="line">    select </span><br><span class="line">    deptno</span><br><span class="line">    from dept</span><br><span class="line">    where dname = &quot;SALES&quot; </span><br><span class="line">) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><ul>
<li>查询姓名以S开头的\以S结尾\包含S字符\第二个字母为L</li>
<li>两种方式 like 或者正则</li>
</ul>
<h3 id="1-4"><a href="#1-4" class="headerlink" title="1"></a>1</h3><ul>
<li><code>select ename from emp where ename like &quot;%s%&quot; or  ename like &quot;_L&quot;; </code></li>
</ul>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2"></a>2</h3><ul>
<li><code>select ename from emp where ename REGEXP &#39;*s*&#39;or ename REGEXP &#39;^.L&#39;;</code></li>
</ul>
<h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><ul>
<li>查询每种工作的最高工资、最低工资、人数</li>
<li>条件 ： <code>工资</code> ， <code>最高工资</code> ， <code>最低工资</code> ， <code>人数</code></li>
<li>这个题目前我所想到的有两种</li>
<li>第一是慢慢做 ，用嵌套的方式 ，</li>
<li>优点 ： 不用动脑</li>
<li>缺点 ： 代码量比较多</li>
<li>第二个是第一个的优化版本 </li>
<li>优点 ： 代码量少很多</li>
<li>缺点 : 难理解</li>
<li></li>
</ul>
<h3 id="1-5"><a href="#1-5" class="headerlink" title="1"></a>1</h3><ul>
<li>我们先获取基本的数据源  </li>
<li>获取工资的情况 ，以及各种职业所对应的工资 及其人数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">(ifnull((sal + comm) , sal)) as sal1,</span><br><span class="line">job,</span><br><span class="line">count(*) as total_people</span><br><span class="line">from emp group by job,sal1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>接下来是获取最高工资 和最低工资 ，以及工作的种类 ,以及总人数（最高工资，以及最低工资的）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select max(sal1),min(sal1),job,count(*)</span><br><span class="line">from(select </span><br><span class="line">(ifnull((sal + comm) , sal)) as sal1,</span><br><span class="line">job,</span><br><span class="line">count(*) as total_people</span><br><span class="line">from emp group by job,sal1) as king group by job;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>接下来 我们只需要连接上述的两个表 </li>
<li>一个表里对应的是每个人所对应的工资以及职业</li>
<li>因为一个表里是我们的最高的工资，最低的工资以及他所对应的工作 和总人数</li>
<li>相当于第二个表当我们的筛选条件 ， 如果符合筛选条件 就从第一个表选出这条数据</li>
<li>然后获得符合条件的人数</li>
<li>根据以上分析 ， 我们采用左连接的方式 ，</li>
<li>内连接可能会丢值 ，不过在此题中不会丢值</li>
<li>如下 ：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">sal1,</span><br><span class="line">max_sal,</span><br><span class="line">min_sal,</span><br><span class="line">tjob,</span><br><span class="line">total_people</span><br><span class="line">from(</span><br><span class="line">select max(sal1) as max_sal,min(sal1) as min_sal,job as tjob,count(*)</span><br><span class="line">from(select </span><br><span class="line">(ifnull((sal + comm) , sal)) as sal1,</span><br><span class="line">job,</span><br><span class="line">count(*) as total_people</span><br><span class="line">from emp group by job,sal1) as king group by job) as KING  </span><br><span class="line">left join </span><br><span class="line">(</span><br><span class="line">select </span><br><span class="line">(ifnull((sal + comm) , sal)) as sal1,</span><br><span class="line">job,</span><br><span class="line">count(*) as total_people</span><br><span class="line">from emp group by job,sal1) as yu  </span><br><span class="line">on KING.tjob = yu.job and yu.sal1 = KING.max_sal or yu.sal1 = KING.min_sal; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-4"><a href="#2-4" class="headerlink" title="2"></a>2</h3><ul>
<li>第二种方法 ， 我们所采用的是union</li>
<li>而不是连接</li>
<li>我们先获取 每种工作的 最高工资 和最低工资 以及工作种类 ，以及总共人数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">               max(ifnull((sal + comm) , sal)) as sal_max,</span><br><span class="line">               min(ifnull((sal + comm) , sal)) as sal_min,</span><br><span class="line">               job,</span><br><span class="line">               count(*) as total_people</span><br><span class="line">               from emp group by job;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>然后我们现在要做的就是统计人数了</li>
<li>我们要先判断他的最大工资和11最小工资是不是相等</li>
<li>因为相等的话，他会默认把一个人分最大，一个人分最小</li>
<li>所以要分开</li>
<li>下面就是如果最大工资和最小工资相等的时候的做法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">total_people as max_people ,(sal_max - sal_max) as min_people,job,sal_max,sal_min</span><br><span class="line">from(select </span><br><span class="line">max(ifnull((sal + comm) , sal)) as sal_max,</span><br><span class="line">min(ifnull((sal + comm) , sal)) as sal_min,</span><br><span class="line">job,</span><br><span class="line">count(*) as total_people</span><br><span class="line">from emp group by job)  as king  group  by job having sal_max = sal_min;</span><br></pre></td></tr></table></figure>


<ul>
<li>下面是不相等的时候</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">count(sal_max) as max_people,count(sal_min) as min_people,job,sal_max,sal_min</span><br><span class="line">from(select </span><br><span class="line">max(ifnull((sal + comm) , sal)) as sal_max,</span><br><span class="line">min(ifnull((sal + comm) , sal)) as sal_min,</span><br><span class="line">job,</span><br><span class="line">count(*) as total_people</span><br><span class="line">from emp group by job)  as king  group  by job having sal_max != sal_min</span><br></pre></td></tr></table></figure>


<ul>
<li>我这里是用的<code>having</code> ， 因为我把条件放在<code>group by</code>后面了 ，这两个也可用where的不过要放在<code>group by</code>之前</li>
<li>接下来，我们用union就可以 ， 因为 我把他们的别名起的一样 ，而且列也能对的上</li>
<li>我们就可以直接用union了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">count(sal_max) as max_people,count(sal_min) as min_people,job,sal_max,sal_min</span><br><span class="line">from(select </span><br><span class="line">max(ifnull((sal + comm) , sal)) as sal_max,</span><br><span class="line">min(ifnull((sal + comm) , sal)) as sal_min,</span><br><span class="line">job,</span><br><span class="line">count(*) as total_people</span><br><span class="line">from emp group by job)  as king where sal_max != sal_min group  by job </span><br><span class="line">union</span><br><span class="line">select </span><br><span class="line">total_people as max_people ,(sal_max - sal_max) as min_people,job,sal_max,sal_min</span><br><span class="line">from(select </span><br><span class="line">max(ifnull((sal + comm) , sal)) as sal_max,</span><br><span class="line">min(ifnull((sal + comm) , sal)) as sal_min,</span><br><span class="line">job,</span><br><span class="line">count(*) as total_people</span><br><span class="line">from emp group by job)  as king  group  by job having sal_max = sal_min;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第七题的附加题"><a href="#第七题的附加题" class="headerlink" title="第七题的附加题"></a>第七题的附加题</h2><ul>
<li>找出最高的工资 最低工资 以及人数 ，职业</li>
<li>这个是我没读题的时候 ，看错题意了 ，结果做出个这么个玩意 ，姑且也当作一个题把。</li>
<li>条件 ： 所有工作中 ，<code>最高工资</code> , <code>最低工资</code> ， <code>人数</code></li>
</ul>
<h3 id="1-6"><a href="#1-6" class="headerlink" title="1"></a>1</h3><ul>
<li>对于这个问题 ， 我们要先找到数据源 ，就是说，我们现在需要最大工资 和最小工资 ，那么为我们要先搞出这样有一个表</li>
<li><code>select max(ifnull((sal + comm) , sal)) as max_sal, min(coalesce((sal + comm) , sal)) as min_sal,count(*) from emp ;</code></li>
<li>这个是统计所有工作中的最大和最小工资</li>
<li>然后我们要找出人数以及职业</li>
<li>这相当于我们现在有了最大最小的筛选条件 ，去有工资和职业，以及人数的表中筛选就好</li>
<li>接下来，我们就要创建一个表有工资和职业，以及人数</li>
<li><code>select job, (ifnull((sal + comm) , sal)) as sal1,count(sal) as total_people from emp  group by sal1 , job;</code></li>
<li>接下来我们就要进行筛选了 ， 最简单的筛选就是把两个表链接上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">sal1,</span><br><span class="line">job,</span><br><span class="line">total_people</span><br><span class="line">from(select max(ifnull((sal + comm) , sal)) as max_sal, min(coalesce((sal + comm) , sal))  as min_sal from emp ) as king </span><br><span class="line"></span><br><span class="line">left join </span><br><span class="line"></span><br><span class="line">(select job, (ifnull((sal + comm) , sal)) as sal1,count(sal) as total_people from emp  group by sal1 , job) as kk </span><br><span class="line">on max_sal = sal1 or min_sal =sal1 ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>但是做到这里其实还可以进行优化 ， 我们可以不用链接 ， 但是上述链接是小表驱动大表的，我们也可以反过来</li>
<li>但是用in的时候我们不能用一列去匹配两列</li>
<li>因为我们最开始的数据源，分出来的是两列</li>
<li>现在我们要通过别名，把两列变成一列</li>
<li><code>select max(ifnull((sal + comm) , sal)) as sal from emp union select min(coalesce((sal + comm) , sal))  as sal from emp;</code></li>
<li>然后我们就可以用where进行匹配了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">sal1,</span><br><span class="line">job,</span><br><span class="line">total_people</span><br><span class="line">from(select job, (ifnull((sal + comm) , sal)) as sal1,count(sal) as total_people from emp  group by sal1 , job) as kk </span><br><span class="line">where sal1 in (select max(ifnull((sal + comm) , sal)) as sal from emp union select min(coalesce((sal + comm) , sal))  as sal from emp);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这里的in也可以用等号替代 ，只不过如果是等号，那么你后面的条件要拆开 ，而且 中间要用or</li>
</ul>
<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><ul>
<li>列出薪金 高于 公司平均薪金的所有员工号，员工姓名，所在部门名称，上级领导，工资，工资等级</li>
<li>条件 ： <code>薪金</code>高于 <code>平均薪金</code> ， <code>工资等级</code> ，<code>部门名称</code> </li>
<li>通过以上条件我们可知 ，这个是三个表都要用到的</li>
</ul>
<h3 id="1-7"><a href="#1-7" class="headerlink" title="1"></a>1</h3><ul>
<li>老样子 ： 我们要先获取基本的数据源</li>
<li><code>select avg(sal) as sal_avg from emp</code></li>
<li>上述是获取平均薪金 ，是要作为我们的判断条件的</li>
<li>然后求出薪金大于平均薪金的 进行初步筛选</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">deptno,</span><br><span class="line">sal,</span><br><span class="line">mgr</span><br><span class="line">from emp where sal &gt; (select </span><br><span class="line">avg(sal)</span><br><span class="line">from emp);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>接下来我们要把初步筛选完成的表 和 部门表联合起来 ，原因是 部门表有部门编号作为连接点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select</span><br><span class="line">*</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">deptno as deptno1,</span><br><span class="line">sal,</span><br><span class="line">mgr</span><br><span class="line">from emp where sal &gt; (select </span><br><span class="line">avg(sal)</span><br><span class="line">from emp)) as Oavg_table left join dept on Oavg_table.deptno1=dept.deptno; </span><br></pre></td></tr></table></figure>


<ul>
<li>现在除了工资等级 ，和工资，其余的我们全都有了、</li>
<li>接下来，我们先加上工资 ，然后根据工资进行判断等级</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">(sal + commchange) as earn</span><br><span class="line">from(</span><br><span class="line">select</span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">ifnull(comm , 0) as commchange</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">deptno as deptno1,</span><br><span class="line">sal,</span><br><span class="line">mgr</span><br><span class="line">from emp where sal &gt; (select </span><br><span class="line">avg(sal)</span><br><span class="line">from emp)) as Oavg_table left join dept on Oavg_table.deptno1=dept.deptno) as setlist;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>接下来，我们要加上工资等级</li>
<li>在这里，我就偷个懒 因为平均薪金是2200多，那么你工资必不可能比这个少</li>
<li>那么工资等级也就不会是3及以下</li>
<li>一般的话是条件都要判断的 ，我这里就偷个懒</li>
<li>接下来，我们设置筛选条件 ，  因为工资等级没有能和别的表联合 ，或者union的列 ，那么我们只能一个个判断了</li>
<li>我们先判断大于3000的 并给与工资等级</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">earn,</span><br><span class="line">((empno + 5) - empno) as level</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">(sal + commchange) as earn</span><br><span class="line">from(</span><br><span class="line">select</span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">ifnull(comm , 0) as commchange</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">deptno as deptno1,</span><br><span class="line">sal,</span><br><span class="line">mgr</span><br><span class="line">from emp where sal &gt; (select </span><br><span class="line">avg(sal)</span><br><span class="line">from emp)) as Oavg_table left join dept on Oavg_table.deptno1=dept.deptno) as setlist) as sal_tables where earn &gt;3000;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>接下来是小于3000的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">earn,</span><br><span class="line">((empno + 4) - empno) as level</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">(sal + commchange) as earn</span><br><span class="line">from(</span><br><span class="line">select</span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">ifnull(comm , 0) as commchange</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">deptno as deptno1,</span><br><span class="line">sal,</span><br><span class="line">mgr</span><br><span class="line">from emp where sal &gt; (select </span><br><span class="line">avg(sal)</span><br><span class="line">from emp)) as Oavg_table left join dept on Oavg_table.deptno1=dept.deptno) as setlist) as sal_tables where earn &gt;2000 and earn &lt;=3000;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>注意我这里是偷懒了，没有判断2000和更低的，原因在上面 ，如果想判断和上面两个一样</li>
<li>接下来 我们用unio  把他们链接到一起</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">earn,</span><br><span class="line">((empno + 5) - empno) as level</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">(sal + commchange) as earn</span><br><span class="line">from(</span><br><span class="line">select</span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">ifnull(comm , 0) as commchange</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">deptno as deptno1,</span><br><span class="line">sal,</span><br><span class="line">mgr</span><br><span class="line">from emp where sal &gt; (select </span><br><span class="line">avg(sal)</span><br><span class="line">from emp)) as Oavg_table left join dept on Oavg_table.deptno1=dept.deptno) as setlist) as sal_tables where earn &gt;3000</span><br><span class="line">union</span><br><span class="line">select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">earn,</span><br><span class="line">((empno + 4) - empno) as level</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">(sal + commchange) as earn</span><br><span class="line">from(</span><br><span class="line">select</span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">sal,</span><br><span class="line">mgr,</span><br><span class="line">deptno1,</span><br><span class="line">dname,</span><br><span class="line">ifnull(comm , 0) as commchange</span><br><span class="line">from(select </span><br><span class="line">comm,</span><br><span class="line">empno,</span><br><span class="line">ename,</span><br><span class="line">deptno as deptno1,</span><br><span class="line">sal,</span><br><span class="line">mgr</span><br><span class="line">from emp where sal &gt; (select </span><br><span class="line">avg(sal)</span><br><span class="line">from emp)) as Oavg_table left join dept on Oavg_table.deptno1=dept.deptno) as setlist) as sal_tables where earn &gt;2000 and earn &lt;=3000;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>就可以了 ，上面的我做法是我没动脑子，直接一点点搞出来的</li>
</ul>
<h3 id="2-5"><a href="#2-5" class="headerlink" title="2"></a>2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">select empno,ename,dname,sal,mgr,ifnull((sal + comm) , sal) as earn , (sal + 5  - sal) as  level from (select * from emp where sal &gt; (select avg(sal) from  emp))  as king left join dept on king.deptno=dept.deptno having earn &gt;  3000</span><br><span class="line">union </span><br><span class="line">select empno,ename,dname,sal,mgr,ifnull((sal + comm) , sal) as earn , (sal + 4  - sal) as  level from (select * from emp where sal &gt; (select avg(sal) from  emp))  as king left join dept on king.deptno=dept.deptno having earn &lt;= 3000;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2"><a href="#3-2" class="headerlink" title="3"></a>3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">king.ename,</span><br><span class="line">king.empno,</span><br><span class="line">e1.ename as leader,</span><br><span class="line">king.earn,</span><br><span class="line">case when earn Between 700 and 1200 then 1</span><br><span class="line">     when earn Between 1200 and 1400 then 2</span><br><span class="line">     when earn Between 1400 and 2000 then 3</span><br><span class="line">     when earn Between 2000 and 3000 then 4</span><br><span class="line">     when earn Between 3000 and 9990 then 5</span><br><span class="line">     end</span><br><span class="line">as sallevel</span><br><span class="line">from (</span><br><span class="line">  select ename , empno , deptno , ifnull((sal + comm),sal) as earn ,mgr </span><br><span class="line">  from emp</span><br><span class="line">  where sal &gt; (</span><br><span class="line">    select avg(sal)</span><br><span class="line">    from emp</span><br><span class="line">  )</span><br><span class="line">) as king </span><br><span class="line">left join dept on king.deptno=dept.deptno </span><br><span class="line">left join emp e1 on king.mgr = e1.empno;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">// 最好不用 ，因为笛卡尔积 会造成数据膨胀</span><br><span class="line">   select </span><br><span class="line">   king.ename,</span><br><span class="line">   king.empno,</span><br><span class="line">   e1.ename as leader,</span><br><span class="line">   king.earn,</span><br><span class="line">   s.grade</span><br><span class="line">   as sallevel</span><br><span class="line">   from (</span><br><span class="line">     select ename , empno , deptno , ifnull((sal + comm),sal) as earn ,mgr </span><br><span class="line">     from emp</span><br><span class="line">     where sal &gt; (</span><br><span class="line">       select avg(sal)</span><br><span class="line">       from emp</span><br><span class="line">     )</span><br><span class="line">   ) as king </span><br><span class="line">   left join dept on king.deptno=dept.deptno </span><br><span class="line">   left join (</span><br><span class="line">     select empno,</span><br><span class="line">     ename</span><br><span class="line">     from emp</span><br><span class="line">   ) e1 on king.mgr = e1.empno</span><br><span class="line">   cross join salgrade as s where earn Between losal and hisal ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">king.ename,</span><br><span class="line">king.empno,</span><br><span class="line">e1.ename as leader,</span><br><span class="line">king.earn,</span><br><span class="line">s.grade</span><br><span class="line">as sallevel</span><br><span class="line">from (</span><br><span class="line">  select ename , empno , deptno , ifnull((sal + comm),sal) as earn ,mgr </span><br><span class="line">  from emp</span><br><span class="line">  where sal &gt; (</span><br><span class="line">    select avg(sal)</span><br><span class="line">    from emp</span><br><span class="line">  )</span><br><span class="line">) as king </span><br><span class="line">left join dept on king.deptno=dept.deptno </span><br><span class="line">left join (</span><br><span class="line">  select empno,</span><br><span class="line">  ename</span><br><span class="line">  from emp</span><br><span class="line">) e1 on king.mgr = e1.empno</span><br><span class="line">left join salgrade as s on earn &gt;= losal and earn &lt;= hisal;</span><br></pre></td></tr></table></figure>


<h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><ul>
<li>列出薪金  高于  在各自部门工作的员工的平均薪金的员工姓名和薪金、部门名称</li>
<li>条件 ： 各个部门，<code>薪金</code>高于<code>各个部门</code>的<code>平均薪金</code></li>
</ul>
<h3 id="1-8"><a href="#1-8" class="headerlink" title="1"></a>1</h3><ul>
<li><p>我们可以先获取薪金，以及部门编号 ，并且按照他们进行划分</p>
</li>
<li><p>因为题目中主要要求的就是部门以及薪金</p>
</li>
<li><p><code>select  sal ,deptno from emp group by sal , deptno;</code></p>
</li>
<li><p>接下来我们求各个部门的平均薪金</p>
</li>
<li><p><code>select avg(sal) as sal_avg, deptno from (select  sal ,deptno from emp group by sal , deptno) as king group by deptno;</code></p>
</li>
<li><p>其实上述两部可以通过一步完成</p>
</li>
<li><p><code>select avg(sal) ,deptno from emp group by deptno;</code></p>
</li>
<li><p>就是不动脑子和动脑子的区别</p>
</li>
<li><p>不过一般没思路的时候把数据源写上，可能会有奇效</p>
</li>
<li><p>接下来找出高于平均薪金的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select</span><br><span class="line">*</span><br><span class="line">from (select avg(sal) as sal_avg, deptno from (select  sal ,deptno from emp group by sal , deptno) as king group by deptno) as avg_basic left join emp</span><br><span class="line">on emp.deptno=avg_basic.deptno  and emp.sal &gt; avg_basic.sal_avg;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个是用左连接来实现的</p>
</li>
<li><p>其实还可以要用where来实现 , 不过比较复杂 ，就不在这里写了</p>
</li>
<li><p>接下来我们就合并部门输出就可以了</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select  * </span><br><span class="line">from  </span><br><span class="line">(select</span><br><span class="line">*</span><br><span class="line">from (select avg(sal) as sal_avg, deptno as deptno1 from (select  sal ,deptno from emp group by sal , deptno) as king group by deptno) as avg_basic left join emp</span><br><span class="line">on emp.deptno=avg_basic.deptno1  and emp.sal &gt; avg_basic.sal_avg) as basicinfo left  join dept on basicinfo.deptno1=dept.deptno;</span><br></pre></td></tr></table></figure>


<ul>
<li>这个可以用in替代</li>
<li>代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select  * </span><br><span class="line">from  </span><br><span class="line">(select</span><br><span class="line">*</span><br><span class="line">from (select avg(sal) as sal_avg, deptno as deptno1 from (select  sal ,deptno from emp group by sal , deptno) as king group by deptno) as avg_basic left join emp</span><br><span class="line">on emp.deptno=avg_basic.deptno1  and emp.sal &gt; avg_basic.sal_avg) as basicinfo where basicinfo.deptno1 in (select deptno from dept);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>完结撒花！</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>我们做题不可以改变源头数据 ， 就是数据库里的数据</li>
<li>没有思路的时候可以写题中要的数据 ， 题是做出来的，不是看出来的</li>
<li>写了第一行 ，自然就会有后面的代码，只是看你愿不愿意开始</li>
<li>有思路自然是按照自己的思路去做</li>
<li>在有些时候 left join 可以替换成  in  但是这样的替换是在 没有大于小于判定的时候</li>
<li>如果有大于小于判定 ，则要替换要用where</li>
<li>进行in的时候如果出现一行对多行的情况 ，</li>
<li>不妨把多行化成一行 ，用union</li>
<li>或者把多余的行删除</li>
<li>对于分组 ， 我们如果没有思路可以把题中要的东西先分组，然后后面再进行分组</li>
<li>比如 ： <code>select avg(sal) as sal_avg, deptno from (select  sal ,deptno from emp group by sal , deptno) as king group by deptno;</code></li>
<li>和 <code>select avg(sal) ,deptno from emp group by deptno;</code></li>
<li>是一样的，但是对于没有思路的时候来说，还是上面一个更好一点，下面是块，可是有时候会忘，</li>
<li>对于几乎所有的sql题目</li>
<li>几乎没有题通过 以下做不出来的 </li>
<li>就是简单方法和笨方法的区别  ， 笨方法虽然笨 ，可是实用性强 ，简单虽然简单 ，可是难想</li>
<li>而且笨方法的速度其实主要取决于你的打字速度</li>
<li>先筛选数据 <code>group by</code> , <code>where</code> , <code>avg ,sum ,max ,min..</code> …</li>
<li>再筛选数据 <code>group by</code> , <code>where</code> , <code>avg ,sum ,max ,min..</code> …</li>
<li>通过链接的方式链接 <code>union</code> , <code>union all</code> ,<code> join</code>..</li>
<li>判断条件 <code>in</code> , <code>where</code> ….</li>
<li>注意 ： 组函数不可以进行嵌套使用 <code>where max(sal) =1</code> 这样就是不可以的 ，相应的 在in 里也不可以<br> ， 在组函数里也不可以  ，如果非要这样操作 ，那么你要 嵌套表 , 加上别名才可以</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select</span><br><span class="line">*</span><br><span class="line">from(select</span><br><span class="line">max(sal) as max_sal</span><br><span class="line">from emp</span><br><span class="line">) where max_sal =1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上述那样才可以</li>
<li>where 和 having是有区别的 作用域的区别，以及位置的区别 ，但是语法是基本上完全一样的 in ， like 之类的 </li>
<li>where被放在group之前 ，havin 是在group之后</li>
<li>例子 ：  </li>
<li><code>select sal as sal1 ,comm  as comm1 from emp where sal1 &gt; 1500; </code></li>
<li><code>select sal as sal1 ,comm  as comm1 from emp where comm1 in (300);</code></li>
<li>这样where是读取不到这个别名的 ，但是having是可以读取到的</li>
<li>原因在于，他们对数据操作的时机不同</li>
<li>having是上面都执行完了 ，才操作</li>
<li>where是和他们一起操作的</li>
<li><code>select sal as sal1 from emp having sal1 &gt;1500;</code></li>
<li><code>select sal as sal1 from emp having sal in (800);</code></li>
<li>这样就可以了</li>
</ul>
<h1 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h1><h2 id="现在运营想要了解复旦大学的每个用户在8月份练习的总题目数和回答正确的题目数情况，请取出相应明细数据，对于在8月份没有练习过的用户，答题数结果返回0"><a href="#现在运营想要了解复旦大学的每个用户在8月份练习的总题目数和回答正确的题目数情况，请取出相应明细数据，对于在8月份没有练习过的用户，答题数结果返回0" class="headerlink" title="现在运营想要了解复旦大学的每个用户在8月份练习的总题目数和回答正确的题目数情况，请取出相应明细数据，对于在8月份没有练习过的用户，答题数结果返回0"></a>现在运营想要了解复旦大学的每个用户在8月份练习的总题目数和回答正确的题目数情况，请取出相应明细数据，对于在8月份没有练习过的用户，答题数结果返回0</h2><ul>
<li>数据源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">drop table if exists `user_profile`;</span><br><span class="line">drop table if  exists `question_practice_detail`;</span><br><span class="line">drop table if  exists `question_detail`;</span><br><span class="line">CREATE TABLE `user_profile` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `device_id` int(11) NOT NULL,</span><br><span class="line">  `gender` varchar(14) NOT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `university` varchar(32) NOT NULL,</span><br><span class="line">  `gpa` float DEFAULT NULL,</span><br><span class="line">  `active_days_within_30` int(11) DEFAULT NULL,</span><br><span class="line">  `question_cnt` int(11) DEFAULT NULL,</span><br><span class="line">  `answer_cnt` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">CREATE TABLE `question_practice_detail` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`device_id` int NOT NULL,</span><br><span class="line">`question_id`int NOT NULL,</span><br><span class="line">`result` varchar(32) NOT NULL,</span><br><span class="line">`date` date NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE `question_detail` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`question_id`int NOT NULL,</span><br><span class="line">`difficult_level` varchar(32) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO user_profile VALUES(1,2138,&#x27;male&#x27;,21,&#x27;北京大学&#x27;,3.4,7,2,12);</span><br><span class="line">INSERT INTO user_profile VALUES(2,3214,&#x27;male&#x27;,null,&#x27;复旦大学&#x27;,4.0,15,5,25);</span><br><span class="line">INSERT INTO user_profile VALUES(3,6543,&#x27;female&#x27;,20,&#x27;北京大学&#x27;,3.2,12,3,30);</span><br><span class="line">INSERT INTO user_profile VALUES(4,2315,&#x27;female&#x27;,23,&#x27;浙江大学&#x27;,3.6,5,1,2);</span><br><span class="line">INSERT INTO user_profile VALUES(5,5432,&#x27;male&#x27;,25,&#x27;山东大学&#x27;,3.8,20,15,70);</span><br><span class="line">INSERT INTO user_profile VALUES(6,2131,&#x27;male&#x27;,28,&#x27;山东大学&#x27;,3.3,15,7,13);</span><br><span class="line">INSERT INTO user_profile VALUES(7,4321,&#x27;male&#x27;,28,&#x27;复旦大学&#x27;,3.6,9,6,52);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(1,2138,111,&#x27;wrong&#x27;,&#x27;2021-05-03&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(2,3214,112,&#x27;wrong&#x27;,&#x27;2021-05-09&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(3,3214,113,&#x27;wrong&#x27;,&#x27;2021-06-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(4,6543,111,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(5,2315,115,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(6,2315,116,&#x27;right&#x27;,&#x27;2021-08-14&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(7,2315,117,&#x27;wrong&#x27;,&#x27;2021-08-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(8,3214,112,&#x27;wrong&#x27;,&#x27;2021-05-09&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(9,3214,113,&#x27;wrong&#x27;,&#x27;2021-08-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(10,6543,111,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(11,2315,115,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(12,2315,116,&#x27;right&#x27;,&#x27;2021-08-14&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(13,2315,117,&#x27;wrong&#x27;,&#x27;2021-08-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(14,3214,112,&#x27;wrong&#x27;,&#x27;2021-08-16&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(15,3214,113,&#x27;wrong&#x27;,&#x27;2021-08-18&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(16,6543,111,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(1,111,&#x27;hard&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(2,112,&#x27;medium&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(3,113,&#x27;easy&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(4,115,&#x27;easy&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(5,116,&#x27;medium&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(6,117,&#x27;easy&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h2><ul>
<li>因为要用大于8月的 ， 所以 直接 用month就好</li>
<li>用if判断是不是正确</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">profile.device_id,</span><br><span class="line">university,</span><br><span class="line">count(question_id) as total,</span><br><span class="line">sum(if(result = &#x27;right&#x27; , 1 ,0)) as right_question_cnt</span><br><span class="line">from user_profile as profile left join question_practice_detail as detail on profile.device_id=detail.device_id  and month(detail.date)=8 where university = &#x27;复旦大学&#x27; group by profile.device_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select </span><br><span class="line">device_id,</span><br><span class="line">university,</span><br><span class="line">sum(right_question_cnt + wrong_question_cnt) as question_cnt,</span><br><span class="line">sum(right_question_cnt) as right_question_cnt</span><br><span class="line">from(select </span><br><span class="line">device_id,</span><br><span class="line">university,</span><br><span class="line">ifnull((right_question_cnt) , 0) as right_question_cnt,</span><br><span class="line">ifnull((wrong_question_cnt) , 0) as wrong_question_cnt,</span><br><span class="line">ifnull((date) , 0) as date</span><br><span class="line">from user_profile left join (</span><br><span class="line">select device_id as ID,count(*) as right_question_cnt ,date , (device_id - device_id) as wrong_question_cnt from question_practice_detail where result  = &quot;right&quot; group by device_id ,date</span><br><span class="line">union</span><br><span class="line">select device_id,(device_id - device_id) as right_question_cnt,date ,count(*) as wrong_question_cnt  from question_practice_detail where result  = &quot;wrong&quot; group by device_id ,date) as king on king.ID = user_profile.device_id where university = &quot;复旦大学&quot;) as king    </span><br><span class="line">where date &gt; &#x27;2021-08-00&#x27; or date = 0  group by device_id , university ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>链接后面的on后面 ，能加上and 进行条件筛选</li>
<li>month（date） 可以直接获取这个日期的月份</li>
<li>if（xxx , sss , www） : if表达式 ： 如果前一个为真 ，则执行sss ，如果不是真 则 www</li>
<li>要看清题意</li>
</ul>
<h2 id="现在运营想要了解浙江大学的用户在不同难度题目下答题的正确率情况，请取出相应数据，并按照准确率升序输出。"><a href="#现在运营想要了解浙江大学的用户在不同难度题目下答题的正确率情况，请取出相应数据，并按照准确率升序输出。" class="headerlink" title="现在运营想要了解浙江大学的用户在不同难度题目下答题的正确率情况，请取出相应数据，并按照准确率升序输出。"></a>现在运营想要了解浙江大学的用户在不同难度题目下答题的正确率情况，请取出相应数据，并按照准确率升序输出。</h2><ul>
<li>数据源<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">drop table if exists `user_profile`;</span><br><span class="line">drop table if  exists `question_practice_detail`;</span><br><span class="line">drop table if  exists `question_detail`;</span><br><span class="line">CREATE TABLE `user_profile` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `device_id` int(11) NOT NULL,</span><br><span class="line">  `gender` varchar(14) NOT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `university` varchar(32) NOT NULL,</span><br><span class="line">  `gpa` float DEFAULT NULL,</span><br><span class="line">  `active_days_within_30` int(11) DEFAULT NULL,</span><br><span class="line">  `question_cnt` int(11) DEFAULT NULL,</span><br><span class="line">  `answer_cnt` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">CREATE TABLE `question_practice_detail` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`device_id` int NOT NULL,</span><br><span class="line">`question_id`int NOT NULL,</span><br><span class="line">`result` varchar(32) NOT NULL,</span><br><span class="line">`date` date NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE `question_detail` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`question_id`int NOT NULL,</span><br><span class="line">`difficult_level` varchar(32) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO user_profile VALUES(1,2138,&#x27;male&#x27;,21,&#x27;北京大学&#x27;,3.4,7,2,12);</span><br><span class="line">INSERT INTO user_profile VALUES(2,3214,&#x27;male&#x27;,null,&#x27;复旦大学&#x27;,4.0,15,5,25);</span><br><span class="line">INSERT INTO user_profile VALUES(3,6543,&#x27;female&#x27;,20,&#x27;北京大学&#x27;,3.2,12,3,30);</span><br><span class="line">INSERT INTO user_profile VALUES(4,2315,&#x27;female&#x27;,23,&#x27;浙江大学&#x27;,3.6,5,1,2);</span><br><span class="line">INSERT INTO user_profile VALUES(4,2316,&#x27;female&#x27;,23,&#x27;浙江大学&#x27;,3.6,5,1,2);</span><br><span class="line">INSERT INTO user_profile VALUES(5,5432,&#x27;male&#x27;,25,&#x27;山东大学&#x27;,3.8,20,15,70);</span><br><span class="line">INSERT INTO user_profile VALUES(6,2131,&#x27;male&#x27;,28,&#x27;山东大学&#x27;,3.3,15,7,13);</span><br><span class="line">INSERT INTO user_profile VALUES(7,4321,&#x27;male&#x27;,28,&#x27;复旦大学&#x27;,3.6,9,6,52);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(1,2138,111,&#x27;wrong&#x27;,&#x27;2021-05-03&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(2,3214,112,&#x27;wrong&#x27;,&#x27;2021-05-09&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(3,3214,113,&#x27;wrong&#x27;,&#x27;2021-06-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(4,6543,111,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(5,2315,115,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(6,2315,116,&#x27;right&#x27;,&#x27;2021-08-14&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(7,2315,117,&#x27;wrong&#x27;,&#x27;2021-08-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(8,3214,112,&#x27;wrong&#x27;,&#x27;2021-05-09&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(9,3214,113,&#x27;wrong&#x27;,&#x27;2021-08-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(10,6543,111,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(11,2315,115,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(12,2315,116,&#x27;right&#x27;,&#x27;2021-08-14&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(13,2315,117,&#x27;wrong&#x27;,&#x27;2021-08-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(14,3214,112,&#x27;wrong&#x27;,&#x27;2021-08-16&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(15,3214,113,&#x27;wrong&#x27;,&#x27;2021-08-18&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(16,6543,111,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(1,111,&#x27;hard&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(2,112,&#x27;medium&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(3,113,&#x27;easy&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(4,115,&#x27;easy&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(5,116,&#x27;medium&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(6,117,&#x27;easy&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select</span><br><span class="line">difficult_level,</span><br><span class="line">(sum(if(result = &#x27;right&#x27; , 1 ,0))/count(up.question_id)) as Rate</span><br><span class="line">from</span><br><span class="line">(select * from question_practice_detail where device_id in (select device_id from user_profile where university = &quot;浙江大学&quot;)) as up left join question_detail on up.question_id = question_detail.question_id group by difficult_level order by Rate;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>优化方法</li>
<li>把中间筛选浙江大学的地方换成链接 ，并且在链接的时候进行筛选 ， 就会快上给 5-6ms</li>
<li>如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SELECT qd.difficult_level,(</span><br><span class="line">SUM(CASE WHEN qpd.result=&#x27;right&#x27; THEN 1</span><br><span class="line">	ELSE 0</span><br><span class="line">	END</span><br><span class="line">)/COUNT(qpd.result)</span><br><span class="line">) correct_rated</span><br><span class="line">FROM user_profile up,</span><br><span class="line">     question_practice_detail qpd,</span><br><span class="line">     question_detail qd</span><br><span class="line">WHERE     up.university=&#x27;浙江大学&#x27;</span><br><span class="line">      AND up.device_id=qpd.device_id</span><br><span class="line">      AND qpd.question_id=qd.question_id</span><br><span class="line">GROUP BY  qd.difficult_level</span><br><span class="line">order by correct_rated asc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="现在运营想要查看用户在某天刷题后第二天还会再来刷题的平均概率。请你取出相应数据。"><a href="#现在运营想要查看用户在某天刷题后第二天还会再来刷题的平均概率。请你取出相应数据。" class="headerlink" title="现在运营想要查看用户在某天刷题后第二天还会再来刷题的平均概率。请你取出相应数据。"></a>现在运营想要查看用户在某天刷题后第二天还会再来刷题的平均概率。请你取出相应数据。</h2><ul>
<li>数据源<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">drop table if exists `user_profile`;</span><br><span class="line">drop table if  exists `question_practice_detail`;</span><br><span class="line">drop table if  exists `question_detail`;</span><br><span class="line">CREATE TABLE `user_profile` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `device_id` int(11) NOT NULL,</span><br><span class="line">  `gender` varchar(14) NOT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `university` varchar(32) NOT NULL,</span><br><span class="line">  `gpa` float DEFAULT NULL,</span><br><span class="line">  `active_days_within_30` int(11) DEFAULT NULL,</span><br><span class="line">  `question_cnt` int(11) DEFAULT NULL,</span><br><span class="line">  `answer_cnt` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">CREATE TABLE `question_practice_detail` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`device_id` int NOT NULL,</span><br><span class="line">`question_id`int NOT NULL,</span><br><span class="line">`result` varchar(32) NOT NULL,</span><br><span class="line">`date` date NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE `question_detail` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`question_id`int NOT NULL,</span><br><span class="line">`difficult_level` varchar(32) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO user_profile VALUES(1,2138,&#x27;male&#x27;,21,&#x27;北京大学&#x27;,3.4,7,2,12);</span><br><span class="line">INSERT INTO user_profile VALUES(2,3214,&#x27;male&#x27;,null,&#x27;复旦大学&#x27;,4.0,15,5,25);</span><br><span class="line">INSERT INTO user_profile VALUES(3,6543,&#x27;female&#x27;,20,&#x27;北京大学&#x27;,3.2,12,3,30);</span><br><span class="line">INSERT INTO user_profile VALUES(4,2315,&#x27;female&#x27;,23,&#x27;浙江大学&#x27;,3.6,5,1,2);</span><br><span class="line">INSERT INTO user_profile VALUES(5,5432,&#x27;male&#x27;,25,&#x27;山东大学&#x27;,3.8,20,15,70);</span><br><span class="line">INSERT INTO user_profile VALUES(6,2131,&#x27;male&#x27;,28,&#x27;山东大学&#x27;,3.3,15,7,13);</span><br><span class="line">INSERT INTO user_profile VALUES(7,4321,&#x27;male&#x27;,28,&#x27;复旦大学&#x27;,3.6,9,6,52);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(1,2138,111,&#x27;wrong&#x27;,&#x27;2021-05-03&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(2,3214,112,&#x27;wrong&#x27;,&#x27;2021-05-09&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(3,3214,113,&#x27;wrong&#x27;,&#x27;2021-06-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(4,6543,111,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(5,2315,115,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(6,2315,116,&#x27;right&#x27;,&#x27;2021-08-14&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(7,2315,117,&#x27;wrong&#x27;,&#x27;2021-08-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(8,3214,112,&#x27;wrong&#x27;,&#x27;2021-05-09&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(9,3214,113,&#x27;wrong&#x27;,&#x27;2021-08-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(10,6543,111,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(11,2315,115,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(12,2315,116,&#x27;right&#x27;,&#x27;2021-08-14&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(13,2315,117,&#x27;wrong&#x27;,&#x27;2021-08-15&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(14,3214,112,&#x27;wrong&#x27;,&#x27;2021-08-16&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(15,3214,113,&#x27;wrong&#x27;,&#x27;2021-08-18&#x27;);</span><br><span class="line">INSERT INTO question_practice_detail VALUES(16,6543,111,&#x27;right&#x27;,&#x27;2021-08-13&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(1,111,&#x27;hard&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(2,112,&#x27;medium&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(3,113,&#x27;easy&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(4,115,&#x27;easy&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(5,116,&#x27;medium&#x27;);</span><br><span class="line">INSERT INTO question_detail VALUES(6,117,&#x27;easy&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">select avg(if(datediff(date2, date1)=1, 1, 0)) as avg_ret</span><br><span class="line">from (</span><br><span class="line">    select</span><br><span class="line">        distinct device_id,</span><br><span class="line">        date as date1,</span><br><span class="line">        lead(date) over (partition by device_id order by date) as date2</span><br><span class="line">    from (</span><br><span class="line">        select distinct device_id, date</span><br><span class="line">        from question_practice_detail</span><br><span class="line">    ) as uniq_id_date</span><br><span class="line">) as id_last_next_date</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>作业</category>
      </categories>
  </entry>
  <entry>
    <title>11-19作业</title>
    <url>/2022/11/19/%E4%BD%9C%E4%B8%9A11-19/</url>
    <content><![CDATA[<h1 id="通过mapreduce的api统计emp表里的每个工作的人数"><a href="#通过mapreduce的api统计emp表里的每个工作的人数" class="headerlink" title="通过mapreduce的api统计emp表里的每个工作的人数"></a>通过mapreduce的api统计emp表里的每个工作的人数</h1><ul>
<li>数据源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">7369,SMITH,CLERK,7902,1980-12-17 14:00:00,800.00,,20</span><br><span class="line">7499,ALLEN,SALESMAN,7698,1981-02-20 14:00:00,1600.00,300.00,30</span><br><span class="line">7521,WARD,SALESMAN,7698,1981-02-22 14:00:00,1250.00,500.00,30</span><br><span class="line">7566,JONES,MANAGER,7839,1981-04-02 14:00:00,2975.00,,20</span><br><span class="line">7654,MARTIN,SALESMAN,7698,1981-09-28 13:00:00,1250.00,1400.00,30</span><br><span class="line">7698,BLAKE,MANAGER,7839,1981-05-01 13:00:00,2850.00,,30</span><br><span class="line">7782,CLARK,MANAGER,7839,1981-06-09 13:00:00,2450.00,,10</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7839,KING,PRESIDENT,,1981-11-17 14:00:00,5000.00,,10</span><br><span class="line">7844,TURNER,SALESMAN,7698,1981-09-08 13:00:00,1500.00,0.00,30</span><br><span class="line">7876,ADAMS,CLERK,7788,1983-01-12 14:00:00,1100.00,,20</span><br><span class="line">7900,lebulang,CLERK,7698,1981-12-03 14:00:00,950.00,,30</span><br><span class="line">7902,FORD,ANALYST,7566,1981-12-03 14:00:00,3000.00,,20</span><br><span class="line">7934,MILLER,CLERK,7782,1982-01-23 14:00:00,1300.00,,10</span><br><span class="line">7839,KING,PRESIDENT,,1981-11-17 14:00:00,5000.00,,10</span><br><span class="line">7654,MARTIN,SALESMAN,7698,1981-09-28 13:00:00,3200.00,1400.00,30</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line">7788,SCOTT,ANALYST,7566,1982-12-09 14:00:00,3000.00,,20</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中第二列就是工作</p>
</li>
<li><p>代码如下 ：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author sxwang</span><br><span class="line"> * 11 18 14:00</span><br><span class="line"> */</span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * driver</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        String input=&quot;D://emp.txt&quot;;</span><br><span class="line">        String output=&quot;out&quot;;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        //0.todo... 删除目标路径</span><br><span class="line">        FileUtils.deletePath(conf,output);</span><br><span class="line"></span><br><span class="line">        //1.设置 作业名称</span><br><span class="line">        Job job = Job.getInstance(conf, &quot;WCAPP&quot;);</span><br><span class="line">        //2.设置map reduce 执行代码的主类</span><br><span class="line">        job.setJarByClass(test.class);</span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line">        //3.指定 oupput kv类型</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        //4. 设置数据源路径 数据输出路径</span><br><span class="line">        FileInputFormat.addInputPath(job, new Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, new Path(output));</span><br><span class="line">        //5. 提交mr yarn</span><br><span class="line">        System.exit(job.waitForCompletion(true) ? 0 : 1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * mapper</span><br><span class="line">     */</span><br><span class="line">    public static class MyMapper</span><br><span class="line">            extends Mapper&lt;Object, Text, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 1.按照分隔符 进行拆分 每个单词 ，每个单词赋值为1</span><br><span class="line">             * (word ,1)</span><br><span class="line">             */</span><br><span class="line"></span><br><span class="line">            String[] words = value.toString().split(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">            for (String word : words) &#123;</span><br><span class="line">                String[] split = word.split(&quot;,&quot;);</span><br><span class="line">                context.write(new Text(split[2]) ,new IntWritable(1));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * reducer</span><br><span class="line">     */</span><br><span class="line">    public static class MyReducer</span><br><span class="line">            extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         *  (word ,1)</span><br><span class="line">         *</span><br><span class="line">         *  (word,&lt;1,1,1,1&gt;)</span><br><span class="line">         *</span><br><span class="line">         *  1.聚合value</span><br><span class="line">         *</span><br><span class="line">         *  2.写出去</span><br><span class="line">         *  (word ,3)</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            int sum=0;</span><br><span class="line">            for (IntWritable value : values) &#123;</span><br><span class="line">                sum +=Integer.parseInt(value.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,new IntWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>基本概念 ： 把数据先通过map进行etl，然后通过redurce进行数据的整合之类的</li>
<li>最后输出</li>
</ul>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/2022/11/19/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>内网穿透简单来说就是让我们处于局域网的机器或者本地的项目，可以在外部的公网访问</li>
</ul>
<h3 id="常见的内网穿透工具"><a href="#常见的内网穿透工具" class="headerlink" title="常见的内网穿透工具"></a>常见的内网穿透工具</h3><ul>
<li>natapp网站</li>
<li>frp</li>
<li>ngrok</li>
<li>蜻蜓映射</li>
<li>ssh命令</li>
</ul>
<h3 id="natapp"><a href="#natapp" class="headerlink" title="natapp"></a>natapp</h3><ul>
<li>natapp网站 ： 注册账号之后会免费给你送一条隧道，不过临时用可以，不能长久用，</li>
<li>因为隧道名字会被强制更换</li>
<li>而vip隧道就不会强制更换</li>
</ul>
<h3 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h3><ul>
<li>frp是专业的反向代理工具</li>
<li><code>https:github.com/fatedier/frp</code></li>
<li>其中部署也非常简单 ： </li>
<li>frps在云服务器上</li>
<li>而要进行内网穿透的机器运行frpc</li>
<li>再改改配置就ok了</li>
</ul>
<h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><ul>
<li>属于专门做内网穿透的平台，以前是免费的不过最近好像收费了</li>
<li>注册之后我们就可以根据平台上的帮助文档进行配置，</li>
</ul>
<h3 id="蜻蜓映射"><a href="#蜻蜓映射" class="headerlink" title="蜻蜓映射"></a>蜻蜓映射</h3><ul>
<li>同上</li>
</ul>
<h3 id="ssh命令"><a href="#ssh命令" class="headerlink" title="ssh命令"></a>ssh命令</h3><ul>
<li>我们可以通过<code>ssh -R 80:localhost:80 xxxxx@localhost.run</code></li>
<li>进行反向映射端口</li>
<li>xxxx是远程云主机</li>
<li>前面的80是云主机的端口</li>
<li>后面的是本地的端口</li>
<li>这个命令是ssh自带的</li>
</ul>
]]></content>
      <categories>
        <category>杂货技术栈</category>
      </categories>
  </entry>
  <entry>
    <title>签到的制作（后端＋前端）</title>
    <url>/2022/10/19/%E5%88%B6%E4%BD%9C%E7%AD%BE%E5%88%B0/</url>
    <content><![CDATA[<h1 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h1><ul>
<li>Centos7.8</li>
<li>在虚拟机安装好redis，并且可以成功ping通</li>
<li>使用jdk 11</li>
<li>使用idea 2019.3</li>
<li>准备好post man</li>
<li>准备好可以观察redis的软件，比如redisDespoketManger等</li>
</ul>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul>
<li>先打开虚拟机，并开启redis</li>
<li>然后打开idea，创建springboot项目，在插件列表选择 </li>
<li>spring web</li>
<li>spring Data Redis</li>
<li>Lombok</li>
<li>然后在pom文件里添加hutool插件（我们要用到的）</li>
<li>接下来修改application文件，我习惯把他的后缀改成yml</li>
<li>然后在application文件里添加<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    redis:</span><br><span class="line">       # host: 192.168.1.121 #ip地址</span><br><span class="line">        host: 192.168.41.110</span><br><span class="line">        port: 6379 #端口</span><br><span class="line">        password: liuzihan #密码</span><br><span class="line">        timeout: 3000 #超时时间</span><br><span class="line">        database: 0 #第几号数据库</span><br><span class="line">server:</span><br><span class="line">    port: 9999 #这个是程序启动之后的端口号，也就是tomcat插件的端口号</span><br></pre></td></tr></table></figure></li>
<li>ip地址是虚拟机，或者局域网内真实机的ip</li>
</ul>
<h1 id="思考编写方式"><a href="#思考编写方式" class="headerlink" title="思考编写方式"></a>思考编写方式</h1><ul>
<li>我的编写思路是通过redis里的bitMap进行日期的存取</li>
<li>首先在SignDemoApplication的包内创建几个包，分别代表客户端，服务端以及自动启动还有配置文件包，</li>
<li>首先确定的是浏览器页面，原因很简单，网页有强大的动态效果，以及平台的适配能力，而且很美观，比较与传统的GUI要好不少</li>
<li>我的文件层级目录如下</li>
<li><img src="/%5B!%5Bx4XBBd.jpg%5D(https:/s1.ax1x.com/2022/10/29/x4XBBd.jpg)%5D(https:/imgse.com/i/x4XBBd)"></li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>创建config包，然后在包里创建RedisTemplateConfiguration.class</li>
<li>然后写入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line">import com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;ClassName: RedisConfigure&lt;/p &gt;</span><br><span class="line"> * &lt;p&gt;Description: redisTemplate自定义序列化配置，更改其默认序列化器&lt;/p &gt;</span><br><span class="line"> * &lt;p&gt;Date: 2021/10/23&lt;/p &gt;</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisTemplateConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        // 参照StringRedisTemplate内部实现指定序列化器</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        //使用 jackson2jasonRedisSerialize替换默认序列化</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL , JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        //为String类型 key/value 设置序列化</span><br><span class="line">        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        //为hash ；类型 key、value 设置序列化</span><br><span class="line">        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        return redisTemplate;</span><br><span class="line"></span><br><span class="line">       /* redisTemplate.setKeySerializer(keySerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(keySerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(valueSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(valueSerializer());</span><br><span class="line"></span><br><span class="line">        return redisTemplate;*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用Jackson序列化器，key使用字符串</span><br><span class="line">    private RedisSerializer&lt;String&gt; keySerializer() &#123;</span><br><span class="line">        return new StringRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用Jackson序列化器，value使用Object</span><br><span class="line">    private RedisSerializer&lt;Object&gt; valueSerializer() &#123;</span><br><span class="line">        return new GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>这个就是个简单的redis自动序列化类，网上一抓一大把</li>
</ul>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul>
<li>客户端是我们主要想写的地方，就是实现签到，以及获取mac地址等功能的地方</li>
<li>于是我们创建Severdemo包</li>
<li>在这个包下，写入SignSeverce类写上<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import cn.hutool.core.date.DateUtil;</span><br><span class="line">import cn.hutool.core.date.LocalDateTimeUtil;</span><br><span class="line">import cn.hutool.core.net.NetUtil;</span><br><span class="line">import cn.hutool.core.util.StrUtil;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.springframework.data.redis.connection.BitFieldSubCommands;</span><br><span class="line">import org.springframework.data.redis.core.RedisCallback;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Mapper</span><br><span class="line">public class SignService &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line">    /*</span><br><span class="line">     *用户签到可以补签</span><br><span class="line">     * @param UserId</span><br><span class="line">     * @param DataStr</span><br><span class="line">     * */</span><br><span class="line">    public Map&lt;String , Object&gt; doSign(String UserId , String DataStr)&#123;</span><br><span class="line"></span><br><span class="line">        InetAddress inetAddress = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inetAddress = InetAddress.getLocalHost();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种方式：利用hutool工具类中的封装方法获取本机mac地址</span><br><span class="line">        String localMacAddress2 = NetUtil.getMacAddress(inetAddress);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String , Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		// 判断MAc地址和redis中的是不是一样</span><br><span class="line">        if (String.valueOf(redisTemplate.keys(&quot;user:&quot; + UserId + &quot;:*&quot;)).equals(&quot;[]&quot;))&#123;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String MAc = String.valueOf(redisTemplate.keys(&quot;user:&quot; + UserId + &quot;:*&quot;));</span><br><span class="line">            String[] split = MAc.split(&quot;:&quot;);</span><br><span class="line">            if (localMacAddress2.equals(split[2]))&#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result.put(&quot;code&quot; , 404);</span><br><span class="line">                result.put(&quot;message&quot; , &quot;你不是在同一台电脑上进行的签到，请联系管理员进行修复&quot;);</span><br><span class="line">                return  result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		 // 获取日期</span><br><span class="line">        Date  date = getDate(DataStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		// 判断获取到了补签权限吗</span><br><span class="line">        if (DataStr != null)&#123;</span><br><span class="line">          if (String.valueOf(redisTemplate.keys(&quot;user:&quot; + UserId + &quot;:*&quot;)).equals(&quot;[]&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              String MAc = String.valueOf(redisTemplate.keys(&quot;user:&quot; + UserId + &quot;:*&quot;));</span><br><span class="line">              String[] split = MAc.split(&quot;:&quot;);</span><br><span class="line">              if (&quot;0&quot;.equals(split[3])) &#123;</span><br><span class="line">                  result.put(&quot;code&quot;, 407);</span><br><span class="line">                  result.put(&quot;message&quot;, &quot;你未经过老师同意无法补签&quot;);</span><br><span class="line">                  return result;</span><br><span class="line">              &#125; else&#123;</span><br><span class="line"></span><br><span class="line">                  // 获取日期</span><br><span class="line"></span><br><span class="line">                  // 获取日期对应的天数</span><br><span class="line">                  int day = DateUtil.dayOfMonth(date) - 1;</span><br><span class="line">                  // 构建redis 的 key</span><br><span class="line">                  String signkey = buildSignKEy1(UserId,date , localMacAddress2);</span><br><span class="line">                  // 查看日期是不是签到</span><br><span class="line">                  boolean isSigned = redisTemplate.opsForValue().getBit(signkey , day);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                  if(isSigned)&#123;</span><br><span class="line">                      result.put(&quot;code&quot; , 400);</span><br><span class="line">                      result.put(&quot;message&quot; , &quot;当前日期已完成签到，无需再签&quot;);</span><br><span class="line">                      return  result;</span><br><span class="line">                  &#125;</span><br><span class="line">                  // 签到</span><br><span class="line">                  redisTemplate.opsForValue().setBit(signkey , day , true);</span><br><span class="line">                  //根据当前日期获取签到的天数</span><br><span class="line">                  Date today = new Date();</span><br><span class="line">                  //统计总次数</span><br><span class="line">                  long count = getSumSignCount(UserId , today);</span><br><span class="line">                  //统计连续次数</span><br><span class="line">                  int continuous = getContinusSignCount(UserId , today);</span><br><span class="line"></span><br><span class="line">                  result.put(&quot;code&quot; , 200);</span><br><span class="line">                  result.put(&quot;message&quot; , &quot;签到成功&quot;);</span><br><span class="line">                  result.put(&quot;continuous&quot; , continuous);</span><br><span class="line">                  result.put(&quot;count&quot; , count);</span><br><span class="line"></span><br><span class="line">                  String basicname = String.valueOf(redisTemplate.keys(&quot;user:&quot; +UserId+ &quot;:*&quot;));</span><br><span class="line">                  String changgename = basicname.substring(basicname.indexOf(&quot;[&quot;)+1 , basicname.indexOf(&quot;]&quot;));</span><br><span class="line">                  String[] namebasic  =  changgename.split(&quot;:&quot;);</span><br><span class="line">                  String newname = namebasic[0] + &quot;:&quot; + namebasic[1] + &quot;:&quot; + namebasic[2] + &quot;:0:&quot; + namebasic[4];</span><br><span class="line">                  redisTemplate.rename(changgename , newname);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                  return  result;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 获取日期对应的天数</span><br><span class="line">        int day = DateUtil.dayOfMonth(date) - 1;</span><br><span class="line">        // 构建redis 的 key</span><br><span class="line">        String signkey = buildSignKEy(UserId,date , localMacAddress2);</span><br><span class="line">        // 查看日期是不是签到</span><br><span class="line">        boolean isSigned = redisTemplate.opsForValue().getBit(signkey , day);</span><br><span class="line"></span><br><span class="line">		// 判断今天是不是已经签到了</span><br><span class="line">        if(isSigned)&#123;</span><br><span class="line">            result.put(&quot;code&quot; , 400);</span><br><span class="line">            result.put(&quot;message&quot; , &quot;当前日期已完成签到，无需再签&quot;);</span><br><span class="line">            return  result;</span><br><span class="line">        &#125;</span><br><span class="line">        // 签到</span><br><span class="line">        redisTemplate.opsForValue().setBit(signkey , day , true);</span><br><span class="line">        //根据当前日期获取签到的天数</span><br><span class="line">        Date today = new Date();</span><br><span class="line">        //统计总次数</span><br><span class="line">        long count = getSumSignCount(UserId , today);</span><br><span class="line">        //统计连续次数</span><br><span class="line">        int continuous = getContinusSignCount(UserId , today);</span><br><span class="line"></span><br><span class="line">        result.put(&quot;code&quot; , 200);</span><br><span class="line">        result.put(&quot;message&quot; , &quot;签到成功&quot;);</span><br><span class="line">        result.put(&quot;continuous&quot; , continuous);</span><br><span class="line">        result.put(&quot;count&quot; , count);</span><br><span class="line">		</span><br><span class="line">		// 更改补签权限</span><br><span class="line">        String basicname = String.valueOf(redisTemplate.keys(&quot;user:&quot; +UserId+ &quot;:*&quot;));</span><br><span class="line">        String changgename = basicname.substring(basicname.indexOf(&quot;[&quot;)+1 , basicname.indexOf(&quot;]&quot;));</span><br><span class="line">        String[] namebasic  =  changgename.split(&quot;:&quot;);</span><br><span class="line">        String newname = namebasic[0] + &quot;:&quot; + namebasic[1] + &quot;:&quot; + namebasic[2] + &quot;:0:&quot; + namebasic[4];</span><br><span class="line">        redisTemplate.rename(changgename , newname);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 获取用户当天签到的情况</span><br><span class="line">    public Map&lt;String , Object&gt;getSignByDate(String UserId , String DataStr)&#123;</span><br><span class="line"></span><br><span class="line">        InetAddress inetAddress = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inetAddress = InetAddress.getLocalHost();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种方式：利用hutool工具类中的封装方法获取本机mac地址</span><br><span class="line">        String localMacAddress2 = NetUtil.getMacAddress(inetAddress);</span><br><span class="line">        System.out.println(&quot;localMacAddress2 = &quot; + localMacAddress2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String , Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (String.valueOf(redisTemplate.keys(&quot;user:&quot; + UserId + &quot;:*&quot;)).equals(&quot;[]&quot;))&#123;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String MAc = String.valueOf(redisTemplate.keys(&quot;user:&quot; + UserId + &quot;:*&quot;));</span><br><span class="line">            String[] split = MAc.split(&quot;:&quot;);</span><br><span class="line">            if (localMacAddress2.equals(split[2]))&#123;</span><br><span class="line">                System.out.println(split[2]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result.put(&quot;code&quot; , 404);</span><br><span class="line">                result.put(&quot;message&quot; , &quot;你不是在同一台电脑上进行的签到，请联系管理员进行修复&quot;);</span><br><span class="line">                return  result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        Date date = getDate(DataStr);</span><br><span class="line">        // 获取日期对应的天数</span><br><span class="line">        int day = DateUtil.dayOfMonth(date) - 1;</span><br><span class="line">        // 构建redis 的 key</span><br><span class="line">        String signkey = buildSignKEy(UserId, date , localMacAddress2);</span><br><span class="line">        // 查看日期是不是签到</span><br><span class="line">        boolean isSigned = redisTemplate.opsForValue().getBit(signkey , day);</span><br><span class="line"></span><br><span class="line">        // 签到</span><br><span class="line"></span><br><span class="line">        //根据当前日期获取签到的天数</span><br><span class="line">        Date today = new Date();</span><br><span class="line">        //统计总次数</span><br><span class="line">        long count = getSumSignCount(UserId , today);</span><br><span class="line">        //统计连续次数</span><br><span class="line">        int continuous = getContinusSignCount(UserId , today);</span><br><span class="line">        result.put(&quot;today&quot; , isSigned);</span><br><span class="line"></span><br><span class="line">        result.put(&quot;continuous&quot; , continuous);</span><br><span class="line">        result.put(&quot;count&quot; , count);</span><br><span class="line">        return  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 获取签到天数的信息</span><br><span class="line">    public Map&lt;String , Object&gt; getSignInfo(String UserId , String DataStr)&#123;</span><br><span class="line"></span><br><span class="line">        InetAddress inetAddress = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inetAddress = InetAddress.getLocalHost();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种方式：利用hutool工具类中的封装方法获取本机mac地址</span><br><span class="line">        String localMacAddress2 = NetUtil.getMacAddress(inetAddress);</span><br><span class="line">        System.out.println(&quot;localMacAddress2 = &quot; + localMacAddress2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Date date = getDate(DataStr);</span><br><span class="line">        String signkey = buildSignKEy(UserId , date , localMacAddress2);</span><br><span class="line">        // 构建一个归自动排序的Map</span><br><span class="line">        Map&lt;String , Object&gt; signInfo = new TreeMap&lt;&gt;();</span><br><span class="line">        // 获取一个月的总天数</span><br><span class="line">        int dayOfMouth = DateUtil.lengthOfMonth(DateUtil.month(date) + 1 , DateUtil.isLeapYear(DateUtil.dayOfYear(date)));</span><br><span class="line"></span><br><span class="line">        // bitfiled user : sign : 5 : 2021 014 u30</span><br><span class="line">        BitFieldSubCommands bitFieldSubCommands = BitFieldSubCommands.create().get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMouth)).valueAt(0);</span><br><span class="line"></span><br><span class="line">        // 获取用户从该当前日期到1号的状态</span><br><span class="line">        List&lt;Long&gt; list = redisTemplate.opsForValue().bitField(signkey , bitFieldSubCommands);</span><br><span class="line">        if (list == null || list.isEmpty())&#123;</span><br><span class="line">            return  signInfo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long v = list.get(0) == null ? 0 :list.get(0);</span><br><span class="line">        for (int i = dayOfMouth ; i &gt; 0 ; i--)&#123;</span><br><span class="line">            /**</span><br><span class="line">             *  map的存储格式</span><br><span class="line">             *      签到：  yyyy-mm-01</span><br><span class="line">             *      未签到  yyyy-mm-02 不做任何处理</span><br><span class="line">             *</span><br><span class="line">             */</span><br><span class="line"></span><br><span class="line">            // 获取日期</span><br><span class="line">         LocalDateTime localDateTime =  LocalDateTimeUtil.of(date).withDayOfMonth(i);</span><br><span class="line">            // 右移再左移</span><br><span class="line">            boolean flag = v &gt;&gt; 1 &lt;&lt; 1 !=v;</span><br><span class="line">            if (flag)&#123;</span><br><span class="line">                signInfo.put(DateUtil.format(localDateTime , &quot;yyyy-MM-dd&quot;) , &quot;✔&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            v &gt;&gt;= 1 ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return signInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 获取签到天数的总和</span><br><span class="line">    private long getSumSignCount(String userId, Date today) &#123;</span><br><span class="line"></span><br><span class="line">        InetAddress inetAddress = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inetAddress = InetAddress.getLocalHost();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种方式：利用hutool工具类中的封装方法获取本机mac地址</span><br><span class="line">        String localMacAddress2 = NetUtil.getMacAddress(inetAddress);</span><br><span class="line">        System.out.println(&quot;localMacAddress2 = &quot; + localMacAddress2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String signkey = buildSignKEy(userId , today , localMacAddress2);</span><br><span class="line">        //bitcount命令</span><br><span class="line">        return(long) redisTemplate.execute((RedisCallback&lt;Long&gt;)con -&gt; con.bitCount(signkey.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 获取连续签到天数</span><br><span class="line">    private int getContinusSignCount(String userId, Date today) &#123;</span><br><span class="line"></span><br><span class="line">        InetAddress inetAddress = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inetAddress = InetAddress.getLocalHost();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种方式：利用hutool工具类中的封装方法获取本机mac地址</span><br><span class="line">        String localMacAddress2 = NetUtil.getMacAddress(inetAddress);</span><br><span class="line">        System.out.println(&quot;localMacAddress2 = &quot; + localMacAddress2);</span><br><span class="line"></span><br><span class="line">        // 获取日期对应的天数</span><br><span class="line">        int dayofMonth = DateUtil.dayOfMonth(today);</span><br><span class="line">        String signkey = buildSignKEy(userId , today , localMacAddress2);</span><br><span class="line"></span><br><span class="line">        BitFieldSubCommands bitFieldSubCommands = BitFieldSubCommands.create().get(BitFieldSubCommands.BitFieldType.unsigned(dayofMonth)).valueAt(0);</span><br><span class="line"></span><br><span class="line">        // 获取用户从该当前日期到1号的状态</span><br><span class="line">        List&lt;Long&gt; list = redisTemplate.opsForValue().bitField(signkey , bitFieldSubCommands);</span><br><span class="line">        if (list == null || list.isEmpty())&#123;</span><br><span class="line">            return  0;</span><br><span class="line">        &#125;</span><br><span class="line">        int Signcount = 0;</span><br><span class="line">        long v = list.get(0) == null ? 0 :list.get(0);</span><br><span class="line">        for (int i = dayofMonth ; i &gt; 0 ; i--)&#123;</span><br><span class="line">            // i表示位移操作的次数</span><br><span class="line">            if(v &gt;&gt; 1 &lt;&lt; 1 == v) &#123;</span><br><span class="line">                // 用户当前可能未签到，所以要排除当天的可能性</span><br><span class="line">                if(i != dayofMonth) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果右移后又左移和自己不相等 代表她已经签到</span><br><span class="line">                Signcount++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 右移一位并重新赋值，相当于丢弃已经判断的数字</span><br><span class="line">            v &gt;&gt;= 1 ;</span><br><span class="line">        &#125;</span><br><span class="line">        return Signcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// redis里存储的key方法</span><br><span class="line">    private String buildSignKEy(String userId, Date date , String localMacAddress) &#123;</span><br><span class="line">        return  String.format(&quot;user:%s:%s:0:%s&quot;,userId ,localMacAddress, DateUtil.format(date, &quot;yyyyMM&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 判断是不是补签</span><br><span class="line">    private Date getDate(String dataStr) &#123;</span><br><span class="line">        return StrUtil.isBlank(dataStr) ? new Date() : DateUtil.parseDate(dataStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 教师查看端</span><br><span class="line">    public List&lt;Object&gt; teachercck(String DataStr) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;Object , Object&gt; result = new HashMap();</span><br><span class="line">        List&lt;Object&gt; end = new ArrayList&lt;&gt;();</span><br><span class="line">        String basicname = String.valueOf(redisTemplate.keys(&quot;user:&quot; + &quot;*&quot;));</span><br><span class="line">        String[] basic = basicname.split(&quot;,&quot;);</span><br><span class="line">        Date date = getDate(DataStr);</span><br><span class="line">        int day = DateUtil.dayOfMonth(date) - 1;</span><br><span class="line">//        end.put(&quot;code&quot; , 0);</span><br><span class="line">//        end.put(&quot;msg&quot; , &quot;&quot;);</span><br><span class="line">//        result.put(&quot;count&quot; , basic.length);</span><br><span class="line">        end.add(basic.length);</span><br><span class="line">        for( int i = 0 ; i &lt; basic.length ; i++ )&#123;</span><br><span class="line">                String[] namebasic  =  basic[i].split(&quot;:&quot;);</span><br><span class="line">                String signkey = buildSignKEy(namebasic[1], date , namebasic[2]);</span><br><span class="line">                boolean isSigned = redisTemplate.opsForValue().getBit(signkey , day);</span><br><span class="line">//                result.put(i+1 , namebasic[1]);</span><br><span class="line">                end.add(namebasic[1]);</span><br><span class="line">                end.add(namebasic[2]);</span><br><span class="line">//                result.put(namebasic[1], namebasic[2]);</span><br><span class="line">                if (isSigned)&#123;</span><br><span class="line">//                    result.put(namebasic[2] , &quot;今日已经签到&quot;);</span><br><span class="line">                    end.add(&quot;今日已经签到&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">//                    result.put(namebasic[2] , &quot;今日没有签到&quot;);</span><br><span class="line">                    end.add(&quot;今日未签到&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                if (namebasic[3].equals(&quot;0&quot;))&#123;</span><br><span class="line">                    end.add(&quot;未获得补签权限&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    end.add(&quot;已经获得补签权限&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 教师更改学生可以补签的权限</span><br><span class="line">    public Map&lt;Object , Object&gt; teacherchange(String UserId)</span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Object , Object&gt; result = new HashMap();</span><br><span class="line">        String basicname = String.valueOf(redisTemplate.keys(&quot;user:&quot; +UserId+ &quot;:*&quot;));</span><br><span class="line">        String changgename = basicname.substring(basicname.indexOf(&quot;[&quot;)+1 , basicname.indexOf(&quot;]&quot;));</span><br><span class="line">        String[] namebasic  =  changgename.split(&quot;:&quot;);</span><br><span class="line"></span><br><span class="line">        String newname = namebasic[0] + &quot;:&quot; + namebasic[1] + &quot;:&quot; + namebasic[2] + &quot;:1:&quot; + namebasic[4];</span><br><span class="line">        redisTemplate.rename(changgename , newname);</span><br><span class="line"></span><br><span class="line">        result.put(&quot;code&quot; , 404);</span><br><span class="line">        result.put(&quot;message&quot; , &quot;成功修改&quot;);</span><br><span class="line">        return  result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="控制端"><a href="#控制端" class="headerlink" title="控制端"></a>控制端</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import com.example.demo.Servicedemo.SignService;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;sign&quot;)</span><br><span class="line">public class SignController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private SignService signservice;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 用户的签到可以补签</span><br><span class="line">     * */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public Map&lt;String  , Object&gt; doSignIn(String UserId , String DataStr)&#123;</span><br><span class="line"></span><br><span class="line">        return signservice.doSign(UserId , DataStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取用户当天的签到情况</span><br><span class="line">    @GetMapping(&quot;today&quot;)</span><br><span class="line">    public Map&lt;String  , Object&gt; getSignByDate(String UserId , String DataStr)&#123;</span><br><span class="line"></span><br><span class="line">        return signservice.getSignByDate(UserId , DataStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;SIGNFO&quot;)</span><br><span class="line">    public  Map&lt;String , Object&gt; GetSignInfo(String UserId , String DataStr)&#123;</span><br><span class="line"></span><br><span class="line">        return  signservice.getSignInfo(UserId , DataStr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @PostMapping(&quot;/teacher&quot;)</span><br><span class="line">    public java.util.List&lt;Object&gt; Getinfo(String DataStr)&#123;</span><br><span class="line"></span><br><span class="line">        return signservice.teachercck(DataStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/change&quot;)</span><br><span class="line">    public Map&lt;Object, Object&gt; chenge(String USerId)&#123;</span><br><span class="line"></span><br><span class="line">        return signservice.teacherchange(USerId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自动启动浏览器"><a href="#自动启动浏览器" class="headerlink" title="自动启动浏览器"></a>自动启动浏览器</h2><ul>
<li>先在SignDemo的同级目录下创建web启动类</li>
<li>如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.example.demo;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class ControllerTest &#123;</span><br><span class="line">    @GetMapping</span><br><span class="line">    public String run() &#123;</span><br><span class="line"></span><br><span class="line">        return &quot;启动springboot成功!&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在与SignDEmo同级的包里创建一个浏览器自动启动类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">package com.example.demo.AutoB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.event.ApplicationReadyEvent;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.event.EventListener;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AutoBrower &#123;</span><br><span class="line">    @EventListener(&#123;ApplicationReadyEvent.class&#125;)</span><br><span class="line">    void applicationReadyEvent() &#123;</span><br><span class="line">        System.out.println(&quot;应用已经准备就绪 ... 启动浏览器&quot;);</span><br><span class="line">        // 这里需要注url:端口号+测试类方法名</span><br><span class="line">        String url = &quot;http://localhost:9999/index.html&quot;;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        try &#123;</span><br><span class="line">            runtime.exec(&quot;rundll32 url.dll,FileProtocolHandler &quot; + url);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面那个url是我们要自动启动的网页</li>
</ul>
<h1 id="前端浏览器页面"><a href="#前端浏览器页面" class="headerlink" title="前端浏览器页面"></a>前端浏览器页面</h1><ul>
<li>前端浏览器页面我们主要使用ajax进行浏览器的传值，</li>
<li>前端我们使用了嵌套的布局，是一个index嵌套一个welcome</li>
<li>代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span><br><span class="line">    &lt;title&gt;个人中心&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/layui/2.7.6/css/layui.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;fieldset class=&quot;layui-elem-field layui-field-title&quot; style=&quot;margin-top: 30px;&quot;&gt;</span><br><span class="line">    &lt;legend&gt;个人中心&lt;/legend&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&quot;padding: 20px&quot;&gt;</span><br><span class="line">&lt;div class = &quot;layui-col-md3&quot;&gt;</span><br><span class="line">&lt;div class=&quot;layui-tab layui-tab-card&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;layui-tab-title&quot;&gt;</span><br><span class="line">        &lt;li class=&quot;layui-this&quot;&gt;签到&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;补签&lt;/li&gt;</span><br><span class="line">        &lt;li id=&quot;&quot;&gt;记录&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;div class=&quot;layui-tab-content&quot; style=&quot;height: 100px;&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;layui-tab-item layui-show&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=&quot;layui-form-item&quot;&gt;</span><br><span class="line">                &lt;button class=&quot;layui-btn layui-btn-radius layui-btn-normal layui-form-label&quot; id = &quot;SignBtn&quot; style=&quot;margin-left: 20px&quot; &gt; 签 &amp;nbsp 到&lt;/button&gt;</span><br><span class="line">                &lt;div class=&quot;layui-input-block&quot;&gt;</span><br><span class="line">                    &lt;input type=&quot;text&quot; name=&quot;username&quot; lay-verify=&quot;title&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入姓名&quot; class=&quot;layui-input&quot; id=&quot;user&quot;&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;hr&gt;</span><br><span class="line">            &lt;p&gt;你已签到&amp;nbsp;&lt;span style = &quot;color: red;&quot; id=&quot;count&quot; &gt;0 &lt;/span&gt;&amp;nbsp;天&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;连续签到&amp;nbsp;&lt;span style = &quot;color: red;&quot; id=&quot;continuous&quot;&gt;0&lt;/span&gt;&amp;nbsp;天&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;layui-tab-item&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;layui-inline&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; class=&quot;layui-input&quot; id=&quot;reissue&quot; placeholder=&quot;请选择日期&quot;&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;button class=&quot;layui-btn layui-btn-radius layui-btn-normal&quot; id = &quot;reissueBtn&quot;&gt; 补签&lt;/button&gt;</span><br><span class="line">            &lt;div class=&quot;layui-form-item&quot;&gt;</span><br><span class="line">                    &lt;input type=&quot;text&quot; name=&quot;username&quot; lay-verify=&quot;title&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入姓名&quot; class=&quot;layui-input&quot; id=&quot;user1&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;layui-tab-item&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=&quot;layui-form-item&quot;&gt;</span><br><span class="line">                &lt;button class=&quot;layui-btn layui-btn-radius layui-btn-normal layui-form-label&quot; id = &quot;recordLi&quot;&gt;查询记录&lt;/button&gt;</span><br><span class="line">                &lt;div class=&quot;layui-input-block&quot;&gt;</span><br><span class="line">                    &lt;input type=&quot;text&quot; name=&quot;username&quot; lay-verify=&quot;title&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入姓名&quot; class=&quot;layui-input&quot; id=&quot;user2&quot;&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=&quot;layui-inline&quot; id=&quot;record&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.15.10/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/layui/2.7.6/layui.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // $(function () &#123;</span><br><span class="line">    //</span><br><span class="line">    //     var value = jQuery(&quot;#user&quot;).val();</span><br><span class="line">    //</span><br><span class="line">    //     $.ajax(&#123;</span><br><span class="line">    //         url: &quot;/sign/today&quot;,</span><br><span class="line">    //         type: &quot;GET&quot;,</span><br><span class="line">    //         data: &#123;&quot;UserId&quot; : value&#125;, // 模拟的用户id</span><br><span class="line">    //         dataType: &quot;JSON&quot;,</span><br><span class="line">    //         success: function f(result) &#123;</span><br><span class="line">    //             layer.msg(result.message);</span><br><span class="line">    //             if(200 == result.code)&#123;</span><br><span class="line">    //                 if (true == result.today) &#123;</span><br><span class="line">    //                     $(&quot;#count&quot;).text(result.count);</span><br><span class="line">    //                     // 设置连续签到次数</span><br><span class="line">    //                     $(&quot;#continuous&quot;).text(result.continuous);</span><br><span class="line">    //                     // 设置签到按钮的文本</span><br><span class="line">    //                     $(&quot;#SignBtn&quot;).text(&quot;已经签到&quot;);</span><br><span class="line">    //                     // 禁用签到按钮</span><br><span class="line">    //                     $(&quot;#SignBtn&quot;).addClass(&quot;layui-btn-disabled&quot;);</span><br><span class="line">    //                     $(&quot;#SignBtn&quot;).attr(&quot;disabled&quot; , &quot;true&quot;);</span><br><span class="line">    //                 &#125;</span><br><span class="line">    //</span><br><span class="line">    //             &#125;</span><br><span class="line">    //</span><br><span class="line">    //</span><br><span class="line">    //         &#125;</span><br><span class="line">    //</span><br><span class="line">    //     &#125;);</span><br><span class="line">    //</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    layui.use(&#x27;laydate&#x27;, function()&#123;</span><br><span class="line">        var laydate = layui.laydate;</span><br><span class="line"></span><br><span class="line">        //执行一个laydate实例</span><br><span class="line">        laydate.render(&#123;</span><br><span class="line">            elem: &#x27;#reissue&#x27; //指定元素</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    layui.use(&#x27;layer&#x27; , function () &#123;</span><br><span class="line">        // 签到</span><br><span class="line">        $(&quot;#SignBtn&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class="line">            var value = jQuery(&quot;#user&quot;).val();</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: &quot;/sign&quot;,</span><br><span class="line">                type: &quot;POST&quot;,</span><br><span class="line">                data: &#123;&quot;UserId&quot;: value&#125;, // 模拟的用户id</span><br><span class="line">                dataType: &quot;JSON&quot;,</span><br><span class="line">                success: function f(result) &#123;</span><br><span class="line">                    // for (var m in result)&#123;</span><br><span class="line">                    //     alert(m)</span><br><span class="line">                    //     alert(result[m])</span><br><span class="line">                    // &#125;</span><br><span class="line">                    layer.msg(result.message);</span><br><span class="line">                    if (200 == result.code) &#123;</span><br><span class="line">                        // 设置总签到次数</span><br><span class="line">                        $(&quot;#count&quot;).text(result.count);</span><br><span class="line">                        // 设置连续签到次数</span><br><span class="line">                        $(&quot;#continuous&quot;).text(result.continuous);</span><br><span class="line">                        // 设置签到按钮的文本</span><br><span class="line">                        $(&quot;#SignBtn&quot;).text(&quot;已经签到&quot;);</span><br><span class="line">                        // 禁用签到按钮</span><br><span class="line">                        $(&quot;#SignBtn&quot;).addClass(&quot;layui-btn-disabled&quot;);</span><br><span class="line">                        $(&quot;#SignBtn&quot;).attr(&quot;disabled&quot;, &quot;true&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        //补签</span><br><span class="line">        $(&quot;#reissueBtn&quot;).on(&quot;click&quot; , function () &#123;</span><br><span class="line">            var va = jQuery(&quot;#user1&quot;).val();</span><br><span class="line"></span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: &quot;/sign&quot;,</span><br><span class="line">                type: &quot;POST&quot;,</span><br><span class="line">                data: &#123;&quot;UserId&quot; : va , &quot;DataStr&quot; : $(&quot;#reissue&quot;).val()&#125;, // 模拟的用户id</span><br><span class="line">                dataType: &quot;JSON&quot;,</span><br><span class="line">                success: function f(result) &#123;</span><br><span class="line">                    layer.msg(result.message);</span><br><span class="line">                    if(200 == result.code)&#123;</span><br><span class="line">                        // 设置总签到次数</span><br><span class="line">                        $(&quot;#count&quot;).text(result.count);</span><br><span class="line"></span><br><span class="line">                        // 设置连续签到次数</span><br><span class="line">                        $(&quot;#continuous&quot;).text(result.continuous);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 签到记录的元素</span><br><span class="line">    $(&quot;#recordLi&quot;).on(&quot;click&quot; , function () &#123;</span><br><span class="line">        var vae = jQuery(&quot;#user2&quot;).val();</span><br><span class="line">        layui.use(&#x27;layer&#x27; , function () &#123;</span><br><span class="line">            var laydate = layui.laydate;</span><br><span class="line"></span><br><span class="line">            // 获取签到记录</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: &quot;/sign/SIGNFO&quot;,</span><br><span class="line">                type: &quot;POST&quot;,</span><br><span class="line">                data: &#123;&quot;UserId&quot;: vae&#125;, // 模拟的用户id</span><br><span class="line">                dataType: &quot;JSON&quot;,</span><br><span class="line">                success: function f(result) &#123;</span><br><span class="line"></span><br><span class="line">                    // 清空日历元素</span><br><span class="line">                    $(&quot;#record&quot;).html(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">                    laydate.render(&#123;</span><br><span class="line">                        elem: &#x27;#record&#x27;</span><br><span class="line">                        ,mark: result,</span><br><span class="line">                        position: &#x27;static&#x27;</span><br><span class="line">                    &#125;)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>index的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span><br><span class="line">    &lt;title&gt;用户签到系统&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/layui/2.7.6/css/layui.css&quot; media=&quot;all&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;layui-header&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;layui-logo layui-hide-xs layui-bg-black&quot;&gt;用户签到系统&lt;/div&gt;</span><br><span class="line">        &lt;!-- 头部区域（可配合layui 已有的水平导航） --&gt;</span><br><span class="line">        &lt;ul class=&quot;layui-nav layui-layout-left&quot;&gt;</span><br><span class="line">            &lt;!-- 移动端显示 --&gt;</span><br><span class="line">            &lt;li class=&quot;layui-nav-item layui-show-xs-inline-block layui-hide-sm&quot; lay-header-event=&quot;menuLeft&quot;&gt;</span><br><span class="line">                &lt;i class=&quot;layui-icon layui-icon-spread-left&quot;&gt;&lt;/i&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">            &lt;li class=&quot;layui-nav-item layui-hide-xs&quot;&gt;&lt;a href=&quot;&quot;&gt;签到&lt;/a&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;layui-side-scroll&quot;&gt;</span><br><span class="line">            &lt;!-- 左侧导航区域（可配合layui已有的垂直导航） --&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;layui-body&quot;&gt;</span><br><span class="line">        &lt;!-- 内容主体区域 --&gt;</span><br><span class="line">        &lt;iframe src=&quot;welcome.html&quot;  name=&quot;container&quot; style=&quot;width: 100%; height: 100%; &quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;layui-footer&quot;&gt;</span><br><span class="line">        &lt;!-- 底部固定区域 --&gt;</span><br><span class="line">        底部固定区域</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/layui/2.7.6/layui.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>上述只是学生端的，对于教师端也和其大差不差，代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Layui&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/layui/2.7.6/css/layui.css&quot;    media=&quot;all&quot;&gt;</span><br><span class="line">    &lt;!-- 注意：如果你直接复制所有代码到本地，上述css路径需要改成你本地的 --&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;legend&gt;教师中心&lt;/legend&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;layui-tab layui-tab-card&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;layui-tab-title&quot;&gt;</span><br><span class="line">        &lt;li class=&quot;layui-this&quot;&gt;查看签到情况&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;更改权限&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;div class=&quot;layui-tab-content&quot; style=&quot;height: 100px;&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;layui-tab-item layui-show&quot;&gt;</span><br><span class="line">            &lt;table border=&quot;1&quot; width=&quot;600px&quot;&gt;</span><br><span class="line">            &lt;tbody &gt;</span><br><span class="line">            &lt;tr  style=&#x27;width:300px&#x27; &gt;</span><br><span class="line">                &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;Mac地址&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;今日签到情况&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;补签情况&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;/tbody&gt;</span><br><span class="line">            &lt;tbody id=&quot;tbody1&quot;&gt;</span><br><span class="line">            &lt;/tbody&gt;</span><br><span class="line">        &lt;/table&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;layui-tab-item&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;button class=&quot;layui-btn layui-btn-radius layui-btn-normal&quot; id = &quot;reissueBtn&quot;&gt;更改补签权限&lt;/button&gt;</span><br><span class="line">            &lt;div class=&quot;layui-form-item&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; name=&quot;username&quot; lay-verify=&quot;title&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入姓名&quot; class=&quot;layui-input&quot; id=&quot;user1&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/layui/2.7.6/layui.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 注意：如果你直接复制所有代码到本地，上述 JS 路径需要改成你本地的 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.15.10/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/layui/2.7.6/layui.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &quot;/sign/teacher&quot;,</span><br><span class="line">            type: &quot;POST&quot;,</span><br><span class="line">            data: &#123;&quot;DataStr&quot;: null&#125;,</span><br><span class="line">            dataType: &quot;JSON&quot;,</span><br><span class="line">            success: function f(result) &#123;</span><br><span class="line">                var m = 0;</span><br><span class="line">                var tableData = null;</span><br><span class="line">                for (let k = 1; k &lt;= result[0]; k++) &#123;</span><br><span class="line"></span><br><span class="line">                    tableData += &quot;&lt;tr  style=&#x27;width:300px&#x27; &gt;&quot;</span><br><span class="line">                    for (let i = 1 + m; i &lt;= 4 + m; i++) &#123;</span><br><span class="line">                        tableData += &quot;&lt;td&gt;&quot; + result[i] + &quot;&lt;/td&gt;&quot;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    // tableData += &quot;&lt;td&gt;&lt;button type=&#x27;submit&#x27; onclick=&#x27;btnAction&#x27; name=&#x27;btn&#x27;&gt;更改补签权限&lt;/button&gt;&lt;/td&gt;&quot;</span><br><span class="line">                    tableData += &quot;&lt;/tr&gt;&quot;</span><br><span class="line">                    m += 4;</span><br><span class="line">                &#125;</span><br><span class="line">                $(&quot;#tbody1&quot;).html(tableData)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     $(&quot;#reissueBtn&quot;).on(&quot;click&quot; , function () &#123;</span><br><span class="line">         var va = jQuery(&quot;#user1&quot;).val();</span><br><span class="line">                alert(va)</span><br><span class="line">         $.ajax(&#123;</span><br><span class="line">             url: &quot;/sign/change&quot;,</span><br><span class="line">             type: &quot;POST&quot;,</span><br><span class="line">             data: &#123;&quot;USerId&quot; : va&#125;,</span><br><span class="line">             dataType: &quot;JSON&quot;,</span><br><span class="line">             success: function f(result) &#123;</span><br><span class="line">                 layer.msg(result.message);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>教师的index</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span><br><span class="line">    &lt;title&gt;教师观察系统&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/layui/2.7.6/css/layui.css&quot; media=&quot;all&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;layui-header&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;layui-logo layui-hide-xs layui-bg-black&quot;&gt;教师观察系统&lt;/div&gt;</span><br><span class="line">        &lt;!-- 头部区域（可配合layui 已有的水平导航） --&gt;</span><br><span class="line">        &lt;ul class=&quot;layui-nav layui-layout-left&quot;&gt;</span><br><span class="line">            &lt;!-- 移动端显示 --&gt;</span><br><span class="line">            &lt;li class=&quot;layui-nav-item layui-show-xs-inline-block layui-hide-sm&quot; lay-header-event=&quot;menuLeft&quot;&gt;</span><br><span class="line">                &lt;i class=&quot;layui-icon layui-icon-spread-left&quot;&gt;&lt;/i&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">            &lt;li class=&quot;layui-nav-item layui-hide-xs&quot;&gt;&lt;a href=&quot;&quot;&gt;签到情况&lt;/a&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;layui-side-scroll&quot;&gt;</span><br><span class="line">            &lt;!-- 左侧导航区域（可配合layui已有的垂直导航） --&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;layui-body&quot;&gt;</span><br><span class="line">        &lt;!-- 内容主体区域 --&gt;</span><br><span class="line">        &lt;iframe src=&quot;teacher.html&quot;  name=&quot;container&quot; style=&quot;width: 100%; height: 100%; &quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;layui-footer&quot;&gt;</span><br><span class="line">        &lt;!-- 底部固定区域 --&gt;</span><br><span class="line">        底部固定区域</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/layui/2.7.6/layui.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>签到的制作</category>
      </categories>
  </entry>
  <entry>
    <title>踩过的坑</title>
    <url>/2022/11/17/%E5%9D%91/</url>
    <content><![CDATA[<h1 id="修改windows下的hosts文件不生效"><a href="#修改windows下的hosts文件不生效" class="headerlink" title="修改windows下的hosts文件不生效"></a>修改windows下的hosts文件不生效</h1><ul>
<li>这个坑一直卡了我三四天</li>
<li>配置完hadoop集群，进行web访问的时候出现了这个问题</li>
<li>因为windows的主机映射不好使，所以我无法在网页端查看数据</li>
</ul>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li>我这里解决这个的办法是通过</li>
<li>把中间空格放大的方法</li>
<li>就是一个小空格加一个tab键</li>
<li>然后进入 <code>edge://net-internals</code>或者 <code>chrome://net-internals</code></li>
<li>这取决于你的浏览器</li>
<li>然后 <code>win + x</code> 查看windows powershell（管理员）打开之后执行 <code> ipconfig /flushdns</code></li>
<li>刷新之后就可以通过映射访问了</li>
</ul>
<h1 id="有关于idea关于Hadoop的api的copyToLocalfile不生效"><a href="#有关于idea关于Hadoop的api的copyToLocalfile不生效" class="headerlink" title="有关于idea关于Hadoop的api的copyToLocalfile不生效"></a>有关于idea关于Hadoop的api的copyToLocalfile不生效</h1><ul>
<li>报错信息 <code>java.io.FileNotFoundException: HADOOP_HOME and hadoop.home.dir are unset.</code></li>
<li>这个是代表你windows里没有配置hadoop环境</li>
<li>我们可以不用他提供的api</li>
<li>通过</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FSDataInputStream fis = fs.open(new Path(&quot;/date&quot;)); // hdfs上的文件</span><br><span class="line">OutputStream outputStream = new FileOutputStream( new File(&quot;D:\\ bg1.txt&quot;) , false); // 本地的存储地点</span><br><span class="line">IOUtils.copyBytes(fis,outputStream,4096 , true);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>就可以实现下载</li>
</ul>
<h1 id="关于linux里的mysql会自动识别大小写表名的事情"><a href="#关于linux里的mysql会自动识别大小写表名的事情" class="headerlink" title="关于linux里的mysql会自动识别大小写表名的事情"></a>关于linux里的mysql会自动识别大小写表名的事情</h1><p>linux里的mysql会自动对表名进行大小写区分，这可能导致一些boot项目启动的时候找不到表名</p>
<p>如何更改如下</p>
<p>首先查看自己的表名大小写权限是不是打开了</p>
<p>先在mysql里执行</p>
<p><code>show variables like &quot;%case%&quot;;</code></p>
<p>查看一下我们的权限打没打开</p>
<p>一般默认的时候会有个off的选项</p>
<p>这个是默认的情况</p>
<p>接下来我们对其进行修改</p>
<p>我们首先退出mysql</p>
<p>然后关闭mysql服务输入 ： <code>mysqladmin -uroot -p shutdown //以安全模式关闭数据库</code></p>
<p>接下来输入密码就关闭了</p>
<p>然后编辑mysql的配置文件</p>
<p>输入 ： <code>vim /etc/my.cnf</code></p>
<p>在mysqld下添加一行</p>
<p><code>lower_case_table_names=1</code></p>
<p>然后退出保存即可</p>
<p>最后要重新启动mysql输入 ： <code>systemctl resatrt mysqld</code></p>
<p>就可以了</p>
<h1 id="mysql误删了配置文件-performance-schema的恢复"><a href="#mysql误删了配置文件-performance-schema的恢复" class="headerlink" title="mysql误删了配置文件 performance_schema的恢复"></a>mysql误删了配置文件 performance_schema的恢复</h1><p>首先我们退出mysql</p>
<p>然后输入 <code>mysql_upgrade -u root -p </code></p>
<p>输入我们的密码之后</p>
<p>然后重新登录我们的mysql就会出现了</p>
<h1 id="npm怎么清除缓存"><a href="#npm怎么清除缓存" class="headerlink" title="npm怎么清除缓存"></a>npm怎么清除缓存</h1><p>首先关于npm进行清除缓存</p>
<p>先明确自己的npm的版本</p>
<p>如果npm version &lt; 7.0.0</p>
<p><code>$ npm cache clean -f</code></p>
<p>npm version ≧ 7.0.0 会报以下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm cache cleannpm ERR! As of npm@5, the npm cache self-heals from corruption issues</span><br><span class="line">npm ERR! by treating integrity mismatches as cache misses.  As a result,</span><br><span class="line">npm ERR! data extracted from the cache is guaranteed to be valid.  If you</span><br><span class="line">npm ERR! want to make sure everything is consistent, use npm cache verify</span><br><span class="line">npm ERR! instead.  Deleting the cache can only make npm go slower, and is</span><br><span class="line">npm ERR! not likely to correct any problems you may be encountering!</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! On the other hand, <span class="keyword">if</span> you<span class="string">&#x27;re debugging an issue with the installer,</span></span><br><span class="line"><span class="string">npm ERR! or race conditions that depend on the timing of writing to an empty</span></span><br><span class="line"><span class="string">npm ERR! cache, you can use npm install --cache /tmp/empty-cache to use a</span></span><br><span class="line"><span class="string">npm ERR! temporary cache instead of nuking the actual one.</span></span><br><span class="line"><span class="string">npm ERR!</span></span><br><span class="line"><span class="string">npm ERR! If you&#x27;</span>re sure you want to delete the entire cache, rerun this <span class="built_in">command</span></span><br><span class="line">npm ERR! with --force.npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /Users/xxxxxx/.npm/_logs/2021-02-04T06_35_38_043Z-debug.log</span><br></pre></td></tr></table></figure>

<p>如果想强制清除缓存就要用–force</p>
<h1 id="关于npm设置镜像源"><a href="#关于npm设置镜像源" class="headerlink" title="关于npm设置镜像源"></a>关于npm设置镜像源</h1><p><code>npm config set registry http://registry.npm.taobao.org</code></p>
<p>然后就把淘宝镜像源加进入了</p>
<h1 id="Git之本地分支和远程分支建立追踪关系的几种方式"><a href="#Git之本地分支和远程分支建立追踪关系的几种方式" class="headerlink" title="Git之本地分支和远程分支建立追踪关系的几种方式"></a>Git之本地分支和远程分支建立追踪关系的几种方式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/remote_branch your_branch</span><br><span class="line">origin/remote_branch是你本地分支对应的远程分支；your_branch是你当前的本地分支。</span><br></pre></td></tr></table></figure>

<p>或者之间checkout -b 根据远程建立本地分支</p>
<h1 id="git-删除远程分支"><a href="#git-删除远程分支" class="headerlink" title="git 删除远程分支"></a>git 删除远程分支</h1><p><code> git push origin --delete [branch_name]</code></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>杂项</title>
    <url>/2022/10/27/%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="查看自己电脑可支持的最大内存"><a href="#查看自己电脑可支持的最大内存" class="headerlink" title="查看自己电脑可支持的最大内存"></a>查看自己电脑可支持的最大内存</h1><ul>
<li>打开cmd</li>
<li>输入wmic memphysical get maxcapacity</li>
<li>就会获得字节数</li>
<li>除以两个1024，就会是xxxG</li>
</ul>
<h1 id="查看电脑有几个卡槽"><a href="#查看电脑有几个卡槽" class="headerlink" title="查看电脑有几个卡槽"></a>查看电脑有几个卡槽</h1><ul>
<li>打开任务管理器</li>
<li>选择性能</li>
<li>上面就有已经使用了几个卡槽</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>第一天</title>
    <url>/2022/10/27/%E7%89%9B%E5%AE%A21/</url>
    <content><![CDATA[<h1 id="实现二叉树的前序遍历"><a href="#实现二叉树的前序遍历" class="headerlink" title="实现二叉树的前序遍历"></a>实现二叉树的前序遍历</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * public class TreeNode &#123; // 树形结构</span><br><span class="line"> *   int val = 0;</span><br><span class="line"> *   TreeNode left = null;</span><br><span class="line"> *   TreeNode right = null;</span><br><span class="line"> *   public TreeNode(int val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型一维数组</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    public int[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        // write code here</span><br><span class="line"></span><br><span class="line">        list =  pre(root); // 先设置一个函数，让他把二叉树的节点存入list中方便输出 ， 简单来说就是把二叉树转化为list形式的</span><br><span class="line">        int[] res = new int[list.size()]; // 设定一个输出数组 ，我们要遍历的其实是这个数组</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; list.size(); i++)&#123;</span><br><span class="line">           res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt;  pre(TreeNode node)&#123;</span><br><span class="line"></span><br><span class="line">        if(node == null)&#123;</span><br><span class="line">                return list;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        pre(node.left);</span><br><span class="line">        pre(node.right);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>其时间复杂度和空间复杂度都是O（N）</li>
<li>用堆栈实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *   int val = 0;</span><br><span class="line"> *   TreeNode left = null;</span><br><span class="line"> *   TreeNode right = null;</span><br><span class="line"> *   public TreeNode(int val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型一维数组</span><br><span class="line">     */</span><br><span class="line">    private List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">    public int[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        if(root==null) return new int[0];</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            </span><br><span class="line">            if(node.right!=null) stack.push(node.right);</span><br><span class="line">            if(node.left!=null) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res= new int[list.size()];</span><br><span class="line">        for(int i=0;i&lt;list.size();i++)&#123;</span><br><span class="line">            res[i]=list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>堆栈更简单可是更难理解，可以直接背</li>
</ul>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *   int val = 0;</span><br><span class="line"> *   TreeNode left = null;</span><br><span class="line"> *   TreeNode right = null;</span><br><span class="line"> *   public TreeNode(int val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型一维数组</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list =new ArrayList&lt;&gt;();</span><br><span class="line">    public int[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        pre(root);</span><br><span class="line">        int[] res = new int[list.size()];</span><br><span class="line">        for(int i = 0; i &lt; list.size(); i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; pre(TreeNode node)&#123;</span><br><span class="line">        if(node == null)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        pre(node.left);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        pre(node.right);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>用堆栈实现</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *   int val = 0;</span><br><span class="line"> *   TreeNode left = null;</span><br><span class="line"> *   TreeNode right = null;</span><br><span class="line"> *   public TreeNode(int val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型一维数组</span><br><span class="line">     */</span><br><span class="line">    private List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">    public int[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        if(root==null) return new int[0];</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">			if(node.right!=null) stack.push(node.right);</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            if(node.left!=null) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res= new int[list.size()];</span><br><span class="line">        for(int i=0;i&lt;list.size();i++)&#123;</span><br><span class="line">            res[i]=list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">		</span><br><span class="line">		/*</span><br><span class="line">		 * public class TreeNode &#123;</span><br><span class="line">		 *   int val = 0;</span><br><span class="line">		 *   TreeNode left = null;</span><br><span class="line">		 *   TreeNode right = null;</span><br><span class="line">		 *   public TreeNode(int val) &#123;</span><br><span class="line">		 *     this.val = val;</span><br><span class="line">		 *   &#125;</span><br><span class="line">		 * &#125;</span><br><span class="line">		 */</span><br><span class="line">		</span><br><span class="line">		public class Solution &#123;</span><br><span class="line">		    /**</span><br><span class="line">		     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">		     *</span><br><span class="line">		     * </span><br><span class="line">		     * @param root TreeNode类 </span><br><span class="line">		     * @return int整型一维数组</span><br><span class="line">		     */</span><br><span class="line">		</span><br><span class="line">		    List&lt;Integer&gt; list =new ArrayList&lt;&gt;();</span><br><span class="line">		    public int[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">		        // write code here</span><br><span class="line">		        pre(root);</span><br><span class="line">		        int[] res = new int[list.size()];</span><br><span class="line">		        for(int i = 0; i &lt; list.size(); i++)&#123;</span><br><span class="line">		            res[i] = list.get(i);</span><br><span class="line">		        &#125;</span><br><span class="line">		        return res;</span><br><span class="line">		    &#125;</span><br><span class="line">		</span><br><span class="line">		    List&lt;Integer&gt; pre(TreeNode node)&#123;</span><br><span class="line">		        if(node == null)&#123;</span><br><span class="line">		            return list;</span><br><span class="line">		        &#125;</span><br><span class="line">		        pre(node.right);</span><br><span class="line">		        list.add(node.val);</span><br><span class="line">		        pre(node.left);</span><br><span class="line">		        return list;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>用堆栈实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *   int val = 0;</span><br><span class="line"> *   TreeNode left = null;</span><br><span class="line"> *   TreeNode right = null;</span><br><span class="line"> *   public TreeNode(int val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型一维数组</span><br><span class="line">     */</span><br><span class="line">    private List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">    public int[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        if(root==null) return new int[0];</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">				if(node.left!=null) stack.push(node.left);</span><br><span class="line">            list.add(node.val);</span><br><span class="line">			if(node.right!=null) stack.push(node.right);</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        int[] res= new int[list.size()];</span><br><span class="line">        for(int i=0;i&lt;list.size();i++)&#123;</span><br><span class="line">            res[i]=list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><ul>
<li>bfs</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    //边界条件判断</span><br><span class="line">    if (root == null)</span><br><span class="line">        return new ArrayList&lt;&gt;();</span><br><span class="line">    //队列</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    //根节点入队</span><br><span class="line">    queue.add(root);</span><br><span class="line">    //如果队列不为空就继续循环</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        //BFS打印，levelNum表示的是每层的结点数</span><br><span class="line">        int levelNum = queue.size();</span><br><span class="line">        //subList存储的是每层的结点值</span><br><span class="line">        ArrayList&lt;Integer&gt; subList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; levelNum; i++) &#123;</span><br><span class="line">            //出队</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            subList.add(node.val);</span><br><span class="line">            //左右子节点如果不为空就加入到队列中</span><br><span class="line">            if (node.left != null)</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            if (node.right != null)</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        //把每层的结点值存储在res中，</span><br><span class="line">        res.add(subList);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>dfs</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    levelHelper(res, root, 0);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void levelHelper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list, TreeNode root, int level) &#123;</span><br><span class="line">    //边界条件判断</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    //level表示的是层数，如果level &gt;= list.size()，说明到下一层了，所以</span><br><span class="line">    //要先把下一层的list初始化，防止下面add的时候出现空指针异常</span><br><span class="line">    if (level &gt;= list.size()) &#123;</span><br><span class="line">        list.add(new ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    //level表示的是第几层，这里访问到第几层，我们就把数据加入到第几层</span><br><span class="line">    list.get(level).add(root.val);</span><br><span class="line">    //当前节点访问完之后，再使用递归的方式分别访问当前节点的左右子节点</span><br><span class="line">    levelHelper(list, root.left, level + 1);</span><br><span class="line">    levelHelper(list, root.right, level + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="按照之字型打印二叉树"><a href="#按照之字型打印二叉树" class="headerlink" title="按照之字型打印二叉树"></a>按照之字型打印二叉树</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        boolean rev = true;</span><br><span class="line">        q.add(pRoot);</span><br><span class="line">        while(!q.isEmpty())&#123;</span><br><span class="line">            int size = q.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i=0; i&lt;size; i++)&#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                if(node == null)&#123;continue;&#125;</span><br><span class="line">                if(rev)&#123;</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    list.add(0, node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                q.offer(node.left);</span><br><span class="line">                q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            if(list.size()!=0)&#123;res.add(list);&#125;</span><br><span class="line">            rev=!rev;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int maxDepth (TreeNode root) &#123;</span><br><span class="line">        //空节点没有深度</span><br><span class="line">        if(root == null) </span><br><span class="line">            return 0;</span><br><span class="line">        //队列维护层次后续节点</span><br><span class="line">        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); </span><br><span class="line">        //根入队</span><br><span class="line">        q.offer(root); </span><br><span class="line">        //记录深度</span><br><span class="line">        int res = 0; </span><br><span class="line">        //层次遍历</span><br><span class="line">        while(!q.isEmpty())&#123; </span><br><span class="line">            //记录当前层有多少节点</span><br><span class="line">            int n = q.size(); </span><br><span class="line">            //遍历完这一层，再进入下一层</span><br><span class="line">            for(int i = 0; i &lt; n; i++)&#123; </span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                //添加下一层的左右节点</span><br><span class="line">                if(node.left != null) </span><br><span class="line">                    q.offer(node.left);</span><br><span class="line">                if(node.right != null)</span><br><span class="line">                    q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            //深度加1</span><br><span class="line">            res++; </span><br><span class="line">        &#125;</span><br><span class="line">        return res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用堆栈因该也可以，尝试想想</li>
</ul>
<h1 id="二叉树中和为某一个值的路径"><a href="#二叉树中和为某一个值的路径" class="headerlink" title="二叉树中和为某一个值的路径"></a>二叉树中和为某一个值的路径</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *   int val = 0;</span><br><span class="line"> *   TreeNode left = null;</span><br><span class="line"> *   TreeNode right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @param sum int整型 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    public boolean hasPathSum (TreeNode root, int sum) &#123;</span><br><span class="line">        return helper(root,sum,0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean helper(TreeNode node,int sum,int preSum)&#123;</span><br><span class="line">        if(node == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null)&#123;</span><br><span class="line">            return node.val + preSum == sum;</span><br><span class="line">        &#125;</span><br><span class="line">        preSum += node.val;</span><br><span class="line">        return helper(node.left,sum,preSum) || helper(node.right,sum ,preSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树和双向链表"><a href="#二叉搜索树和双向链表" class="headerlink" title="二叉搜索树和双向链表"></a>二叉搜索树和双向链表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    TreeNode pre= null;</span><br><span class="line">    TreeNode root=null;</span><br><span class="line">    public TreeNode Convert(TreeNode pRootOfTree) &#123;</span><br><span class="line">        if(pRootOfTree ==null) return null;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        if(root == null)&#123;</span><br><span class="line">            root=pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre!=null)&#123;</span><br><span class="line">            pRootOfTree.left=pre;</span><br><span class="line">            pre.right=pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客刷题</category>
      </categories>
  </entry>
</search>
