<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>枫叶冢</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>只有努力不会辜负你</description>
    <pubDate>Mon, 17 Oct 2022 15:54:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>数字及big类</title>
      <link>http://example.com/2022/10/17/%E6%95%B0%E5%AD%97%E7%B1%BB%E4%BB%A5%E5%8F%8Abig%E7%B1%BB/</link>
      <guid>http://example.com/2022/10/17/%E6%95%B0%E5%AD%97%E7%B1%BB%E4%BB%A5%E5%8F%8Abig%E7%B1%BB/</guid>
      <pubDate>Mon, 17 Oct 2022 09:44:10 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;关于数学包里常用的几个类&quot;&gt;&lt;a href=&quot;#关于数学包里常用的几个类&quot; class=&quot;headerlink&quot; title=&quot;关于数学包里常用的几个类&quot;&gt;&lt;/a&gt;关于数学包里常用的几个类&lt;/h1&gt;&lt;h2 id=&quot;abs&quot;&gt;&lt;a href=&quot;#abs&quot; class</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="关于数学包里常用的几个类"><a href="#关于数学包里常用的几个类" class="headerlink" title="关于数学包里常用的几个类"></a>关于数学包里常用的几个类</h1><h2 id="abs"><a href="#abs" class="headerlink" title="abs"></a>abs</h2><p>abs是取绝对值</p><h2 id="cell"><a href="#cell" class="headerlink" title="cell"></a>cell</h2><p>向上（正方向）取整</p><h2 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h2><p>向下（负方向）取整</p><h2 id="round"><a href="#round" class="headerlink" title="round"></a>round</h2><p> 四舍五入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> // 简单的例子 ，5舍6入</span><br><span class="line">可以通过floor进行</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h1><p>BigInteger类型的数字范围较Integer，Long类型的数字范围要大得多，它支持任意精度的整数，也就是说在运算中 BigInteger 类型可以准确地表示任何大小的整数值而不会丢失任何信息。</p><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//1.加</span><br><span class="line">BigInteger bigNum1 = a.add(b);//17</span><br><span class="line">//2.减</span><br><span class="line">BigInteger bigNum2 = a.subtract(b);//9</span><br><span class="line">//3.乘</span><br><span class="line">BigInteger bigNum3 = a.multiply(b);//52</span><br><span class="line">//4.除</span><br><span class="line">BigInteger bigNum4 = a.divide(b);//3</span><br><span class="line">//5.取模(需 b &gt; 0，否则出现异常：ArithmeticException(&quot;BigInteger: modulus not positive&quot;))</span><br><span class="line">BigInteger bigNum5 = a.mod(b);//1</span><br><span class="line">//6.求余</span><br><span class="line">BigInteger bigNum6 = a.remainder(b);//1</span><br><span class="line">//7.平方(需 n &gt;= 0，否则出现异常：ArithmeticException(&quot;Negative exponent&quot;))</span><br><span class="line">BigInteger bigNum7 = a.pow(n);//2197</span><br><span class="line">//8.取绝对值</span><br><span class="line">BigInteger bigNum8 = a.abs();//13</span><br><span class="line">//9.取相反数</span><br><span class="line">BigInteger bigNum9 = a.negate();//-13</span><br></pre></td></tr></table></figure><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//读入方法：nextBigInteger()</span><br><span class="line">@Test</span><br><span class="line">public void test5() &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);// 读入</span><br><span class="line">int n = scan.nextInt(); // 读入一个int;</span><br><span class="line">BigInteger m = scan.nextBigInteger();// 读入一个BigInteger;</span><br><span class="line">while(scan.hasNext())&#123;</span><br><span class="line">System.out.print(&quot;scan.hasNext()=&quot; + scan.hasNext());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中除了这个还有big浮点型，用法和上面一样</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%97%A5%E5%BF%97/">日志</category>
      
      
      
      <comments>http://example.com/2022/10/17/%E6%95%B0%E5%AD%97%E7%B1%BB%E4%BB%A5%E5%8F%8Abig%E7%B1%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java面试题</title>
      <link>http://example.com/2022/10/15/java%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/</link>
      <guid>http://example.com/2022/10/15/java%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/</guid>
      <pubDate>Sat, 15 Oct 2022 09:44:10 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;重载和重写&quot;&gt;&lt;a href=&quot;#重载和重写&quot; class=&quot;headerlink&quot; title=&quot;重载和重写&quot;&gt;&lt;/a&gt;重载和重写&lt;/h1&gt;&lt;h2 id=&quot;重载&quot;&gt;&lt;a href=&quot;#重载&quot; class=&quot;headerlink&quot; title=&quot;重载&quot;&gt;&lt;/a&gt;重</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载发生在同一个类里，方法名必须相同，参数类型不同，个数不同，顺序不同，方法的返回值和访问修饰符可以不同，发生在编译时</p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>发生在父类和子类中，方法名，参数列表相同，返回值范围小于等于父类，<br>抛出异常小于等于父类，访问修饰符大于等于父类，若父类的方法是private则不能重写</p><h1 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>list是有序的，按照插入对象的顺序进行访问的，可重复，，可以有多个null元素，可以用iterator取出所有元素，在逐一遍历还可以用get（index）获取指定元素</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>set是无序的，不可重复，，最多有一个null对象取元素的时候只能用iterator接口取出所有元素，再逐一遍历</p><h1 id="谈谈Concurrent-Hash-Map的扩容机制"><a href="#谈谈Concurrent-Hash-Map的扩容机制" class="headerlink" title="谈谈Concurrent Hash Map的扩容机制"></a>谈谈Concurrent Hash Map的扩容机制</h1><h2 id="1-7jdk"><a href="#1-7jdk" class="headerlink" title="1.7jdk"></a>1.7jdk</h2><ul><li><p>1.ConcurrentHashMap是基于Segment来实现的</p></li><li><p>2.每个Segment相当于是一个小型的HashMap</p></li><li><p>3.每个Segment内部都会进行扩容，和HashMap的扩容逻辑相同</p></li><li><p>4.先生成一个新的数组，然后转移元素到新数组中</p></li><li><p>5.扩容的判断也是每个Segment单独进行判断的</p></li></ul><h2 id="1-8jdk"><a href="#1-8jdk" class="headerlink" title="1.8jdk"></a>1.8jdk</h2><ul><li><p>1.到了1.8 就不基于Segment了</p></li><li><p>2.当某个线程进行put的时，如果发现有扩容的，就会优先跟着一起进行扩容，</p></li><li><p>3.如果发现没有进行扩容的，就会把key-value添加到ConcurrentHashMap中然后判断超过阈值了吗超过了则进行扩容</p></li><li><p>4.ConcurrentHashMap是支持多线程同时扩容的</p></li><li><p>5.扩容之前也先生成一个新数组</p></li><li><p>6.转移元素之前先将元素分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或者多组的元素转移工作</p></li></ul><h1 id="jdk1-7到1-8HashMap发生了什么变化"><a href="#jdk1-7到1-8HashMap发生了什么变化" class="headerlink" title="jdk1.7到1.8HashMap发生了什么变化"></a>jdk1.7到1.8HashMap发生了什么变化</h1><h2 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h2><p>其底层是数组加链表<br>使用的是头插法<br>哈希算法比较复杂</p><h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p>其底层是数组+链表和红黑树加入红黑树的目的是加快查找效率<br>其用的是尾插法，要先遍历数组的每个元素，判断数组中的元素个数<br>哈希算法进行了优化，节省cpu资源</p><h1 id="接口可以多继承接口"><a href="#接口可以多继承接口" class="headerlink" title="接口可以多继承接口"></a>接口可以多继承接口</h1><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><p>浅拷贝是指只会拷贝基础类型的值<br>浅拷贝是指拷贝的地址指向同一目标</p><h1 id="CopyOnwriteArrayList底层"><a href="#CopyOnwriteArrayList底层" class="headerlink" title="CopyOnwriteArrayList底层"></a>CopyOnwriteArrayList底层</h1><ul><li><p>1.首先其内部也是通过数组实现的，在向其中加元素的时候时，会复制一个新数组 ， 并在新数组上进行进行写操作 ， 读操作在原数组上进行</p></li><li><p>2.并且写操作会加锁，防止出现写入数据丢失的问题</p></li><li><p>3.写操作结束之后会把原数组指向新数组</p></li><li><p>4.CopyOnWriteArrayList允许在写数据的同时进行读数据，大大提高了效率因此适合读多写少的场景，但其比较占内存，因此读到的数据并不是最新的，因此适用与实时性不强的地方</p></li></ul><h1 id="什么是字节码-字节码的好处"><a href="#什么是字节码-字节码的好处" class="headerlink" title="什么是字节码 字节码的好处"></a>什么是字节码 字节码的好处</h1><p>编译器Javac会将java源文件编译为.class可以做到一次编译到此处运行，例如，windows上编译好的.class可以在linux上运行。</p><h2 id="采用字节码的好处"><a href="#采用字节码的好处" class="headerlink" title="采用字节码的好处"></a>采用字节码的好处</h2><p>一方面实现了跨平台，另外一方面提高了代码的执行效率，让编译器可以在编译时进行优化</p><h1 id="在java的异常处理机制中，什么时候要抛出异常，什么时候捕获异常"><a href="#在java的异常处理机制中，什么时候要抛出异常，什么时候捕获异常" class="headerlink" title="在java的异常处理机制中，什么时候要抛出异常，什么时候捕获异常"></a>在java的异常处理机制中，什么时候要抛出异常，什么时候捕获异常</h1><p>异常相当于一种提示 ， 若我们抛出异常，就相当于告诉上层方法，我抛出了一个异常，我处理不了这个异常给你来处理，如果上层也处理不了，就继续往上抛，或者捕获</p><h1 id="java中异常体系是怎么样的"><a href="#java中异常体系是怎么样的" class="headerlink" title="java中异常体系是怎么样的"></a>java中异常体系是怎么样的</h1><p>java中所有异常都来自于顶级父类 Throwable<br>Throwable下有两个子类Exceptio 和 erro<br>error属于重大错误：包括但不限于 虚拟机，磁盘，操作系统层面的问题<br>Exception属于普通编译器报错，其还分为运行时异常和编译时异常</p><h1 id="包装类型传参数的时候按照基本类型算，只传值，不传地址"><a href="#包装类型传参数的时候按照基本类型算，只传值，不传地址" class="headerlink" title="包装类型传参数的时候按照基本类型算，只传值，不传地址"></a>包装类型传参数的时候按照基本类型算，只传值，不传地址</h1><h1 id="java中的类加载机制"><a href="#java中的类加载机制" class="headerlink" title="java中的类加载机制"></a>java中的类加载机制</h1><p>jdk中自带了三个类加载器：</p><h2 id="BootStrap-ClassLoader"><a href="#BootStrap-ClassLoader" class="headerlink" title="BootStrap ClassLoader"></a>BootStrap ClassLoader</h2><p>BootStrap是Ext的父类加载器默认负责加载%JAVA_HOME%lib下面的lib和class</p><h2 id="Ext-ClassLoader"><a href="#Ext-ClassLoader" class="headerlink" title="Ext ClassLoader"></a>Ext ClassLoader</h2><p>Ext ClassLoader是AppClassLoader的父类，默认加载%JAVA_HOME%&#x2F;lib&#x2F;ext文件夹下的jar包和class</p><h2 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h2><p>AppClassLoader是自定义器的加载器的父类，负责加载classpath下的</p><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>简单来说就是当问题从最下面的类加载器进入的时候会先让最上面的类加载器加载，然后逐级往下，最后才是自己定义的类加载器</p><h1 id="排查JVM问题"><a href="#排查JVM问题" class="headerlink" title="排查JVM问题"></a>排查JVM问题</h1><h2 id="对于还可以正常运行的系统"><a href="#对于还可以正常运行的系统" class="headerlink" title="对于还可以正常运行的系统"></a>对于还可以正常运行的系统</h2><ul><li><p>可以使用jmap来查看各个区域的情况</p></li><li><p>可以通过jstack来查看线程的运行情况，比如xxx线程阻塞；是不是死锁等</p></li><li><p>可以通过jstat命令查看垃圾回收的情况 ， 特别是fullgc若fullgc比较多就要考虑调优了</p></li><li><p>通过各个命令的结果，或者jvisualvm等工具进行分析</p></li><li><p>猜测fullgc多的原因：如果无内存溢出，那么表示fullgc是回收了很多对象，所以这些对象最好能在younggc过程中直接回收，避免进入老年代，对于这些情况就要考虑存活区间是不是比较小，导致年轻代放不下，直接到了老年代，尝试加大年轻代的区间若改完fullgc变小，则猜想正确</p></li></ul><h2 id="对于已发生了OOM的系统"><a href="#对于已发生了OOM的系统" class="headerlink" title="对于已发生了OOM的系统"></a>对于已发生了OOM的系统</h2><ul><li>一般生产中都会设置系统发生了OOM时，生成当时的dump文件（-xx:+HeapDumpOnOutOfMemoryError -xx:HHEapDump Path &#x3D; &#x2F;user&#x2F;local&#x2F;base)</li><li>我们可以用jsvisualvm等工具进行分析dump</li><li>根据dump找到异常实例和线程（占用cpu高），定位到具体代码。</li><li>之后再做细致的分析</li></ul><h1 id="一个对象从加载到jvm到被Gc清楚都经历了什么"><a href="#一个对象从加载到jvm到被Gc清楚都经历了什么" class="headerlink" title="一个对象从加载到jvm到被Gc清楚都经历了什么"></a>一个对象从加载到jvm到被Gc清楚都经历了什么</h1><ul><li>先把字节码文件内容加载到方法区</li><li>然后再根据类信息在堆区域创建对象</li><li>对象首先会分配在堆中年轻代的Eden区经过一次Minorc之后会进入Survivor区，在后续的每次MinorGC中若一直存活，则会在Suvivor区来回拷贝，每拷贝一次每移动一次年龄加1</li><li>当年龄过15，若对象仍存活，会进入老年态</li><li>若经过fullgc，被标记为垃圾对象，那么会被gc线程清楚</li></ul><h1 id="jvm有哪些垃圾回收算法"><a href="#jvm有哪些垃圾回收算法" class="headerlink" title="jvm有哪些垃圾回收算法"></a>jvm有哪些垃圾回收算法</h1><h2 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h2><ul><li>标记阶段：把垃圾内存标记出来</li><li>清除阶段：直接把垃圾内存回收</li><li>问题：会产生大量的内存碎片</li></ul><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ul><li>为了解决标记清除的内存碎片的问题</li><li>将内存分为两份，每次只使用其中一半，垃圾回收时将当前这一块的存活对象完全拷贝到另外一半，而后当前这一半可直接清除，这种无内存碎片，但是浪费空间，且放弃和存活对象的个数相关</li></ul><h2 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h2><ul><li>为了解决复制算法的缺陷，就提出了标记压缩算法，这种算法在标记阶段跟标记清除算法是一样的，但是在完成之后不是直接清理，而是将存活的对象往一端移动，而后面将边界以外的所有内存清除</li></ul><h1 id="什么是STW"><a href="#什么是STW" class="headerlink" title="什么是STW"></a>什么是STW</h1><p>Stw-stop-the-world,是在垃圾回收算法执行过程中要将JVM内存冻结的一种状态，在STW状态下，java的所有线程都是停止执行的——GC除外，native方法可执行；但是不能与jvm交互GC各种算法的优化的重点便是减少STW,是jvm调优的重点</p><h1 id="jvm参数"><a href="#jvm参数" class="headerlink" title="jvm参数"></a>jvm参数</h1><ul><li>标注指令：开头这个是所有Hotspot都支持的参数，可以用java-help</li><li>非标注指令:-x开头；与特定的hotspot对立的用java-x打印</li><li>不稳定参数：-xx开头，与上面一样</li></ul><h1 id="对守护线程的理解"><a href="#对守护线程的理解" class="headerlink" title="对守护线程的理解"></a>对守护线程的理解</h1><p>线程分为 守护线程和用户线程</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>是jvm的后台线程，比如垃圾回收器，守护线程会在其他线程都停止之后自动关闭，我们可以通过设置thread.setDemon（true）来把一个线程设置成守护线程</p><h2 id="普通线程"><a href="#普通线程" class="headerlink" title="普通线程"></a>普通线程</h2><p>普通用户的线程</p><h1 id="ThreadLocal的底层原理"><a href="#ThreadLocal的底层原理" class="headerlink" title="ThreadLocal的底层原理"></a>ThreadLocal的底层原理</h1><p>其是java中所提供的线程本地存储机制，可利用该机制将数据存储到一个线程内部，该线程可在任意时刻，任意的方法，获取其存储的数据</p><ul><li>其底层是通过ThreadLocalMap来实现的，Map的key为ThreadLocal对象，Map的value为需要缓存的值</li><li>如果在线程池中使用ThreadLocal会造成内存泄露，因为当ThreadLoccal对象用完之后应该把设置的key value 也就是Entry的对象进行回收，但是线程池的线程不会进行回收，而线程对象是通过强引用指向ThreadLocalMap而ThreadLocalMap也是通过强引用的方法指向Entry的对象，线程也就不会被回收，从而出现内存泄露。</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>在使用了ThreadLocal对象之后，手动调Thread Local的remove方法，手动清除Entry，其经典应用是用在连接管理上</li></ul><h1 id="并发-并行-穿行的区别"><a href="#并发-并行-穿行的区别" class="headerlink" title="并发,并行,穿行的区别"></a>并发,并行,穿行的区别</h1><ul><li>串行：一个任务执行完才可以执行下一个</li><li>并发：两个任务看起来是一起执行的，在底层，两个任务被拆成了很多份，从而后一个执行，但是在更高处看，两个任务是一起执行的</li><li>并行：两个可以一起执行</li></ul><h1 id="java死锁如何避免"><a href="#java死锁如何避免" class="headerlink" title="java死锁如何避免"></a>java死锁如何避免</h1><ul><li>一个资源每次只被一个线程调用</li><li>一个线程在阻塞资源的时候不释放已经占有的资源</li><li>一个线程已经获得的资源在使用之前不可被强行剥夺</li><li>若干个线程形成头尾相接的循环等待状</li></ul><h1 id="说一下HashMap的put方法"><a href="#说一下HashMap的put方法" class="headerlink" title="说一下HashMap的put方法"></a>说一下HashMap的put方法</h1><h2 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h2><ul><li><p>1.根据key通过哈希算法与与运算得出数组的下标</p></li><li><p>2.如果数组下标的元素为空 ， 则将key和value封装为entry对象（1.7中是Entry ， 1.8里是node对象）并放入该位置</p></li></ul><h2 id="如果数组下标不为空，分情况讨论"><a href="#如果数组下标不为空，分情况讨论" class="headerlink" title="如果数组下标不为空，分情况讨论"></a>如果数组下标不为空，分情况讨论</h2><h3 id="1-7jdk-1"><a href="#1-7jdk-1" class="headerlink" title="1.7jdk"></a>1.7jdk</h3><ul><li>要先判断是不是要扩容，如果不扩容就生成Entry对象，并且用头插法添加到当前位置的链表中</li></ul><h3 id="1-8jdk-1"><a href="#1-8jdk-1" class="headerlink" title="1.8jdk"></a>1.8jdk</h3><ul><li>会先判断当前位置上node的类型，看是红黑树node还是链表node</li><li>如果是红黑树node，则会将key和value封装为一个红黑树节点并添加到红黑树中去，这个过程中会判断是不是有当前key，如果存在则更新value</li><li>如果此位置是node对象是链表节点，则将key和value封装为一个链表node并通过尾插法插到链表最后去，因为是尾插法所以要遍历整个链表，在遍历链表的过程中会判断是不是存在当前的key如果存在就更新key，当遍历完链表后，将新node插入到链表中，插入链表1后会看到当前链表的节点个数，如果大于等于8就会把这个链表转化为红黑树</li><li>将key和value封装为node插入到链表或红黑树中再判断是不是需要扩容如果需要就扩容，不需要就结束put方法</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/">Java中的易错点</category>
      
      
      
      <comments>http://example.com/2022/10/15/java%E4%B8%AD%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java中异常的相关知识</title>
      <link>http://example.com/2022/10/15/%E5%BC%82%E5%B8%B8/</link>
      <guid>http://example.com/2022/10/15/%E5%BC%82%E5%B8%B8/</guid>
      <pubDate>Sat, 15 Oct 2022 09:44:10 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h2&gt;&lt;h3 id=&quot;因为一些原因导致开发的程序出现问题&quot;&gt;&lt;a href=&quot;#因为一些原因导致开发的程序出现问题&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="因为一些原因导致开发的程序出现问题"><a href="#因为一些原因导致开发的程序出现问题" class="headerlink" title="因为一些原因导致开发的程序出现问题"></a>因为一些原因导致开发的程序出现问题</h3><p>Throwable是error和Exception的父类，是Java里所有异常的父类<br>##error<br>如果出现了error，则代表计算机出现了重大的错误，比如jvm无法解决的问题等。</p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>如果出现了Exception，则代表计算机代码出现了问题，编译或者运行的时候出现了问题。但是Exception还分为运行时异常和编译时异常</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>运行时异常比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayIndexOutOfBoundsException//这就是个数组越界的异常</span><br></pre></td></tr></table></figure><p>这些都是运行的时候产生的异常，编译可以通过的，其中最常见的就是数组越界，下表越剧等</p><h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>编译时异常比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The final local variable m cannot be assigned. It must be blank and not using a compound assignment //这个就是个简单的final修饰的变量不可被改变的异常</span><br></pre></td></tr></table></figure><p>这些是在程序未被运行之前就报出的错误。会被编译器会进行优先的处理。<br>最常见的就是作用域的问题，比如static变量和非static的变量等。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><p>我们可以通过try catch的方法进行捕获异常，让异常出现的时候不至于停止程序的运行<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try &#123;//放会报错的语句，这个是个简单数组越界</span><br><span class="line">a[m] = 1;</span><br><span class="line">System.out.println(&quot;输入正确&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO: handle exception</span><br><span class="line">// 在错误发生时怎么处理</span><br><span class="line">System.out.println(&quot;成功抛出异常&quot;);</span><br><span class="line">&#125; </span><br><span class="line">catch(xxxxx) &#123;</span><br><span class="line">&#125;// 这里的catch还可以继续往下写，但是要注意其中异常的类型必须是越在后面类型越大的，因为Exception还分多个子类异常，这样可以更精确的分辨是什么异常，不过直接写Exception也不算错</span><br><span class="line">finally &#123;</span><br><span class="line">// finally里放一定会执行的代码，不过不写finally也不算错</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是要注意，我们不可以捕获error异常，因为error异常已经超出了代码捕获的范围，我们一般都要进行硬件及软件的处理</p><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>我们可以通过throws把异常向上抛出，让他们的上层去处理，可是一般上层如果不能处理，还会继续向上抛出，这种方法我简称为逃避，我们，一般使用try catch语句较多，一般是抛到main方法里进行try catch处理，<br>如果异常一直不处理，那编译器最后会报错</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/javase/">javase</category>
      
      
      
      <comments>http://example.com/2022/10/15/%E5%BC%82%E5%B8%B8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://example.com/2022/10/15/hello-world/</link>
      <guid>http://example.com/2022/10/15/hello-world/</guid>
      <pubDate>Fri, 14 Oct 2022 16:33:54 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">$ hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2022/10/15/hello-world/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
